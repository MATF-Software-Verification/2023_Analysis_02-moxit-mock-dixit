--------------------------------------------------------------------------------
I1 cache:         65536 B, 64 B, 2-way associative
D1 cache:         65536 B, 64 B, 2-way associative
LL cache:         262144 B, 64 B, 8-way associative
Command:          ./../backend/build/moxit-backend
Data file:        cachegrind.out.8000
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                   I1mr               ILmr             Dr                   D1mr             DLmr             Dw                  D1mw             DLmw            
--------------------------------------------------------------------------------
431,548,731 (100.0%) 2,702,427 (100.0%) 127,646 (100.0%) 110,410,112 (100.0%) 470,074 (100.0%) 101,586 (100.0%) 68,522,098 (100.0%) 246,122 (100.0%) 82,076 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                  I1mr             ILmr            Dr                  D1mr             DLmr            Dw                  D1mw             DLmw             file:function
--------------------------------------------------------------------------------
90,481,849 (20.97%) 837,071 (30.97%) 25,938 (20.32%) 22,265,784 (20.17%) 166,480 (35.42%) 23,552 (23.18%) 10,740,765 (15.67%)   5,670 ( 2.30%)    608 ( 0.74%)  ???:???
38,272,675 ( 8.87%)   7,873 ( 0.29%)  2,799 ( 2.19%) 11,621,161 (10.53%)  14,606 ( 3.11%)  1,509 ( 1.49%)  5,978,043 ( 8.72%)     685 ( 0.28%)    142 ( 0.17%)  ./malloc/./malloc/malloc.c:_int_free
19,639,109 ( 4.55%)   9,330 ( 0.35%)    171 ( 0.13%)  5,018,802 ( 4.55%)  83,642 (17.79%)  3,486 ( 3.43%)  2,705,123 ( 3.95%)     143 ( 0.06%)      2 ( 0.00%)  ./malloc/./malloc/malloc.c:malloc
16,022,235 ( 3.71%)  40,414 ( 1.50%)      8 ( 0.01%)  1,497,732 ( 1.36%)     142 ( 0.03%)      0           2,962,009 ( 4.32%)   1,993 ( 0.81%)    233 ( 0.28%)  ???:QArrayData::allocate(unsigned long, unsigned long, unsigned long, QFlags<QArrayData::AllocationOption>)
15,577,560 ( 3.61%)  58,080 ( 2.15%)    860 ( 0.67%)  1,496,802 ( 1.36%)     493 ( 0.10%)     20 ( 0.02%)  1,341,193 ( 1.96%)  37,410 (15.20%)     18 ( 0.02%)  ???:double_conversion::FastDtoa(double, double_conversion::FastDtoaMode, int, double_conversion::Vector<char>, int*, int*)
13,734,082 ( 3.18%)   6,400 ( 0.24%)    168 ( 0.13%)  3,345,614 ( 3.03%)  11,911 ( 2.53%)    316 ( 0.31%)  2,532,446 ( 3.70%) 127,700 (51.88%) 63,034 (76.80%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
13,271,224 ( 3.08%)  93,576 ( 3.46%)  1,148 ( 0.90%)  2,802,664 ( 2.54%)  22,370 ( 4.76%)  6,676 ( 6.57%)  1,726,608 ( 2.52%)  14,070 ( 5.72%)  4,874 ( 5.94%)  ./malloc/./malloc/malloc.c:_int_malloc
12,003,356 ( 2.78%)   2,269 ( 0.08%)    240 ( 0.19%)  4,911,788 ( 4.45%)   2,095 ( 0.45%)      5 ( 0.00%)  1,362,892 ( 1.99%)   1,889 ( 0.77%)    496 ( 0.60%)  ???:QByteArray::append(QByteArray const&)
 9,966,350 ( 2.31%) 116,653 ( 4.32%)     24 ( 0.02%)  3,624,070 ( 3.28%)   9,662 ( 2.06%)  1,876 ( 1.85%)  1,811,972 ( 2.64%)       0               0           ./malloc/./malloc/malloc.c:free
 9,230,163 ( 2.14%)  20,452 ( 0.76%)    281 ( 0.22%)  2,631,805 ( 2.38%)      24 ( 0.01%)      0           1,155,684 ( 1.69%)     940 ( 0.38%)    121 ( 0.15%)  ???:QByteArray::resize(int)
 7,293,456 ( 1.69%)   3,210 ( 0.12%)    236 ( 0.18%)  1,461,317 ( 1.32%)   4,704 ( 1.00%)  1,936 ( 1.91%)    940,869 ( 1.37%)   3,411 ( 1.39%)    329 ( 0.40%)  ./malloc/./malloc/malloc.c:_int_realloc
 7,145,868 ( 1.66%) 143,445 ( 5.31%)     39 ( 0.03%)  1,386,516 ( 1.26%)     613 ( 0.13%)    139 ( 0.14%)    746,590 ( 1.09%)     175 ( 0.07%)     11 ( 0.01%)  ./malloc/./malloc/malloc.c:realloc
 7,115,940 ( 1.65%)  49,745 ( 1.84%)      2 ( 0.00%)    474,396 ( 0.43%)       0               0                   0                0               0           ???:qCalculateBlockSize(unsigned long, unsigned long, unsigned long)
 5,821,407 ( 1.35%)   1,683 ( 0.06%)  1,220 ( 0.96%)  1,829,689 ( 1.66%)     186 ( 0.04%)      0             831,599 ( 1.21%)       0               0           ???:QByteArray::append(char const*)
 5,635,764 ( 1.31%)  45,395 ( 1.68%)    388 ( 0.30%)    890,040 ( 0.81%)     299 ( 0.06%)     19 ( 0.02%)  1,038,091 ( 1.51%)     607 ( 0.25%)     35 ( 0.04%)  ???:QString::fromLatin1_helper(char const*, int)
 4,856,681 ( 1.13%)   1,138 ( 0.04%)    127 ( 0.10%)  1,723,341 ( 1.56%)      44 ( 0.01%)      0             783,331 ( 1.14%)   1,441 ( 0.59%)    362 ( 0.44%)  ???:QByteArray::append(char)
 4,170,544 ( 0.97%)  39,620 ( 1.47%)      1 ( 0.00%)    446,844 ( 0.40%)       0               0             446,844 ( 0.65%)   1,198 ( 0.49%)      0           ???:qCalculateGrowingBlockSize(unsigned long, unsigned long, unsigned long)
 3,920,532 ( 0.91%)   2,805 ( 0.10%)    440 ( 0.34%)  1,425,648 ( 1.29%)  19,223 ( 4.09%)  6,573 ( 6.47%)    445,515 ( 0.65%)     618 ( 0.25%)      9 ( 0.01%)  ???:QCborValue::toString(QString const&) const
 3,827,980 ( 0.89%)   3,927 ( 0.15%)    367 ( 0.29%)    564,380 ( 0.51%)      27 ( 0.01%)     25 ( 0.02%)    518,047 ( 0.76%)   5,617 ( 2.28%)      9 ( 0.01%)  ???:double_conversion::DoubleToStringConverter::DoubleToAscii(double, double_conversion::DoubleToStringConverter::DtoaMode, int, char*, int, bool*, int*, int*)
 3,744,774 ( 0.87%)  52,864 ( 1.96%)     13 ( 0.01%)    907,824 ( 0.82%)     331 ( 0.07%)     21 ( 0.02%)    680,868 ( 0.99%)      82 ( 0.03%)      1 ( 0.00%)  ???:QByteArray::setNum(double, char, int)
 3,622,537 ( 0.84%)   8,366 ( 0.31%)    194 ( 0.15%)    808,591 ( 0.73%)   2,079 ( 0.44%)    213 ( 0.21%)    767,738 ( 1.12%)      18 ( 0.01%)      0           ???:QCborValue::fromJsonValue(QJsonValue const&)
 3,571,665 ( 0.83%)   1,554 ( 0.06%)    671 ( 0.53%)  1,125,340 ( 1.02%)     113 ( 0.02%)      3 ( 0.00%)    679,825 ( 0.99%)   4,728 ( 1.92%)  1,562 ( 1.90%)  ???:QJsonArray::insert(int, QJsonValue const&)
 3,312,530 ( 0.77%)   7,319 ( 0.27%)    734 ( 0.58%)    898,625 ( 0.81%)     651 ( 0.14%)     18 ( 0.02%)    608,875 ( 0.89%)     868 ( 0.35%)    106 ( 0.13%)  ???:QJsonObject::operator[](QStringView)
 2,892,442 ( 0.67%) 180,978 ( 6.70%)    378 ( 0.30%)    413,397 ( 0.37%)   3,907 ( 0.83%)    742 ( 0.73%)          0                0               0           ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2
 2,773,004 ( 0.64%)     572 ( 0.02%)      1 ( 0.00%)    426,616 ( 0.39%)       7 ( 0.00%)      2 ( 0.00%)    639,924 ( 0.93%)     415 ( 0.17%)      0           ???:QArrayData::reallocateUnaligned(QArrayData*, unsigned long, unsigned long, QFlags<QArrayData::AllocationOption>)
 2,723,472 ( 0.63%)   2,244 ( 0.08%)      9 ( 0.01%)    794,346 ( 0.72%)       0               0             567,390 ( 0.83%)       0               0           ???:QString::toLatin1_helper_inplace(QString&)
 2,545,968 ( 0.59%)  22,469 ( 0.83%)    115 ( 0.09%)    424,328 ( 0.38%)   1,264 ( 0.27%)    704 ( 0.69%)    159,123 ( 0.23%)       0               0           ???:double_conversion::PowersOfTenCache::GetCachedPowerForBinaryExponentRange(int, int, double_conversion::DiyFp*, int*)
 2,494,482 ( 0.58%)  22,816 ( 0.84%)      3 ( 0.00%)    729,754 ( 0.66%)     138 ( 0.03%)      0             518,084 ( 0.76%)      44 ( 0.02%)     15 ( 0.02%)  ???:QByteArray::reallocData(unsigned int, QFlags<QArrayData::AllocationOption>)
 2,007,501 ( 0.47%)   1,719 ( 0.06%)  1,180 ( 0.92%)    298,768 ( 0.27%)       0               0                   0                0               0           ???:QJsonValue::type() const
 1,998,231 ( 0.46%)   2,735 ( 0.10%)    156 ( 0.12%)  1,023,723 ( 0.93%)       0               0             273,003 ( 0.40%)       0               0           /home/andrijanabos/Desktop/02-moxit-mock-dixit/backend/src/lib/server/moxit_server.cpp:MoxitServer::writeToClient(HttpStatus*)
 1,972,828 ( 0.46%)   1,700 ( 0.06%)      6 ( 0.00%)    358,696 ( 0.32%)       0               0             538,044 ( 0.79%)     193 ( 0.08%)     21 ( 0.03%)  ???:QByteArray::QByteArray(int, Qt::Initialization)
 1,862,665 ( 0.43%)   1,135 ( 0.04%)     22 ( 0.02%)      4,886 ( 0.00%)       0               0                   0                0               0           ???:QArrayData::deallocate(QArrayData*, unsigned long, unsigned long)
 1,653,382 ( 0.38%)   5,253 ( 0.19%)  2,115 ( 1.66%)    503,078 ( 0.46%)       1 ( 0.00%)      0             401,781 ( 0.59%)     195 ( 0.08%)     13 ( 0.02%)  /usr/include/c++/11/bits/basic_string.tcc:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char*>(char*, char*, std::forward_iterator_tag)
 1,627,797 ( 0.38%)  32,018 ( 1.18%)  2,361 ( 1.85%)    312,951 ( 0.28%)   3,067 ( 0.65%)    531 ( 0.52%)    358,227 ( 0.52%)      31 ( 0.01%)      1 ( 0.00%)  /home/andrijanabos/Desktop/02-moxit-mock-dixit/backend/src/lib/game/game.cpp:Game::toJson()
 1,478,412 ( 0.34%)   2,133 ( 0.08%)    148 ( 0.12%)    568,620 ( 0.52%)      11 ( 0.00%)      0             170,586 ( 0.25%)       0               0           ???:QString::operator=(QString const&)
 1,440,609 ( 0.33%)      43 ( 0.00%)     35 ( 0.03%)    250,529 ( 0.23%)   3,624 ( 0.77%)  3,046 ( 3.00%)     91,072 ( 0.13%)      57 ( 0.02%)     33 ( 0.04%)  ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x
 1,440,090 ( 0.33%)   1,169 ( 0.04%)    214 ( 0.17%)    933,993 ( 0.85%)   1,570 ( 0.33%)     92 ( 0.09%)    216,243 ( 0.32%)       0               0           ???:QCborValue::dispose()
 1,410,856 ( 0.33%)     117 ( 0.00%)     85 ( 0.07%)    483,694 ( 0.44%)  10,968 ( 2.33%)  4,259 ( 4.19%)    172,095 ( 0.25%)     104 ( 0.04%)     43 ( 0.05%)  ./elf/./elf/dl-lookup.c:do_lookup_x
 1,358,979 ( 0.31%)       0               0                   0                0               0                   0                0               0           ./malloc/./malloc/arena.c:free
 1,283,702 ( 0.30%)   1,768 ( 0.07%)    165 ( 0.13%)    340,574 ( 0.31%)      53 ( 0.01%)      0             445,366 ( 0.65%)     123 ( 0.05%)     14 ( 0.02%)  ???:QCborValue::QCborValue(QStringView)
 1,258,801 ( 0.29%)   3,366 ( 0.12%)    123 ( 0.10%)    373,166 ( 0.34%)     120 ( 0.03%)      1 ( 0.00%)    253,953 ( 0.37%)       0               0           ???:QJsonObject::setValueAt(int, QJsonValue const&)
 1,077,744 ( 0.25%)       9 ( 0.00%)      1 ( 0.00%)    404,154 ( 0.37%)       0               0             404,154 ( 0.59%)       0               0           /usr/include/c++/11/new:operator new(unsigned long, void*)
 1,064,232 ( 0.25%)     697 ( 0.03%)    339 ( 0.27%)    177,372 ( 0.16%)       1 ( 0.00%)      0             177,372 ( 0.26%)      24 ( 0.01%)      0           ???:operator new(unsigned long)
 1,024,480 ( 0.24%)   1,683 ( 0.06%)     57 ( 0.04%)    231,298 ( 0.21%)       0               0             264,581 ( 0.39%)     245 ( 0.10%)     15 ( 0.02%)  ???:QByteArray::QByteArray(int, char)
 1,003,976 ( 0.23%)   5,295 ( 0.20%)    222 ( 0.17%)    225,515 ( 0.20%)  11,614 ( 2.47%)  3,625 ( 3.57%)    130,215 ( 0.19%)     110 ( 0.04%)      3 ( 0.00%)  ./malloc/./malloc/malloc.c:malloc_consolidate
   950,895 ( 0.22%)   4,488 ( 0.17%)    343 ( 0.27%)    336,600 ( 0.30%)      28 ( 0.01%)      0             269,280 ( 0.39%)       0               0           /usr/include/c++/11/bits/vector.tcc:void std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_realloc_insert<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&)
   936,078 ( 0.22%)   1,135 ( 0.04%)      3 ( 0.00%)    212,745 ( 0.19%)       0               0             127,647 ( 0.19%)       0               0           ???:QJsonArray::detach2(unsigned int)
   907,629 ( 0.21%)   1,175 ( 0.04%)    472 ( 0.37%)    274,815 ( 0.25%)      13 ( 0.00%)      1 ( 0.00%)    219,177 ( 0.32%)       1 ( 0.00%)      1 ( 0.00%)  /usr/include/c++/11/bits/basic_string.tcc:void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag)
   881,804 ( 0.20%)   1,695 ( 0.06%)     54 ( 0.04%)    240,492 ( 0.22%)       0               0             120,246 ( 0.18%)       0               0           ???:QJsonObject::detach2(unsigned int)
   851,419 ( 0.20%)   1,153 ( 0.04%)     10 ( 0.01%)    310,507 ( 0.28%)  11,549 ( 2.46%)  5,807 ( 5.72%)     80,102 ( 0.12%)       0               0           ./malloc/./malloc/malloc.c:unlink_chunk.constprop.0
   818,723 ( 0.19%)  17,334 ( 0.64%)     75 ( 0.06%)    122,327 ( 0.11%)     401 ( 0.09%)      1 ( 0.00%)          0                0               0           ???:QtPrivate::isAscii(QStringView)
   805,792 ( 0.19%)   1,122 ( 0.04%)    181 ( 0.14%)    247,936 ( 0.22%)       5 ( 0.00%)      0             278,928 ( 0.41%)     124 ( 0.05%)     15 ( 0.02%)  /usr/include/c++/11/bits/stl_construct.h:void std::_Construct<std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&>(std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >*, std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&)
   794,346 ( 0.18%)     561 ( 0.02%)    213 ( 0.17%)    170,217 ( 0.15%)       0               0             226,956 ( 0.33%)       2 ( 0.00%)      0           ???:QByteArray::number(double, char, int)
   786,192 ( 0.18%)   3,370 ( 0.12%)    185 ( 0.14%)    196,548 ( 0.18%)     136 ( 0.03%)      4 ( 0.00%)    142,944 ( 0.21%)       0               0           /usr/include/c++/11/bits/regex_executor.tcc:std::__detail::_Executor<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::__cxx11::regex_traits<char>, true>::_M_dfs(std::__detail::_Executor<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::__cxx11::regex_traits<char>, true>::_Match_mode, long)
   776,622 ( 0.18%)   1,273 ( 0.05%)     20 ( 0.02%)    284,130 ( 0.26%)       0               0              75,768 ( 0.11%)       0               0           ???:QString::fromAscii_helper(char const*, int)
   766,080 ( 0.18%)     561 ( 0.02%)     17 ( 0.01%)    164,160 ( 0.15%)       0               0             218,880 ( 0.32%)       0               0           /usr/include/c++/11/bits/stl_construct.h:void std::_Construct<std::pair<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, int>>(std::pair<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, int>*)
   722,848 ( 0.17%)   2,810 ( 0.10%)     37 ( 0.03%)    309,792 ( 0.28%)     805 ( 0.17%)     84 ( 0.08%)    154,896 ( 0.23%)      54 ( 0.02%)      0           ???:std::basic_ostream<char, std::char_traits<char> >& std::__ostream_insert<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*, long)
   711,360 ( 0.16%)       2 ( 0.00%)      1 ( 0.00%)    218,880 ( 0.20%)       0               0             218,880 ( 0.32%)       0               0           /usr/include/c++/11/bits/stl_pair.h:std::pair<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, int>::pair<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, int, true>()
   701,676 ( 0.16%)     561 ( 0.02%)      1 ( 0.00%)    233,892 ( 0.21%)       0               0             233,892 ( 0.34%)   4,123 ( 1.68%)  1,183 ( 1.44%)  /usr/include/c++/11/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >::__normal_iterator()
   684,420 ( 0.16%)   1,691 ( 0.06%)      2 ( 0.00%)    205,326 ( 0.19%)       0               0             205,326 ( 0.30%)     157 ( 0.06%)      3 ( 0.00%)  /usr/include/c++/11/bits/hashtable_policy.h:std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true> > >::_M_node_allocator()
   661,514 ( 0.15%)  41,068 ( 1.52%)    136 ( 0.11%)     49,588 ( 0.04%)       0               0              99,236 ( 0.14%)   3,192 ( 1.30%)    742 ( 0.90%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
   644,436 ( 0.15%)     547 ( 0.02%)      1 ( 0.00%)    107,406 ( 0.10%)       0               0                   0                0               0           ./socket/../sysdeps/unix/sysv/linux/send.c:send
   639,924 ( 0.15%)  94,967 ( 3.51%)      1 ( 0.00%)          0                0               0                   0                0               0           ./malloc/./malloc/arena.c:realloc
   605,449 ( 0.14%)   1,132 ( 0.04%)     25 ( 0.02%)    279,438 ( 0.25%)     104 ( 0.02%)      0              93,146 ( 0.14%)       0               0           /usr/include/c++/11/bits/stl_vector.h:std::vector<int, std::allocator<int> >::size() const
   602,218 ( 0.14%)   1,170 ( 0.04%)     23 ( 0.02%)    171,488 ( 0.16%)       1 ( 0.00%)      0             132,744 ( 0.19%)       2 ( 0.00%)      0           /usr/include/c++/11/bits/regex_executor.tcc:std::__detail::_Executor<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::__cxx11::regex_traits<char>, true>::_M_handle_match(std::__detail::_Executor<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, std::__cxx11::regex_traits<char>, true>::_Match_mode, long)
   592,416 ( 0.14%)       3 ( 0.00%)      3 ( 0.00%)    135,762 ( 0.12%)       0               0             197,472 ( 0.29%)       0               0           /usr/include/c++/11/bits/hashtable_policy.h:std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true>* std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true> > >::_M_allocate_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&>(std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > const&)
   590,184 ( 0.14%)   2,248 ( 0.08%)    116 ( 0.09%)    155,127 ( 0.14%)     540 ( 0.11%)    269 ( 0.26%)     99,320 ( 0.14%)       0               0           ???:std::basic_streambuf<char, std::char_traits<char> >::xsputn(char const*, long)
   578,391 ( 0.13%)   7,270 ( 0.27%)    154 ( 0.12%)    203,643 ( 0.18%)       5 ( 0.00%)      0             145,860 ( 0.21%)      39 ( 0.02%)      0           /usr/include/c++/11/bits/hashtable.h:void std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_assign<std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true> > > >(std::_Hashtable<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::__detail::_Select1st, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> > const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true> > > const&)
   574,522 ( 0.13%)      25 ( 0.00%)     25 ( 0.02%)    143,428 ( 0.13%)   7,858 ( 1.67%)  7,318 ( 7.20%)     50,852 ( 0.07%)   4,883 ( 1.98%)  3,811 ( 4.64%)  ./elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
   569,647 ( 0.13%)     593 ( 0.02%)     26 ( 0.02%)    118,264 ( 0.11%)      68 ( 0.01%)      0             153,816 ( 0.22%)   1,739 ( 0.71%)    497 ( 0.61%)  ???:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&)
   558,338 ( 0.13%)   1,122 ( 0.04%)     14 ( 0.01%)    242,124 ( 0.22%)       0               0             128,810 ( 0.19%)       0               0           /usr/include/c++/11/bits/stl_uninitialized.h:std::pair<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, int>* std::__uninitialized_default_n_1<false>::__uninit_default_n<std::pair<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, int>*, unsigned long>(std::pair<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, int>*, unsigned long)
   556,519 ( 0.13%)   4,520 ( 0.17%)     36 ( 0.03%)     32,180 ( 0.03%)      16 ( 0.00%)      0             455,433 ( 0.66%)      55 ( 0.02%)      1 ( 0.00%)  /home/andrijanabos/Desktop/02-moxit-mock-dixit/backend/src/lib/server/moxit_server.cpp:MoxitServer::readFromClient(int, HttpStatus*)
   540,925 ( 0.13%)   1,167 ( 0.04%)     12 ( 0.01%)     86,548 ( 0.08%)       0               0             129,822 ( 0.19%)     844 ( 0.34%)    454 ( 0.55%)  ???:QString::QString(int, Qt::Initialization)
   538,560 ( 0.12%)     561 ( 0.02%)      1 ( 0.00%)    134,640 ( 0.12%)       0               0             185,130 ( 0.27%)       0               0           /usr/include/c++/11/bits/stl_uninitialized.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >* std::__relocate_a<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >&)
   535,212 ( 0.12%)   1,133 ( 0.04%)    212 ( 0.17%)    223,005 ( 0.20%)       0               0             133,803 ( 0.20%)       0               0           /usr/include/c++/11/bits/stl_vector.h:std::vector<int, std::allocator<int> >::operator[](unsigned long)
   522,291 ( 0.12%)   1,684 ( 0.06%)  1,181 ( 0.93%)    107,712 ( 0.10%)      74 ( 0.02%)      0              88,077 ( 0.13%)       0               0           ???:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::find(char const*, unsigned long, unsigned long) const
   522,080 ( 0.12%)     605 ( 0.02%)    554 ( 0.43%)    130,520 ( 0.12%)       0               0             163,150 ( 0.24%)      56 ( 0.02%)      0           /usr/include/c++/11/bits/stl_iterator_base_funcs.h:std::iterator_traits<char*>::difference_type std::distance<char*>(char*, char*)
   519,210 ( 0.12%)     547 ( 0.02%)      1 ( 0.00%)    173,070 ( 0.16%)       6 ( 0.00%)      0             103,842 ( 0.15%)       0               0           /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__detail::_State<char>, std::allocator<std::__detail::_State<char> > >::operator[](unsigned long) const
   488,070 ( 0.11%)   2,244 ( 0.08%)    142 ( 0.11%)    143,055 ( 0.13%)       0               0             126,225 ( 0.18%)       1 ( 0.00%)      0           /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_check_len(unsigned long, char const*) const
   479,276 ( 0.11%)  12,924 ( 0.48%)  1,241 ( 0.97%)     74,360 ( 0.07%)   1,606 ( 0.34%)    451 ( 0.44%)    113,544 ( 0.17%)       0               0           /home/andrijanabos/Desktop/02-moxit-mock-dixit/backend/src/lib/game/player.cpp:Player::toJson()
   479,094 ( 0.11%)     490 ( 0.02%)      0             205,326 ( 0.19%)       0               0             136,884 ( 0.20%)      87 ( 0.04%)      6 ( 0.01%)  /usr/include/c++/11/bits/hashtable_policy.h:std::__detail::_Hashtable_ebo_helper<0, std::allocator<std::__detail::_Hash_node<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, true> >, true>::_M_get()
   478,428 ( 0.11%)       8 ( 0.00%)      5 ( 0.00%)    147,396 ( 0.13%)   4,117 ( 0.88%)  2,134 ( 2.10%)          0                0               0           ???:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string()
   477,432 ( 0.11%)   1,120 ( 0.04%)      1 ( 0.00%)    150,768 ( 0.14%)       0               0             125,640 ( 0.18%)       0               0           /usr/include/x86_64-linux-gnu/qt5/QtCore/qrefcount.h:QtPrivate::RefCount::deref()
   474,045 ( 0.11%)      32 ( 0.00%)     20 ( 0.02%)    218,790 ( 0.20%)       0               0              72,930 ( 0.11%)       0               0           /usr/include/c++/11/bits/stl_vector.h:std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::size() const
   469,455 ( 0.11%)     603 ( 0.02%)      3 ( 0.00%)    190,439 ( 0.17%)      14 ( 0.00%)      1 ( 0.00%)      5,554 ( 0.01%)       0               0           ???:QJsonValue::~QJsonValue()
   461,142 ( 0.11%)   1,122 ( 0.04%)     19 ( 0.01%)    172,788 ( 0.16%)       0               0             141,372 ( 0.21%)       0               0           /usr/include/c++/11/bits/stl_uninitialized.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >* std::__relocate_a_1<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >&)
   460,020 ( 0.11%)     561 ( 0.02%)      4 ( 0.00%)    138,006 ( 0.12%)       0               0             138,006 ( 0.20%)       0               0           /usr/include/c++/11/ext/aligned_buffer.h:__gnu_cxx::__aligned_buffer<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_ptr()
   460,020 ( 0.11%)       1 ( 0.00%)      1 ( 0.00%)    138,006 ( 0.12%)       0               0             138,006 ( 0.20%)       0               0           /usr/include/c++/11/bits/hashtable_policy.h:std::__detail::_Hash_node_value_base<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_M_valptr()
   455,924 ( 0.11%)     564 ( 0.02%)     54 ( 0.04%)    143,976 ( 0.13%)       2 ( 0.00%)      0              95,984 ( 0.14%)       0               0           /usr/include/x86_64-linux-gnu/qt5/QtCore/qstring.h:QString::~QString()
   440,028 ( 0.10%)   7,367 ( 0.27%)    681 ( 0.53%)    160,115 ( 0.15%)       0               0              92,574 ( 0.14%)      10 ( 0.00%)      3 ( 0.00%)  /usr/include/c++/11/bits/vector.tcc:std::vector<std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::allocator<std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > >::operator=(std::vector<std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::allocator<std::__cxx11::sub_match<__gnu_cxx::__normal_iterator<char const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > const&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/vector.tcc
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr              D1mr        DLmr       Dw              D1mw        DLmw       

-- line 101 ----------------------------------------
      .              .            .               .           .          .               .           .          .           #if __cplusplus >= 201103L
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               template<typename... _Args>
      .              .            .               .           .          .               .           .          .           #if __cplusplus > 201402L
      .              .            .               .           .          .               .           .          .                 typename vector<_Tp, _Alloc>::reference
      .              .            .               .           .          .               .           .          .           #else
      .              .            .               .           .          .               .           .          .                 void
      .              .            .               .           .          .               .           .          .           #endif
 63,959 ( 0.01%)   562 ( 0.02%)   5 ( 0.00%)      0           0          0          36,548 ( 0.05%)  0          0                 vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .                 emplace_back(_Args&&... __args)
      .              .            .               .           .          .               .           .          .                 {
 54,822 ( 0.01%)     0            0          36,548 ( 0.03%)  0          0               0           0          0           	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      .              .            .               .           .          .               .           .          .           	  {
      .              .            .               .           .          .               .           .          .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
  6,610 ( 0.00%)     0            0           2,644 ( 0.00%)  0          0           1,322 ( 0.00%)  0          0           	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
      .              .            .               .           .          .               .           .          .           				     std::forward<_Args>(__args)...);
  3,966 ( 0.00%)     0            0           1,983 ( 0.00%)  0          0             661 ( 0.00%)  0          0           	    ++this->_M_impl._M_finish;
      .              .            .               .           .          .               .           .          .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
      .              .            .               .           .          .               .           .          .           	  }
      .              .            .               .           .          .               .           .          .           	else
110,188 ( 0.03%)   565 ( 0.02%)   6 ( 0.00%) 25,428 ( 0.02%)  0          0          25,428 ( 0.04%)  0          0           	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
      .              .            .               .           .          .               .           .          .           #if __cplusplus > 201402L
 27,411 ( 0.01%)     0            0           9,137 ( 0.01%)  0          0           9,137 ( 0.01%)  0          0           	return back();
      .              .            .               .           .          .               .           .          .           #endif
 27,411 ( 0.01%)     0            0          27,411 ( 0.02%)  0          0               0           0          0                 }
      .              .            .               .           .          .               .           .          .           #endif
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               typename vector<_Tp, _Alloc>::iterator
      .              .            .               .           .          .               .           .          .               vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .           #if __cplusplus >= 201103L
      .              .            .               .           .          .               .           .          .               insert(const_iterator __position, const value_type& __x)
      .              .            .               .           .          .               .           .          .           #else
-- line 133 ----------------------------------------
-- line 163 ----------------------------------------
      .              .            .               .           .          .               .           .          .           	_M_realloc_insert(__position, __x);
      .              .            .               .           .          .               .           .          .           #endif
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .                 return iterator(this->_M_impl._M_start + __n);
      .              .            .               .           .          .               .           .          .               }
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               typename vector<_Tp, _Alloc>::iterator
    120 ( 0.00%)    12 ( 0.00%)  12 ( 0.01%)     12 ( 0.00%)  0          0              60 ( 0.00%)  0          0               vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .               _M_erase(iterator __position)
      .              .            .               .           .          .               .           .          .               {
    192 ( 0.00%)    12 ( 0.00%)  12 ( 0.01%)     12 ( 0.00%)  0          0              60 ( 0.00%)  0          0                 if (__position + 1 != end())
    154 ( 0.00%)    11 ( 0.00%)  11 ( 0.01%)     22 ( 0.00%)  0          0              33 ( 0.00%)  0          0           	_GLIBCXX_MOVE3(__position + 1, end(), __position);
     60 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)     36 ( 0.00%)  0          0              12 ( 0.00%)  0          0                 --this->_M_impl._M_finish;
     72 ( 0.00%)     0            0              36 ( 0.00%)  0          0              12 ( 0.00%)  0          0                 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      .              .            .               .           .          .               .           .          .                 _GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
     12 ( 0.00%)     0            0              12 ( 0.00%)  0          0               0           0          0                 return __position;
     72 ( 0.00%)    12 ( 0.00%)  12 ( 0.01%)     60 ( 0.00%)  0          0               0           0          0               }
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               typename vector<_Tp, _Alloc>::iterator
      .              .            .               .           .          .               .           .          .               vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .               _M_erase(iterator __first, iterator __last)
      .              .            .               .           .          .               .           .          .               {
      .              .            .               .           .          .               .           .          .                 if (__first != __last)
      .              .            .               .           .          .               .           .          .           	{
-- line 188 ----------------------------------------
-- line 190 ----------------------------------------
      .              .            .               .           .          .               .           .          .           	    _GLIBCXX_MOVE3(__last, end(), __first);
      .              .            .               .           .          .               .           .          .           	  _M_erase_at_end(__first.base() + (end() - __last));
      .              .            .               .           .          .               .           .          .           	}
      .              .            .               .           .          .               .           .          .                 return __first;
      .              .            .               .           .          .               .           .          .               }
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               vector<_Tp, _Alloc>&
 44,400 ( 0.01%)     5 ( 0.00%)   4 ( 0.00%)      0           0          0          31,080 ( 0.05%)  0          0               vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .               operator=(const vector<_Tp, _Alloc>& __x)
      .              .            .               .           .          .               .           .          .               {
 13,320 ( 0.00%)   561 ( 0.02%)  38 ( 0.03%)  8,880 ( 0.01%)  0          0               0           0          0                 if (&__x != this)
      .              .            .               .           .          .               .           .          .           	{
      .              .            .               .           .          .               .           .          .           	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
      .              .            .               .           .          .               .           .          .           #if __cplusplus >= 201103L
 13,320 ( 0.00%)     0            0               0           0          0           4,440 ( 0.01%) 10 ( 0.00%) 3 ( 0.00%)  	  if (_Alloc_traits::_S_propagate_on_copy_assign())
      .              .            .               .           .          .               .           .          .           	    {
      .              .            .               .           .          .               .           .          .           	      if (!_Alloc_traits::_S_always_equal()
      .              .            .               .           .          .               .           .          .           	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
      .              .            .               .           .          .               .           .          .           	        {
      .              .            .               .           .          .               .           .          .           		  // replacement allocator cannot free existing storage
      .              .            .               .           .          .               .           .          .           		  this->clear();
      .              .            .               .           .          .               .           .          .           		  _M_deallocate(this->_M_impl._M_start,
      .              .            .               .           .          .               .           .          .           				this->_M_impl._M_end_of_storage
-- line 213 ----------------------------------------
-- line 215 ----------------------------------------
      .              .            .               .           .          .               .           .          .           		  this->_M_impl._M_start = nullptr;
      .              .            .               .           .          .               .           .          .           		  this->_M_impl._M_finish = nullptr;
      .              .            .               .           .          .               .           .          .           		  this->_M_impl._M_end_of_storage = nullptr;
      .              .            .               .           .          .               .           .          .           		}
      .              .            .               .           .          .               .           .          .           	      std::__alloc_on_copy(_M_get_Tp_allocator(),
      .              .            .               .           .          .               .           .          .           				   __x._M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           	    }
      .              .            .               .           .          .               .           .          .           #endif
 17,760 ( 0.00%) 1,405 ( 0.05%)  37 ( 0.03%)  4,440 ( 0.00%)  0          0           8,880 ( 0.01%)  0          0           	  const size_type __xlen = __x.size();
 31,080 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)  8,880 ( 0.01%)  0          0           4,440 ( 0.01%)  0          0           	  if (__xlen > capacity())
      .              .            .               .           .          .               .           .          .           	    {
 54,264 ( 0.01%) 1,056 ( 0.04%)  20 ( 0.02%) 15,504 ( 0.01%)  0          0          15,504 ( 0.02%)  0          0           	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
      .              .            .               .           .          .               .           .          .           						   __x.end());
 27,132 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%) 15,504 ( 0.01%)  0          0           3,876 ( 0.01%)  0          0           	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
 15,504 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)  3,876 ( 0.00%)  0          0           3,876 ( 0.01%)  0          0           			    _M_get_Tp_allocator());
 31,008 ( 0.01%) 2,106 ( 0.08%) 110 ( 0.09%) 11,628 ( 0.01%)  0          0           3,876 ( 0.01%)  0          0           	      _M_deallocate(this->_M_impl._M_start,
  7,752 ( 0.00%)     0            0           7,752 ( 0.01%)  0          0               0           0          0           			    this->_M_impl._M_end_of_storage
 31,005 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)  7,752 ( 0.01%)  0          0               0           0          0           			    - this->_M_impl._M_start);
 11,628 ( 0.00%)     0            0           7,752 ( 0.01%)  0          0           3,876 ( 0.01%)  0          0           	      this->_M_impl._M_start = __tmp;
 42,633 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%) 15,504 ( 0.01%)  0          0           3,876 ( 0.01%)  0          0           	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
      .              .            .               .           .          .               .           .          .           	    }
  3,948 ( 0.00%)   567 ( 0.02%)  19 ( 0.01%)  1,128 ( 0.00%)  0          0             564 ( 0.00%)  0          0           	  else if (size() >= __xlen)
      .              .            .               .           .          .               .           .          .           	    {
 13,536 ( 0.00%)   564 ( 0.02%)  99 ( 0.08%)  2,256 ( 0.00%)  0          0           3,384 ( 0.00%)  0          0           	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
  2,256 ( 0.00%)     0            0             564 ( 0.00%)  0          0             564 ( 0.00%)  0          0           			    end(), _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           	    }
      .              .            .               .           .          .               .           .          .           	  else
      .              .            .               .           .          .               .           .          .           	    {
      .              .            .               .           .          .               .           .          .           	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
      .              .            .               .           .          .               .           .          .           			this->_M_impl._M_start);
      .              .            .               .           .          .               .           .          .           	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
      .              .            .               .           .          .               .           .          .           					  __x._M_impl._M_finish,
      .              .            .               .           .          .               .           .          .           					  this->_M_impl._M_finish,
      .              .            .               .           .          .               .           .          .           					  _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           	    }
 44,388 ( 0.01%)   567 ( 0.02%) 141 ( 0.11%) 17,760 ( 0.02%)  0          0           4,440 ( 0.01%)  0          0           	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
      .              .            .               .           .          .               .           .          .           	}
  4,440 ( 0.00%)     0            0           4,440 ( 0.00%)  0          0               0           0          0                 return *this;
 31,080 ( 0.01%)   561 ( 0.02%) 234 ( 0.18%) 26,640 ( 0.02%)  0          0               0           0          0               }
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               void
 79,057 ( 0.02%)   561 ( 0.02%)   1 ( 0.00%)  7,187 ( 0.01%)  0          0          43,122 ( 0.06%)  0          0               vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .               _M_fill_assign(size_t __n, const value_type& __val)
      .              .            .               .           .          .               .           .          .               {
 50,309 ( 0.01%)     0            0          14,374 ( 0.01%)  0          0           7,187 ( 0.01%)  0          0                 if (__n > capacity())
      .              .            .               .           .          .               .           .          .           	{
 34,866 ( 0.01%)     0            0          11,622 ( 0.01%)  0          0           7,748 ( 0.01%)  0          0           	  vector __tmp(__n, __val, _M_get_Tp_allocator());
 19,370 ( 0.00%)   561 ( 0.02%)   7 ( 0.01%)  3,874 ( 0.00%)  0          0           3,874 ( 0.01%)  0          0           	  __tmp._M_impl._M_swap_data(this->_M_impl);
 11,622 ( 0.00%)     0            0               0           0          0           3,874 ( 0.01%)  0          0           	}
 23,191 ( 0.01%)     0            0           6,626 ( 0.01%)  0          0           3,313 ( 0.00%)  0          0                 else if (__n > size())
      .              .            .               .           .          .               .           .          .           	{
      .              .            .               .           .          .               .           .          .           	  std::fill(begin(), end(), __val);
      .              .            .               .           .          .               .           .          .           	  const size_type __add = __n - size();
      .              .            .               .           .          .               .           .          .           	  _GLIBCXX_ASAN_ANNOTATE_GROW(__add);
      .              .            .               .           .          .               .           .          .           	  this->_M_impl._M_finish =
      .              .            .               .           .          .               .           .          .           	    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      .              .            .               .           .          .               .           .          .           					  __add, __val, _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           	  _GLIBCXX_ASAN_ANNOTATE_GREW(__add);
      .              .            .               .           .          .               .           .          .           	}
      .              .            .               .           .          .               .           .          .                 else
 39,756 ( 0.01%)   561 ( 0.02%)  27 ( 0.02%) 16,565 ( 0.02%)  0          0           6,626 ( 0.01%)  0          0                   _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
 54,183 ( 0.01%)     0            0          35,935 ( 0.03%)  0          0               0           0          0               }
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               template<typename _InputIterator>
      .              .            .               .           .          .               .           .          .                 void
      .              .            .               .           .          .               .           .          .                 vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .                 _M_assign_aux(_InputIterator __first, _InputIterator __last,
      .              .            .               .           .          .               .           .          .           		    std::input_iterator_tag)
      .              .            .               .           .          .               .           .          .                 {
-- line 285 ----------------------------------------
-- line 418 ----------------------------------------
      .              .            .               .           .          .               .           .          .                 *__position = std::forward<_Arg>(__arg);
      .              .            .               .           .          .               .           .          .           #endif
      .              .            .               .           .          .               .           .          .               }
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .           #if __cplusplus >= 201103L
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               template<typename... _Args>
      .              .            .               .           .          .               .           .          .                 void
 93,643 ( 0.02%) 1,127 ( 0.04%)  72 ( 0.06%)  8,513 ( 0.01%)  0          0          51,078 ( 0.07%)  0          0                 vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .                 _M_realloc_insert(iterator __position, _Args&&... __args)
      .              .            .               .           .          .               .           .          .           #else
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               void
      .              .            .               .           .          .               .           .          .               vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .               _M_realloc_insert(iterator __position, const _Tp& __x)
      .              .            .               .           .          .               .           .          .           #endif
      .              .            .               .           .          .               .           .          .               {
      .              .            .               .           .          .               .           .          .                 const size_type __len =
 51,078 ( 0.01%)    17 ( 0.00%)   9 ( 0.01%)  8,513 ( 0.01%)  0          0          17,026 ( 0.02%)  0          0           	_M_check_len(size_type(1), "vector::_M_realloc_insert");
 25,539 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%) 17,026 ( 0.02%)  0          0           8,513 ( 0.01%)  0          0                 pointer __old_start = this->_M_impl._M_start;
 25,539 ( 0.01%)     0            0          17,026 ( 0.02%)  0          0           8,513 ( 0.01%)  0          0                 pointer __old_finish = this->_M_impl._M_finish;
 85,130 ( 0.02%)   578 ( 0.02%)  20 ( 0.02%)  8,513 ( 0.01%)  0          0          34,052 ( 0.05%)  0          0                 const size_type __elems_before = __position - begin();
 51,078 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%) 17,026 ( 0.02%)  0          0          17,026 ( 0.02%)  0          0                 pointer __new_start(this->_M_allocate(__len));
 17,026 ( 0.00%)     0            0           8,513 ( 0.01%)  0          0           8,513 ( 0.01%)  0          0                 pointer __new_finish(__new_start);
      .              .            .               .           .          .               .           .          .                 __try
      .              .            .               .           .          .               .           .          .           	{
      .              .            .               .           .          .               .           .          .           	  // The order of the three operations is dictated by the C++11
      .              .            .               .           .          .               .           .          .           	  // case, where the moves could alter a new element belonging
      .              .            .               .           .          .               .           .          .           	  // to the existing vector.  This is an issue only for callers
      .              .            .               .           .          .               .           .          .           	  // taking the element by lvalue ref (see last bullet of C++11
      .              .            .               .           .          .               .           .          .           	  // [res.on.arguments]).
 85,194 ( 0.02%)   566 ( 0.02%)  12 ( 0.01%) 25,539 ( 0.02%)  0          0          17,026 ( 0.02%)  0          0           	  _Alloc_traits::construct(this->_M_impl,
 25,697 ( 0.01%)    23 ( 0.00%)   5 ( 0.00%)  8,513 ( 0.01%)  0          0               0           0          0           				   __new_start + __elems_before,
      .              .            .               .           .          .               .           .          .           #if __cplusplus >= 201103L
      .              .            .               .           .          .               .           .          .           				   std::forward<_Args>(__args)...);
      .              .            .               .           .          .               .           .          .           #else
      .              .            .               .           .          .               .           .          .           				   __x);
      .              .            .               .           .          .               .           .          .           #endif
  8,513 ( 0.00%)     0            0               0           0          0           8,513 ( 0.01%)  0          0           	  __new_finish = pointer();
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .           #if __cplusplus >= 201103L
      .              .            .               .           .          .               .           .          .           	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
      .              .            .               .           .          .               .           .          .           	    {
 85,130 ( 0.02%)    14 ( 0.00%)   6 ( 0.00%) 25,539 ( 0.02%)  0          0          25,539 ( 0.04%)  0          0           	      __new_finish = _S_relocate(__old_start, __position.base(),
 34,052 ( 0.01%)   575 ( 0.02%)  50 ( 0.04%)  8,513 ( 0.01%)  0          0           8,513 ( 0.01%)  0          0           					 __new_start, _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           
  8,513 ( 0.00%)     0            0           8,513 ( 0.01%)  0          0               0           0          0           	      ++__new_finish;
      .              .            .               .           .          .               .           .          .           
 85,130 ( 0.02%)   586 ( 0.02%)  67 ( 0.05%) 25,539 ( 0.02%)  0          0          25,539 ( 0.04%)  0          0           	      __new_finish = _S_relocate(__position.base(), __old_finish,
 34,052 ( 0.01%)     3 ( 0.00%)   2 ( 0.00%)  8,513 ( 0.01%)  0          0           8,513 ( 0.01%)  0          0           					 __new_finish, _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           	    }
      .              .            .               .           .          .               .           .          .           	  else
      .              .            .               .           .          .               .           .          .           #endif
      .              .            .               .           .          .               .           .          .           	    {
      .              .            .               .           .          .               .           .          .           	      __new_finish
      .              .            .               .           .          .               .           .          .           		= std::__uninitialized_move_if_noexcept_a
      .              .            .               .           .          .               .           .          .           		(__old_start, __position.base(),
      .              .            .               .           .          .               .           .          .           		 __new_start, _M_get_Tp_allocator());
-- line 475 ----------------------------------------
-- line 492 ----------------------------------------
      .              .            .               .           .          .               .           .          .           	  _M_deallocate(__new_start, __len);
      .              .            .               .           .          .               .           .          .           	  __throw_exception_again;
      .              .            .               .           .          .               .           .          .           	}
      .              .            .               .           .          .               .           .          .           #if __cplusplus >= 201103L
      .              .            .               .           .          .               .           .          .                 if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
      .              .            .               .           .          .               .           .          .           #endif
      .              .            .               .           .          .               .           .          .           	std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .                 _GLIBCXX_ASAN_ANNOTATE_REINIT;
 42,565 ( 0.01%)   561 ( 0.02%)  26 ( 0.02%) 17,026 ( 0.02%)  0          0           8,513 ( 0.01%)  0          0                 _M_deallocate(__old_start,
 34,244 ( 0.01%)    14 ( 0.00%)   4 ( 0.00%) 25,539 ( 0.02%) 28 ( 0.01%) 0               0           0          0           		    this->_M_impl._M_end_of_storage - __old_start);
 25,539 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%) 17,026 ( 0.02%)  0          0           8,513 ( 0.01%)  0          0                 this->_M_impl._M_start = __new_start;
 25,539 ( 0.01%)    13 ( 0.00%)   5 ( 0.00%) 17,026 ( 0.02%)  0          0           8,513 ( 0.01%)  0          0                 this->_M_impl._M_finish = __new_finish;
 59,749 ( 0.01%)    14 ( 0.00%)   4 ( 0.00%) 25,539 ( 0.02%)  0          0           8,513 ( 0.01%)  0          0                 this->_M_impl._M_end_of_storage = __new_start + __len;
 59,591 ( 0.01%)   567 ( 0.02%) 131 ( 0.10%) 42,565 ( 0.04%)  0          0               0           0          0               }
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               void
      .              .            .               .           .          .               .           .          .               vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .               _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
      .              .            .               .           .          .               .           .          .               {
      .              .            .               .           .          .               .           .          .                 if (__n != 0)
      .              .            .               .           .          .               .           .          .           	{
-- line 513 ----------------------------------------
-- line 603 ----------------------------------------
      .              .            .               .           .          .               .           .          .           	      this->_M_impl._M_end_of_storage = __new_start + __len;
      .              .            .               .           .          .               .           .          .           	    }
      .              .            .               .           .          .               .           .          .           	}
      .              .            .               .           .          .               .           .          .               }
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .           #if __cplusplus >= 201103L
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               void
      7 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      0           0          0               4 ( 0.00%)  0          0               vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .               _M_default_append(size_type __n)
      .              .            .               .           .          .               .           .          .               {
      2 ( 0.00%)     0            0               1 ( 0.00%)  0          0               0           0          0                 if (__n != 0)
      .              .            .               .           .          .               .           .          .           	{
      4 ( 0.00%)     0            0               1 ( 0.00%)  0          0               2 ( 0.00%)  0          0           	  const size_type __size = size();
      3 ( 0.00%)     0            0               2 ( 0.00%)  0          0               1 ( 0.00%)  0          0           	  size_type __navail = size_type(this->_M_impl._M_end_of_storage
      5 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      2 ( 0.00%)  0          0               0           0          0           					 - this->_M_impl._M_finish);
      .              .            .               .           .          .               .           .          .           
     13 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      5 ( 0.00%)  0          0               2 ( 0.00%)  0          0           	  if (__size > max_size() || __navail > max_size() - __size)
      .              .            .               .           .          .               .           .          .           	    __builtin_unreachable();
      .              .            .               .           .          .               .           .          .           
      3 ( 0.00%)     0            0               2 ( 0.00%)  0          0               0           0          0           	  if (__navail >= __n)
      .              .            .               .           .          .               .           .          .           	    {
      .              .            .               .           .          .               .           .          .           	      _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
      .              .            .               .           .          .               .           .          .           	      this->_M_impl._M_finish =
      .              .            .               .           .          .               .           .          .           		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
      .              .            .               .           .          .               .           .          .           						 __n, _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           	      _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
      .              .            .               .           .          .               .           .          .           	    }
      .              .            .               .           .          .               .           .          .           	  else
      .              .            .               .           .          .               .           .          .           	    {
      .              .            .               .           .          .               .           .          .           	      const size_type __len =
      7 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      2 ( 0.00%)  0          0               2 ( 0.00%)  0          0           		_M_check_len(__n, "vector::_M_default_append");
      6 ( 0.00%)     0            0               2 ( 0.00%)  0          0               2 ( 0.00%)  0          0           	      pointer __new_start(this->_M_allocate(__len));
      .              .            .               .           .          .               .           .          .           	      if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
      .              .            .               .           .          .               .           .          .           		{
      .              .            .               .           .          .               .           .          .           		  __try
      .              .            .               .           .          .               .           .          .           		    {
      8 ( 0.00%)     0            0               3 ( 0.00%)  0          0               1 ( 0.00%)  0          0           		      std::__uninitialized_default_n_a(__new_start + __size,
      4 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      1 ( 0.00%)  0          0               1 ( 0.00%)  0          0           			      __n, _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           		    }
      .              .            .               .           .          .               .           .          .           		  __catch(...)
      .              .            .               .           .          .               .           .          .           		    {
      .              .            .               .           .          .               .           .          .           		      _M_deallocate(__new_start, __len);
      .              .            .               .           .          .               .           .          .           		      __throw_exception_again;
      .              .            .               .           .          .               .           .          .           		    }
      7 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      5 ( 0.00%)  0          0               1 ( 0.00%)  0          0           		  _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
      4 ( 0.00%)     0            0               1 ( 0.00%)  0          0               1 ( 0.00%)  0          0           			      __new_start, _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           		}
      .              .            .               .           .          .               .           .          .           	      else
      .              .            .               .           .          .               .           .          .           		{
      .              .            .               .           .          .               .           .          .           		  pointer __destroy_from = pointer();
      .              .            .               .           .          .               .           .          .           		  __try
      .              .            .               .           .          .               .           .          .           		    {
      .              .            .               .           .          .               .           .          .           		      std::__uninitialized_default_n_a(__new_start + __size,
      .              .            .               .           .          .               .           .          .           			      __n, _M_get_Tp_allocator());
-- line 657 ----------------------------------------
-- line 667 ----------------------------------------
      .              .            .               .           .          .               .           .          .           				      _M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           		      _M_deallocate(__new_start, __len);
      .              .            .               .           .          .               .           .          .           		      __throw_exception_again;
      .              .            .               .           .          .               .           .          .           		    }
      .              .            .               .           .          .               .           .          .           		  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
      .              .            .               .           .          .               .           .          .           				_M_get_Tp_allocator());
      .              .            .               .           .          .               .           .          .           		}
      .              .            .               .           .          .               .           .          .           	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
      8 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      3 ( 0.00%)  0          0               1 ( 0.00%)  0          0           	      _M_deallocate(this->_M_impl._M_start,
      2 ( 0.00%)     0            0               2 ( 0.00%)  0          0               0           0          0           			    this->_M_impl._M_end_of_storage
      5 ( 0.00%)     0            0               2 ( 0.00%)  0          0               0           0          0           			    - this->_M_impl._M_start);
      3 ( 0.00%)     0            0               2 ( 0.00%)  0          0               1 ( 0.00%)  0          0           	      this->_M_impl._M_start = __new_start;
      8 ( 0.00%)     0            0               4 ( 0.00%)  0          0               1 ( 0.00%)  0          0           	      this->_M_impl._M_finish = __new_start + __size + __n;
      6 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      3 ( 0.00%)  0          0               1 ( 0.00%)  0          0           	      this->_M_impl._M_end_of_storage = __new_start + __len;
      .              .            .               .           .          .               .           .          .           	    }
      .              .            .               .           .          .               .           .          .           	}
      5 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      3 ( 0.00%)  0          0               0           0          0               }
      .              .            .               .           .          .               .           .          .           
      .              .            .               .           .          .               .           .          .             template<typename _Tp, typename _Alloc>
      .              .            .               .           .          .               .           .          .               bool
      .              .            .               .           .          .               .           .          .               vector<_Tp, _Alloc>::
      .              .            .               .           .          .               .           .          .               _M_shrink_to_fit()
      .              .            .               .           .          .               .           .          .               {
      .              .            .               .           .          .               .           .          .                 if (capacity() == size())
      .              .            .               .           .          .               .           .          .           	return false;
-- line 691 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_iterator_base_funcs.h
--------------------------------------------------------------------------------
Ir               I1mr         ILmr         Dr               D1mr       DLmr       Dw               D1mw        DLmw       

-- line 90 ----------------------------------------
      .            .            .                .          .          .                .           .          .           	  ++__n;
      .            .            .                .          .          .                .           .          .           	}
      .            .            .                .          .          .                .           .          .                 return __n;
      .            .            .                .          .          .                .           .          .               }
      .            .            .                .          .          .                .           .          .           
      .            .            .                .          .          .                .           .          .             template<typename _RandomAccessIterator>
      .            .            .                .          .          .                .           .          .               inline _GLIBCXX14_CONSTEXPR
      .            .            .                .          .          .                .           .          .               typename iterator_traits<_RandomAccessIterator>::difference_type
250,255 ( 0.06%) 584 ( 0.02%)   4 ( 0.00%)       0          0          0          150,153 ( 0.22%)  0          0               __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
      .            .            .                .          .          .                .           .          .                          random_access_iterator_tag)
      .            .            .                .          .          .                .           .          .               {
      .            .            .                .          .          .                .           .          .                 // concept requirements
      .            .            .                .          .          .                .           .          .                 __glibcxx_function_requires(_RandomAccessIteratorConcept<
      .            .            .                .          .          .                .           .          .           				  _RandomAccessIterator>)
100,102 ( 0.02%)   0            0          100,102 ( 0.09%) 0          0                0           0          0                 return __last - __first;
100,102 ( 0.02%)   0            0          100,102 ( 0.09%) 0          0                0           0          0               }
      .            .            .                .          .          .                .           .          .           
      .            .            .                .          .          .                .           .          .           #if _GLIBCXX_USE_CXX11_ABI
      .            .            .                .          .          .                .           .          .             // Forward declaration because of the qualified call in distance.
      .            .            .                .          .          .                .           .          .             template<typename _Tp>
      .            .            .                .          .          .                .           .          .               ptrdiff_t
      .            .            .                .          .          .                .           .          .               __distance(_GLIBCXX_STD_C::_List_iterator<_Tp>,
      .            .            .                .          .          .                .           .          .           	       _GLIBCXX_STD_C::_List_iterator<_Tp>,
      .            .            .                .          .          .                .           .          .           	       input_iterator_tag);
-- line 113 ----------------------------------------
-- line 130 ----------------------------------------
      .            .            .                .          .          .                .           .          .              *  n may be negative.
      .            .            .                .          .          .                .           .          .              *
      .            .            .                .          .          .                .           .          .              *  For random access iterators, this uses their @c + and @c - operations
      .            .            .                .          .          .                .           .          .              *  and are constant time.  For other %iterator classes they are linear time.
      .            .            .                .          .          .                .           .          .             */
      .            .            .                .          .          .                .           .          .             template<typename _InputIterator>
      .            .            .                .          .          .                .           .          .               inline _GLIBCXX17_CONSTEXPR
      .            .            .                .          .          .                .           .          .               typename iterator_traits<_InputIterator>::difference_type
300,306 ( 0.07%) 607 ( 0.02%) 556 ( 0.44%)       0          0          0          150,153 ( 0.22%)  0          0               distance(_InputIterator __first, _InputIterator __last)
      .            .            .                .          .          .                .           .          .               {
      .            .            .                .          .          .                .           .          .                 // concept requirements -- taken care of in __distance
250,255 ( 0.06%)   0            0          100,102 ( 0.09%) 0          0           50,051 ( 0.07%)  0          0                 return std::__distance(__first, __last,
150,153 ( 0.03%)   0            0                0          0          0           50,051 ( 0.07%) 56 ( 0.02%) 0           			     std::__iterator_category(__first));
100,102 ( 0.02%)   0            0          100,102 ( 0.09%) 0          0                0           0          0               }
      .            .            .                .          .          .                .           .          .           
      .            .            .                .          .          .                .           .          .             template<typename _InputIterator, typename _Distance>
      .            .            .                .          .          .                .           .          .               inline _GLIBCXX14_CONSTEXPR void
      .            .            .                .          .          .                .           .          .               __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
      .            .            .                .          .          .                .           .          .               {
      .            .            .                .          .          .                .           .          .                 // concept requirements
      .            .            .                .          .          .                .           .          .                 __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      .            .            .                .          .          .                .           .          .                 __glibcxx_assert(__n >= 0);
-- line 151 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/hashtable_policy.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr           DLmr           Dw               D1mw         DLmw        

-- line 85 ----------------------------------------
      .              .            .                .              .              .                .            .           .                 operator()(_Tp&& __x) const noexcept
      .              .            .                .              .              .                .            .           .                 { return std::forward<_Tp>(__x); }
      .              .            .                .              .              .                .            .           .             };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             struct _Select1st
      .              .            .                .              .              .                .            .           .             {
      .              .            .                .              .              .                .            .           .               template<typename _Tp>
      .              .            .                .              .              .                .            .           .                 auto
 30,666 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)       0              0              0           15,333 ( 0.02%)   0           0                 operator()(_Tp&& __x) const noexcept
      .              .            .                .              .              .                .            .           .                 -> decltype(std::get<0>(std::forward<_Tp>(__x)))
 35,777 ( 0.01%)    20 ( 0.00%)  12 ( 0.01%)  15,333 ( 0.01%)     0              0           10,222 ( 0.01%)   0           0                 { return std::get<0>(std::forward<_Tp>(__x)); }
      .              .            .                .              .              .                .            .           .             };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
      .              .            .                .              .              .                .            .           .               struct _Hashtable_alloc;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             // Functor recycling a pool of nodes and using allocation once the pool is
      .              .            .                .              .              .                .            .           .             // empty.
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
-- line 103 ----------------------------------------
-- line 106 ----------------------------------------
      .              .            .                .              .              .                .            .           .               private:
      .              .            .                .              .              .                .            .           .                 using __node_alloc_type = _NodeAlloc;
      .              .            .                .              .              .                .            .           .                 using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
      .              .            .                .              .              .                .            .           .                 using __node_alloc_traits =
      .              .            .                .              .              .                .            .           .           	typename __hashtable_alloc::__node_alloc_traits;
      .              .            .                .              .              .                .            .           .                 using __node_type = typename __hashtable_alloc::__node_type;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               public:
     18 ( 0.00%)     0            0                0              0              0               12 ( 0.00%)   0           0                 _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)
     27 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      18 ( 0.00%)     0              0                6 ( 0.00%)   0           0                 : _M_nodes(__nodes), _M_h(__h) { }
      .              .            .                .              .              .                .            .           .                 _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;
      .              .            .                .              .              .                .            .           .           
     15 ( 0.00%)     0            0                0              0              0                6 ( 0.00%)   0           0                 ~_ReuseOrAllocNode()
     30 ( 0.00%)     0            0               18 ( 0.00%)     0              0                3 ( 0.00%)   0           0                 { _M_h._M_deallocate_nodes(_M_nodes); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 template<typename _Arg>
      .              .            .                .              .              .                .            .           .           	__node_type*
      7 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0              0              0                4 ( 0.00%)   0           0           	operator()(_Arg&& __arg) const
      .              .            .                .              .              .                .            .           .           	{
      4 ( 0.00%)     0            0                2 ( 0.00%)     0              0                0            0           0           	  if (_M_nodes)
      .              .            .                .              .              .                .            .           .           	    {
      .              .            .                .              .              .                .            .           .           	      __node_type* __node = _M_nodes;
      .              .            .                .              .              .                .            .           .           	      _M_nodes = _M_nodes->_M_next();
      .              .            .                .              .              .                .            .           .           	      __node->_M_nxt = nullptr;
      .              .            .                .              .              .                .            .           .           	      auto& __a = _M_h._M_node_allocator();
      .              .            .                .              .              .                .            .           .           	      __node_alloc_traits::destroy(__a, __node->_M_valptr());
      .              .            .                .              .              .                .            .           .           	      __try
      .              .            .                .              .              .                .            .           .           		{
-- line 133 ----------------------------------------
-- line 136 ----------------------------------------
      .              .            .                .              .              .                .            .           .           		}
      .              .            .                .              .              .                .            .           .           	      __catch(...)
      .              .            .                .              .              .                .            .           .           		{
      .              .            .                .              .              .                .            .           .           		  _M_h._M_deallocate_node_ptr(__node);
      .              .            .                .              .              .                .            .           .           		  __throw_exception_again;
      .              .            .                .              .              .                .            .           .           		}
      .              .            .                .              .              .                .            .           .           	      return __node;
      .              .            .                .              .              .                .            .           .           	    }
      9 ( 0.00%)     0            0                3 ( 0.00%)     0              0                2 ( 0.00%)   0           0           	  return _M_h._M_allocate_node(std::forward<_Arg>(__arg));
      3 ( 0.00%)     0            0                3 ( 0.00%)     0              0                0            0           0           	}
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               private:
      .              .            .                .              .              .                .            .           .                 mutable __node_type* _M_nodes;
      .              .            .                .              .              .                .            .           .                 __hashtable_alloc& _M_h;
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             // Functor similar to the previous one but without any pool of nodes to
      .              .            .                .              .              .                .            .           .             // recycle.
-- line 153 ----------------------------------------
-- line 154 ----------------------------------------
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
      .              .            .                .              .              .                .            .           .               struct _AllocNode
      .              .            .                .              .              .                .            .           .               {
      .              .            .                .              .              .                .            .           .               private:
      .              .            .                .              .              .                .            .           .                 using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
      .              .            .                .              .              .                .            .           .                 using __node_type = typename __hashtable_alloc::__node_type;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               public:
 22,440 ( 0.01%)     0            0                0              0              0           13,464 ( 0.02%)   0           0                 _AllocNode(__hashtable_alloc& __h)
 26,928 ( 0.01%)     0            0           17,952 ( 0.02%)     0              0            4,488 ( 0.01%)   0           0                 : _M_h(__h) { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 template<typename _Arg>
      .              .            .                .              .              .                .            .           .           	__node_type*
 86,394 ( 0.02%)     0            0                0              0              0           49,368 ( 0.07%)   0           0           	operator()(_Arg&& __arg) const
135,762 ( 0.03%) 1,122 ( 0.04%)   4 ( 0.00%)  74,052 ( 0.07%)    34 ( 0.01%)     0           24,684 ( 0.04%)   0           0           	{ return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               private:
      .              .            .                .              .              .                .            .           .                 __hashtable_alloc& _M_h;
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             // Auxiliary types used for all instantiations of _Hashtable nodes
      .              .            .                .              .              .                .            .           .             // and iterators.
      .              .            .                .              .              .                .            .           .           
-- line 176 ----------------------------------------
-- line 211 ----------------------------------------
      .              .            .                .              .              .                .            .           .              *  template parameter of class template _Hashtable controls whether
      .              .            .                .              .              .                .            .           .              *  nodes also store a hash code. In some cases (e.g. strings) this
      .              .            .                .              .              .                .            .           .              *  may be a performance win.
      .              .            .                .              .              .                .            .           .              */
      .              .            .                .              .              .                .            .           .             struct _Hash_node_base
      .              .            .                .              .              .                .            .           .             {
      .              .            .                .              .              .                .            .           .               _Hash_node_base* _M_nxt;
      .              .            .                .              .              .                .            .           .           
171,963 ( 0.04%)   561 ( 0.02%)  27 ( 0.02%)  57,321 ( 0.05%)     0              0           57,321 ( 0.08%)   7 ( 0.00%)  7 ( 0.01%)      _Hash_node_base() noexcept : _M_nxt() { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
      .              .            .                .              .              .                .            .           .             };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /**
      .              .            .                .              .              .                .            .           .              *  struct _Hash_node_value_base
      .              .            .                .              .              .                .            .           .              *
      .              .            .                .              .              .                .            .           .              *  Node type with the value to store.
-- line 227 ----------------------------------------
-- line 229 ----------------------------------------
      .              .            .                .              .              .                .            .           .             template<typename _Value>
      .              .            .                .              .              .                .            .           .               struct _Hash_node_value_base
      .              .            .                .              .              .                .            .           .               {
      .              .            .                .              .              .                .            .           .                 typedef _Value value_type;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 __gnu_cxx::__aligned_buffer<_Value> _M_storage;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 _Value*
237,250 ( 0.05%) 1,401 ( 0.05%)   8 ( 0.01%)       0              0              0           94,900 ( 0.14%)   0           0                 _M_valptr() noexcept
237,250 ( 0.05%)     0            0          142,350 ( 0.13%)     0              0           47,450 ( 0.07%)   0           0                 { return _M_storage._M_ptr(); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 const _Value*
  5,920 ( 0.00%)     0            0                0              0              0            2,368 ( 0.00%)   0           0                 _M_valptr() const noexcept
  5,920 ( 0.00%)   560 ( 0.02%)  80 ( 0.06%)   3,552 ( 0.00%)     0              0            1,184 ( 0.00%)   1 ( 0.00%)  0                 { return _M_storage._M_ptr(); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 _Value&
 82,625 ( 0.02%) 1,397 ( 0.05%) 463 ( 0.36%)       0              0              0           33,050 ( 0.05%)   0           0                 _M_v() noexcept
 82,625 ( 0.02%)   277 ( 0.01%)  10 ( 0.01%)  49,575 ( 0.04%)     0              0           16,525 ( 0.02%)   0           0                 { return *_M_valptr(); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 const _Value&
  5,920 ( 0.00%)    23 ( 0.00%)  17 ( 0.01%)       0              0              0            2,368 ( 0.00%)   0           0                 _M_v() const noexcept
  5,920 ( 0.00%)   561 ( 0.02%)   2 ( 0.00%)   3,552 ( 0.00%)     0              0            1,184 ( 0.00%)   0           0                 { return *_M_valptr(); }
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /**
      .              .            .                .              .              .                .            .           .              *  Primary template struct _Hash_node_code_cache.
      .              .            .                .              .              .                .            .           .              */
      .              .            .                .              .              .                .            .           .             template<bool _Cache_hash_code>
      .              .            .                .              .              .                .            .           .               struct _Hash_node_code_cache
      .              .            .                .              .              .                .            .           .               { };
-- line 258 ----------------------------------------
-- line 269 ----------------------------------------
      .              .            .                .              .              .                .            .           .               : _Hash_node_value_base<_Value>
      .              .            .                .              .              .                .            .           .               , _Hash_node_code_cache<_Cache_hash_code>
      .              .            .                .              .              .                .            .           .               { };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /**
      .              .            .                .              .              .                .            .           .              *  Primary template struct _Hash_node.
      .              .            .                .              .              .                .            .           .              */
      .              .            .                .              .              .                .            .           .             template<typename _Value, bool _Cache_hash_code>
166,892 ( 0.04%)     9 ( 0.00%)   9 ( 0.01%)  45,516 ( 0.04%)     0              0           45,516 ( 0.07%)   0           0               struct _Hash_node
      .              .            .                .              .              .                .            .           .               : _Hash_node_base
      .              .            .                .              .              .                .            .           .               , _Hash_node_value<_Value, _Cache_hash_code>
      .              .            .                .              .              .                .            .           .               {
      .              .            .                .              .              .                .            .           .                 _Hash_node*
126,668 ( 0.03%) 1,941 ( 0.07%)  99 ( 0.08%)       0              0              0           63,334 ( 0.09%)   0           0                 _M_next() const noexcept
126,668 ( 0.03%)     0            0          126,668 ( 0.11%) 4,873 ( 1.04%) 1,071 ( 1.05%)       0            0           0                 { return static_cast<_Hash_node*>(this->_M_nxt); }
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /// Base class for node iterators.
      .              .            .                .              .              .                .            .           .             template<typename _Value, bool _Cache_hash_code>
      .              .            .                .              .              .                .            .           .               struct _Node_iterator_base
      .              .            .                .              .              .                .            .           .               {
      .              .            .                .              .              .                .            .           .                 using __node_type = _Hash_node<_Value, _Cache_hash_code>;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 __node_type* _M_cur;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 _Node_iterator_base() : _M_cur(nullptr) { }
 45,070 ( 0.01%) 1,570 ( 0.06%) 158 ( 0.12%)       0              0              0           27,042 ( 0.04%)   0           0                 _Node_iterator_base(__node_type* __p) noexcept
 54,084 ( 0.01%)     0            0           36,056 ( 0.03%)     0              0            9,014 ( 0.01%)   0           0                 : _M_cur(__p) { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 void
 15,100 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)       0              0              0            6,040 ( 0.01%)   0           0                 _M_incr() noexcept
 27,180 ( 0.01%)   272 ( 0.01%)  18 ( 0.01%)  15,100 ( 0.01%)     3 ( 0.00%)     0            6,040 ( 0.01%)   0           0                 { _M_cur = _M_cur->_M_next(); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 friend bool
  2,800 ( 0.00%)     0            0                0              0              0            1,680 ( 0.00%)   0           0                 operator==(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
      .              .            .                .              .              .                .            .           .                 noexcept
  4,480 ( 0.00%)   560 ( 0.02%) 125 ( 0.10%)   3,360 ( 0.00%)     0              0                0            0           0                 { return __x._M_cur == __y._M_cur; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .           #if __cpp_impl_three_way_comparison < 201907L
      .              .            .                .              .              .                .            .           .                 friend bool
 23,555 ( 0.01%)     0            0                0              0              0           14,133 ( 0.02%)   0           0                 operator!=(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
      .              .            .                .              .              .                .            .           .                 noexcept
 37,688 ( 0.01%)     2 ( 0.00%)   2 ( 0.00%)  28,266 ( 0.03%)     0              0                0            0           0                 { return __x._M_cur != __y._M_cur; }
      .              .            .                .              .              .                .            .           .           #endif
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /// Node iterators, used to iterate through all the hashtable.
      .              .            .                .              .              .                .            .           .             template<typename _Value, bool __constant_iterators, bool __cache>
      .              .            .                .              .              .                .            .           .               struct _Node_iterator
      .              .            .                .              .              .                .            .           .               : public _Node_iterator_base<_Value, __cache>
      .              .            .                .              .              .                .            .           .               {
-- line 319 ----------------------------------------
-- line 330 ----------------------------------------
      .              .            .                .              .              .                .            .           .           				  const value_type*, value_type*>::type;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 using reference = typename std::conditional<__constant_iterators,
      .              .            .                .              .              .                .            .           .           				  const value_type&, value_type&>::type;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 _Node_iterator() = default;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 explicit
 54,084 ( 0.01%) 1,689 ( 0.06%) 315 ( 0.25%)       0              0              0           27,042 ( 0.04%)   0           0                 _Node_iterator(__node_type* __p) noexcept
 72,112 ( 0.02%)    24 ( 0.00%)  12 ( 0.01%)  36,056 ( 0.03%)     0              0            9,014 ( 0.01%)   0           0                 : __base_type(__p) { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 reference
 15,100 ( 0.00%)   273 ( 0.01%)   5 ( 0.00%)       0              0              0            6,040 ( 0.01%)   0           0                 operator*() const noexcept
 21,140 ( 0.00%)     0            0           12,080 ( 0.01%)     0              0            3,020 ( 0.00%)   0           0                 { return this->_M_cur->_M_v(); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 pointer
  2,925 ( 0.00%)     6 ( 0.00%)   4 ( 0.00%)       0              0              0            1,170 ( 0.00%)   0           0                 operator->() const noexcept
  4,095 ( 0.00%)    24 ( 0.00%)  24 ( 0.02%)   2,340 ( 0.00%)     0              0              585 ( 0.00%)   0           0                 { return this->_M_cur->_M_valptr(); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 _Node_iterator&
 15,100 ( 0.00%)     0            0                0              0              0            6,040 ( 0.01%)   0           0                 operator++() noexcept
      .              .            .                .              .              .                .            .           .                 {
  9,060 ( 0.00%)     0            0            3,020 ( 0.00%)     0              0            3,020 ( 0.00%)   0           0           	this->_M_incr();
  3,020 ( 0.00%)     0            0            3,020 ( 0.00%)     0              0                0            0           0           	return *this;
  6,040 ( 0.00%)     0            0            6,040 ( 0.01%)     0              0                0            0           0                 }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 _Node_iterator
      .              .            .                .              .              .                .            .           .                 operator++(int) noexcept
      .              .            .                .              .              .                .            .           .                 {
      .              .            .                .              .              .                .            .           .           	_Node_iterator __tmp(*this);
      .              .            .                .              .              .                .            .           .           	this->_M_incr();
      .              .            .                .              .              .                .            .           .           	return __tmp;
      .              .            .                .              .              .                .            .           .                 }
-- line 362 ----------------------------------------
-- line 420 ----------------------------------------
      .              .            .                .              .              .                .            .           .             /// into the range [0, N).
      .              .            .                .              .              .                .            .           .             struct _Mod_range_hashing
      .              .            .                .              .              .                .            .           .             {
      .              .            .                .              .              .                .            .           .               typedef std::size_t first_argument_type;
      .              .            .                .              .              .                .            .           .               typedef std::size_t second_argument_type;
      .              .            .                .              .              .                .            .           .               typedef std::size_t result_type;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               result_type
121,716 ( 0.03%)    54 ( 0.00%)  12 ( 0.01%)       0              0              0           81,144 ( 0.12%)   1 ( 0.00%)  0               operator()(first_argument_type __num,
      .              .            .                .              .              .                .            .           .           	       second_argument_type __den) const noexcept
121,716 ( 0.03%)     0            0           81,144 ( 0.07%)     0              0                0            0           0               { return __num % __den; }
      .              .            .                .              .              .                .            .           .             };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /// Default ranged hash function H.  In principle it should be a
      .              .            .                .              .              .                .            .           .             /// function object composed from objects of type H1 and H2 such that
      .              .            .                .              .              .                .            .           .             /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
      .              .            .                .              .              .                .            .           .             /// h1 and h2.  So instead we'll just use a tag to tell class template
      .              .            .                .              .              .                .            .           .             /// hashtable to do that composition.
      .              .            .                .              .              .                .            .           .             struct _Default_ranged_hash { };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /// Default value for rehash policy.  Bucket size is (usually) the
      .              .            .                .              .              .                .            .           .             /// smallest prime that keeps the load factor small enough.
      .              .            .                .              .              .                .            .           .             struct _Prime_rehash_policy
      .              .            .                .              .              .                .            .           .             {
      .              .            .                .              .              .                .            .           .               using __has_load_factor = true_type;
      .              .            .                .              .              .                .            .           .           
  5,650 ( 0.00%)     2 ( 0.00%)   1 ( 0.00%)       0              0              0            3,390 ( 0.00%)   0           0               _Prime_rehash_policy(float __z = 1.0) noexcept
  9,040 ( 0.00%)   562 ( 0.02%)   1 ( 0.00%)   5,650 ( 0.01%)     0              0            2,260 ( 0.00%)   1 ( 0.00%)  1 ( 0.00%)      : _M_max_load_factor(__z), _M_next_resize(0) { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               float
      .              .            .                .              .              .                .            .           .               max_load_factor() const noexcept
      .              .            .                .              .              .                .            .           .               { return _M_max_load_factor; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               // Return a bucket size no smaller than n.
      .              .            .                .              .              .                .            .           .               std::size_t
      .              .            .                .              .              .                .            .           .               _M_next_bkt(std::size_t __n) const;
-- line 455 ----------------------------------------
-- line 465 ----------------------------------------
      .              .            .                .              .              .                .            .           .               // is the new bucket count.  If not, return make_pair(false, 0).
      .              .            .                .              .              .                .            .           .               std::pair<bool, std::size_t>
      .              .            .                .              .              .                .            .           .               _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
      .              .            .                .              .              .                .            .           .           		   std::size_t __n_ins) const;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               typedef std::size_t _State;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               _State
 18,060 ( 0.00%)   580 ( 0.02%)   0                0              0              0            9,030 ( 0.01%)   0           0               _M_state() const
 18,060 ( 0.00%)     0            0           18,060 ( 0.02%)    82 ( 0.02%)    20 ( 0.02%)       0            0           0               { return _M_next_resize; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               void
      .              .            .                .              .              .                .            .           .               _M_reset() noexcept
      .              .            .                .              .              .                .            .           .               { _M_next_resize = 0; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               void
      .              .            .                .              .              .                .            .           .               _M_reset(_State __state)
      .              .            .                .              .              .                .            .           .               { _M_next_resize = __state; }
-- line 482 ----------------------------------------
-- line 688 ----------------------------------------
      .              .            .                .              .              .                .            .           .                 const mapped_type&
      .              .            .                .              .              .                .            .           .                 at(const key_type& __k) const;
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
      .              .            .                .              .              .                .            .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .                .              .              .                .            .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .                .              .              .                .            .           .               auto
  6,060 ( 0.00%)   578 ( 0.02%)  48 ( 0.04%)     606 ( 0.00%)     0              0            3,030 ( 0.00%)   0           0               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
      .              .            .                .              .              .                .            .           .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
      .              .            .                .              .              .                .            .           .               operator[](const key_type& __k)
      .              .            .                .              .              .                .            .           .               -> mapped_type&
      .              .            .                .              .              .                .            .           .               {
  1,212 ( 0.00%)     0            0              606 ( 0.00%)     0              0              606 ( 0.00%)   0           0                 __hashtable* __h = static_cast<__hashtable*>(this);
  3,636 ( 0.00%)    20 ( 0.00%)  17 ( 0.01%)   1,212 ( 0.00%)     0              0            1,212 ( 0.00%)   0           0                 __hash_code __code = __h->_M_hash_code(__k);
  3,636 ( 0.00%)   561 ( 0.02%)  27 ( 0.02%)   1,212 ( 0.00%)     0              0            1,212 ( 0.00%)   0           0                 std::size_t __bkt = __h->_M_bucket_index(__code);
  5,454 ( 0.00%)    20 ( 0.00%)  19 ( 0.01%)   3,030 ( 0.00%)     0              0            1,212 ( 0.00%)   0           0                 if (auto __node = __h->_M_find_node(__bkt, __k, __code))
  3,510 ( 0.00%)   560 ( 0.02%) 118 ( 0.09%)     585 ( 0.00%)     0              0              585 ( 0.00%)   0           0           	return __node->_M_v().second;
      .              .            .                .              .              .                .            .           .           
    210 ( 0.00%)    22 ( 0.00%)  21 ( 0.02%)      21 ( 0.00%)     0              0               21 ( 0.00%)   0           0                 typename __hashtable::_Scoped_node __node {
      .              .            .                .              .              .                .            .           .           	__h,
      .              .            .                .              .              .                .            .           .           	std::piecewise_construct,
    105 ( 0.00%)     0            0               21 ( 0.00%)     0              0               21 ( 0.00%)   0           0           	std::tuple<const key_type&>(__k),
      .              .            .                .              .              .                .            .           .           	std::tuple<>()
      .              .            .                .              .              .                .            .           .                 };
      .              .            .                .              .              .                .            .           .                 auto __pos
    168 ( 0.00%)     0            0               84 ( 0.00%)     0              0               42 ( 0.00%)   0           0           	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
     21 ( 0.00%)    12 ( 0.00%)   7 ( 0.01%)       0              0              0               21 ( 0.00%)   0           0                 __node._M_node = nullptr;
     84 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0              0              0               21 ( 0.00%)   0           0                 return __pos->second;
  4,305 ( 0.00%) 1,141 ( 0.04%)  57 ( 0.04%)   3,030 ( 0.00%)     0              0               21 ( 0.00%)   0           0               }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
      .              .            .                .              .              .                .            .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .                .              .              .                .            .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .                .              .              .                .            .           .               auto
  5,800 ( 0.00%) 1,126 ( 0.04%) 174 ( 0.14%)     580 ( 0.00%)     0              0            2,900 ( 0.00%)   0           0               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
      .              .            .                .              .              .                .            .           .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
      .              .            .                .              .              .                .            .           .               operator[](key_type&& __k)
      .              .            .                .              .              .                .            .           .               -> mapped_type&
      .              .            .                .              .              .                .            .           .               {
  1,160 ( 0.00%)     0            0              580 ( 0.00%)     0              0              580 ( 0.00%)   0           0                 __hashtable* __h = static_cast<__hashtable*>(this);
  3,480 ( 0.00%)     7 ( 0.00%)   7 ( 0.01%)   1,160 ( 0.00%)     0              0            1,160 ( 0.00%)   0           0                 __hash_code __code = __h->_M_hash_code(__k);
  3,480 ( 0.00%)   561 ( 0.02%)  24 ( 0.02%)   1,160 ( 0.00%)     0              0            1,160 ( 0.00%)   0           0                 std::size_t __bkt = __h->_M_bucket_index(__code);
  5,220 ( 0.00%)     7 ( 0.00%)   7 ( 0.01%)   2,900 ( 0.00%)     0              0            1,160 ( 0.00%)   0           0                 if (auto __node = __h->_M_find_node(__bkt, __k, __code))
     96 ( 0.00%)     0            0               16 ( 0.00%)     0              0               16 ( 0.00%)   0           0           	return __node->_M_v().second;
      .              .            .                .              .              .                .            .           .           
  7,896 ( 0.00%) 1,125 ( 0.04%)  11 ( 0.01%)     564 ( 0.00%)     0              0            1,128 ( 0.00%)   0           0                 typename __hashtable::_Scoped_node __node {
      .              .            .                .              .              .                .            .           .           	__h,
      .              .            .                .              .              .                .            .           .           	std::piecewise_construct,
  2,256 ( 0.00%)     0            0              564 ( 0.00%)     0              0              564 ( 0.00%)   0           0           	std::forward_as_tuple(std::move(__k)),
      .              .            .                .              .              .                .            .           .           	std::tuple<>()
      .              .            .                .              .              .                .            .           .                 };
      .              .            .                .              .              .                .            .           .                 auto __pos
  4,512 ( 0.00%)     3 ( 0.00%)   3 ( 0.00%)   2,256 ( 0.00%)     0              0            1,128 ( 0.00%)   0           0           	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
    564 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)       0              0              0              564 ( 0.00%)   0           0                 __node._M_node = nullptr;
  2,256 ( 0.00%)     0            0                0              0              0              564 ( 0.00%)   0           0                 return __pos->second;
  5,752 ( 0.00%)    13 ( 0.00%)  12 ( 0.01%)   2,900 ( 0.00%)     0              0              564 ( 0.00%)   0           0               }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
      .              .            .                .              .              .                .            .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .                .              .              .                .            .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .                .              .              .                .            .           .               auto
      .              .            .                .              .              .                .            .           .               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
      .              .            .                .              .              .                .            .           .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
      .              .            .                .              .              .                .            .           .               at(const key_type& __k)
-- line 752 ----------------------------------------
-- line 807 ----------------------------------------
      .              .            .                .              .              .                .            .           .                 using value_type = typename __hashtable_base::value_type;
      .              .            .                .              .              .                .            .           .                 using size_type = typename __hashtable_base::size_type;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 using __unique_keys = typename _Traits::__unique_keys;
      .              .            .                .              .              .                .            .           .                 using __node_alloc_type = typename __hashtable_alloc::__node_alloc_type;
      .              .            .                .              .              .                .            .           .                 using __node_gen_type = _AllocNode<__node_alloc_type>;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 __hashtable&
  6,732 ( 0.00%)     0            0                0              0              0            3,366 ( 0.00%)   0           0                 _M_conjure_hashtable()
  5,049 ( 0.00%)     0            0            5,049 ( 0.00%)     0              0                0            0           0                 { return *(static_cast<__hashtable*>(this)); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 template<typename _InputIterator, typename _NodeGetter>
      .              .            .                .              .              .                .            .           .           	void
      .              .            .                .              .              .                .            .           .           	_M_insert_range(_InputIterator __first, _InputIterator __last,
      .              .            .                .              .              .                .            .           .           			const _NodeGetter&, true_type __uks);
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 template<typename _InputIterator, typename _NodeGetter>
      .              .            .                .              .              .                .            .           .           	void
-- line 824 ----------------------------------------
-- line 832 ----------------------------------------
      .              .            .                .              .              .                .            .           .                 using const_iterator = _Node_const_iterator<_Value, __constant_iterators::value,
      .              .            .                .              .              .                .            .           .           						  __hash_cached::value>;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 using __ireturn_type = typename std::conditional<__unique_keys::value,
      .              .            .                .              .              .                .            .           .           						     std::pair<iterator, bool>,
      .              .            .                .              .              .                .            .           .           						     iterator>::type;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 __ireturn_type
 15,147 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)   1,683 ( 0.00%)     0              0            6,732 ( 0.01%)   0           0                 insert(const value_type& __v)
      .              .            .                .              .              .                .            .           .                 {
  6,732 ( 0.00%)     0            0            1,683 ( 0.00%)     0              0            3,366 ( 0.00%)   0           0           	__hashtable& __h = _M_conjure_hashtable();
  8,415 ( 0.00%)     0            0            1,683 ( 0.00%)     0              0            1,683 ( 0.00%)   0           0           	__node_gen_type __node_gen(__h);
 10,098 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)   3,366 ( 0.00%)     0              0            1,683 ( 0.00%)   0           0           	return __h._M_insert(__v, __node_gen, __unique_keys{});
  8,415 ( 0.00%)     0            0            6,732 ( 0.01%)     0              0                0            0           0                 }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 iterator
      .              .            .                .              .              .                .            .           .                 insert(const_iterator __hint, const value_type& __v)
      .              .            .                .              .              .                .            .           .                 {
      .              .            .                .              .              .                .            .           .           	__hashtable& __h = _M_conjure_hashtable();
      .              .            .                .              .              .                .            .           .           	__node_gen_type __node_gen(__h);	
      .              .            .                .              .              .                .            .           .           	return __h._M_insert(__hint, __v, __node_gen, __unique_keys{});
      .              .            .                .              .              .                .            .           .                 }
-- line 853 ----------------------------------------
-- line 1116 ----------------------------------------
      .              .            .                .              .              .                .            .           .              *  final) and when it is worth it (the type is empty.)
      .              .            .                .              .              .                .            .           .              */
      .              .            .                .              .              .                .            .           .             template<int _Nm, typename _Tp,
      .              .            .                .              .              .                .            .           .           	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
      .              .            .                .              .              .                .            .           .               struct _Hashtable_ebo_helper;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /// Specialization using EBO.
      .              .            .                .              .              .                .            .           .             template<int _Nm, typename _Tp>
 43,230 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)  11,790 ( 0.01%)     0              0           11,790 ( 0.02%)   0           0               struct _Hashtable_ebo_helper<_Nm, _Tp, true>
      .              .            .                .              .              .                .            .           .               : private _Tp
      .              .            .                .              .              .                .            .           .               {
 14,225 ( 0.00%)   578 ( 0.02%)  11 ( 0.01%)   3,983 ( 0.00%)     0              0            3,983 ( 0.01%)   0           0                 _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 template<typename _OtherTp>
 26,928 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)       0              0              0           13,464 ( 0.02%)   0           0           	_Hashtable_ebo_helper(_OtherTp&& __tp)
 30,294 ( 0.01%)     0            0            7,854 ( 0.01%)     0              0            7,854 ( 0.01%)   1 ( 0.00%)  0           	: _Tp(std::forward<_OtherTp>(__tp))
 13,464 ( 0.00%)     0            0            8,976 ( 0.01%)     0              0                0            0           0           	{ }
      .              .            .                .              .              .                .            .           .           
 67,690 ( 0.02%) 2,320 ( 0.09%) 522 ( 0.41%)  29,010 ( 0.03%)     0              0           19,340 ( 0.03%)  16 ( 0.01%)  3 ( 0.00%)        const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
479,780 ( 0.11%)   514 ( 0.02%)   7 ( 0.01%) 205,620 ( 0.19%)     0              0          137,080 ( 0.20%)  87 ( 0.04%)  6 ( 0.01%)        _Tp& _M_get() { return static_cast<_Tp&>(*this); }
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /// Specialization not using EBO.
      .              .            .                .              .              .                .            .           .             template<int _Nm, typename _Tp>
      .              .            .                .              .              .                .            .           .               struct _Hashtable_ebo_helper<_Nm, _Tp, false>
      .              .            .                .              .              .                .            .           .               {
      .              .            .                .              .              .                .            .           .                 _Hashtable_ebo_helper() = default;
      .              .            .                .              .              .                .            .           .           
-- line 1143 ----------------------------------------
-- line 1202 ----------------------------------------
      .              .            .                .              .              .                .            .           .                 hash_function() const
      .              .            .                .              .              .                .            .           .                 { return _M_hash(); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               protected:
      .              .            .                .              .              .                .            .           .                 typedef std::size_t 				__hash_code;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 // We need the default constructor for the local iterators and _Hashtable
      .              .            .                .              .              .                .            .           .                 // default constructor.
  6,259 ( 0.00%)     0            0            1,707 ( 0.00%)     0              0            1,707 ( 0.00%)   0           0                 _Hash_code_base() = default;
      .              .            .                .              .              .                .            .           .           
  7,854 ( 0.00%)     4 ( 0.00%)   3 ( 0.00%)   2,244 ( 0.00%)     0              0            2,244 ( 0.00%)   0           0                 _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 __hash_code
 34,176 ( 0.01%)   609 ( 0.02%) 153 ( 0.12%)       0              0              0           17,088 ( 0.02%)   0           0                 _M_hash_code(const _Key& __k) const
      .              .            .                .              .              .                .            .           .                 {
      .              .            .                .              .              .                .            .           .           	static_assert(__is_invocable<const _Hash&, const _Key&>{},
      .              .            .                .              .              .                .            .           .           	    "hash function must be invocable with an argument of key type");
 45,654 ( 0.01%)   165 ( 0.01%)   7 ( 0.01%)  11,478 ( 0.01%)     7 ( 0.00%)     1 ( 0.00%)  11,392 ( 0.02%)   0           0           	return _M_hash()(__k);
 11,392 ( 0.00%)     0            0           11,392 ( 0.01%)     0              0                0            0           0                 }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 template<typename _Kt>
      .              .            .                .              .              .                .            .           .           	__hash_code
      .              .            .                .              .              .                .            .           .           	_M_hash_code_tr(const _Kt& __k) const
      .              .            .                .              .              .                .            .           .           	{
      .              .            .                .              .              .                .            .           .           	  static_assert(__is_invocable<const _Hash&, const _Kt&>{},
      .              .            .                .              .              .                .            .           .           	    "hash function must be invocable with an argument of key type");
      .              .            .                .              .              .                .            .           .           	  return _M_hash()(__k);
      .              .            .                .              .              .                .            .           .           	}
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 std::size_t
 68,070 ( 0.02%)    43 ( 0.00%)  43 ( 0.03%)   6,807 ( 0.01%)     0              0           34,035 ( 0.05%)   0           0                 _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
 74,877 ( 0.02%) 1,123 ( 0.04%)   4 ( 0.00%)  40,842 ( 0.04%)     0              0            6,807 ( 0.01%)   0           0                 { return _RangeHash{}(__c, __bkt_count); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 std::size_t
    150 ( 0.00%)    15 ( 0.00%)  14 ( 0.01%)      15 ( 0.00%)     0              0               75 ( 0.00%)   0           0                 _M_bucket_index(const _Hash_node_value<_Value, false>& __n,
      .              .            .                .              .              .                .            .           .           		      std::size_t __bkt_count) const
      .              .            .                .              .              .                .            .           .           	noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>()))
      .              .            .                .              .              .                .            .           .           		  && noexcept(declval<const _RangeHash&>()((__hash_code)0,
      .              .            .                .              .              .                .            .           .           							   (std::size_t)0)) )
      .              .            .                .              .              .                .            .           .                 {
    285 ( 0.00%)    15 ( 0.00%)  15 ( 0.01%)      45 ( 0.00%)     0              0               60 ( 0.00%)   0           0           	return _RangeHash{}(_M_hash_code(_ExtractKey{}(__n._M_v())),
      .              .            .                .              .              .                .            .           .           			    __bkt_count);
     75 ( 0.00%)    14 ( 0.00%)  13 ( 0.01%)      60 ( 0.00%)     0              0                0            0           0                 }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 std::size_t
134,640 ( 0.03%)     2 ( 0.00%)   2 ( 0.00%)  13,464 ( 0.01%)     0              0           67,320 ( 0.10%)   0           0                 _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
      .              .            .                .              .              .                .            .           .           		      std::size_t __bkt_count) const
      .              .            .                .              .              .                .            .           .           	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
      .              .            .                .              .              .                .            .           .           							(std::size_t)0)) )
161,568 ( 0.04%)     0            0           94,248 ( 0.09%)   244 ( 0.05%)    28 ( 0.03%)  13,464 ( 0.02%)   0           0                 { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 void
    138 ( 0.00%)    20 ( 0.00%)  20 ( 0.02%)       0              0              0               92 ( 0.00%)   0           0                 _M_store_code(_Hash_node_code_cache<false>&, __hash_code) const
     69 ( 0.00%)     0            0               46 ( 0.00%)     0              0                0            0           0                 { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 void
      6 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0              0              0                4 ( 0.00%)   0           0                 _M_copy_code(_Hash_node_code_cache<false>&,
      .              .            .                .              .              .                .            .           .           		   const _Hash_node_code_cache<false>&) const
      3 ( 0.00%)     0            0                2 ( 0.00%)     0              0                0            0           0                 { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 void
 26,934 ( 0.01%)    13 ( 0.00%)  11 ( 0.01%)       0              0              0           17,956 ( 0.03%)   0           0                 _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
 26,934 ( 0.01%)     0            0           17,956 ( 0.02%)     0              0            4,489 ( 0.01%) 172 ( 0.07%) 10 ( 0.01%)        { __n._M_hash_code = __c; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 void
 63,954 ( 0.01%)     0            0                0              0              0           42,636 ( 0.06%)   0           0                 _M_copy_code(_Hash_node_code_cache<true>& __to,
      .              .            .                .              .              .                .            .           .           		   const _Hash_node_code_cache<true>& __from) const
 74,613 ( 0.02%)     0            0           53,295 ( 0.05%)    91 ( 0.02%)     1 ( 0.00%)  10,659 ( 0.02%) 194 ( 0.08%)  5 ( 0.01%)        { __to._M_hash_code = __from._M_hash_code; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 void
      .              .            .                .              .              .                .            .           .                 _M_swap(_Hash_code_base& __x)
      .              .            .                .              .              .                .            .           .                 { std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get()); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 const _Hash&
 56,960 ( 0.01%) 1,207 ( 0.04%)  56 ( 0.04%)  17,088 ( 0.02%)     0              0           17,088 ( 0.02%)   1 ( 0.00%)  1 ( 0.00%)        _M_hash() const { return __ebo_hash::_M_cget(); }
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /// Partial specialization used when nodes contain a cached hash code.
      .              .            .                .              .              .                .            .           .             template<typename _Key, typename _Value, typename _ExtractKey,
      .              .            .                .              .              .                .            .           .           	   typename _Hash, typename _RangeHash, typename _Unused>
      .              .            .                .              .              .                .            .           .               struct _Local_iterator_base<_Key, _Value, _ExtractKey,
      .              .            .                .              .              .                .            .           .           				_Hash, _RangeHash, _Unused, true>
      .              .            .                .              .              .                .            .           .               : public _Node_iterator_base<_Value, true>
-- line 1284 ----------------------------------------
-- line 1578 ----------------------------------------
      .              .            .                .              .              .                .            .           .           					       __hash_cached::value>;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 using __hash_code = typename __hash_code_base::__hash_code;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               private:
      .              .            .                .              .              .                .            .           .                 using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 static bool
    240 ( 0.00%)    16 ( 0.00%)  13 ( 0.01%)       0              0              0              144 ( 0.00%)   0           0                 _S_equals(__hash_code, const _Hash_node_code_cache<false>&)
    144 ( 0.00%)    20 ( 0.00%)  14 ( 0.01%)      96 ( 0.00%)     0              0                0            0           0                 { return true; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 static bool
      .              .            .                .              .              .                .            .           .                 _S_node_equals(const _Hash_node_code_cache<false>&,
      .              .            .                .              .              .                .            .           .           		     const _Hash_node_code_cache<false>&)
      .              .            .                .              .              .                .            .           .                 { return true; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 static bool
 11,215 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)       0              0              0            6,729 ( 0.01%)   0           0                 _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
 13,458 ( 0.00%)   835 ( 0.03%) 190 ( 0.15%)  11,215 ( 0.01%)    18 ( 0.00%)     0                0            0           0                 { return __c == __n._M_hash_code; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 static bool
      .              .            .                .              .              .                .            .           .                 _S_node_equals(const _Hash_node_code_cache<true>& __lhn,
      .              .            .                .              .              .                .            .           .           		     const _Hash_node_code_cache<true>& __rhn)
      .              .            .                .              .              .                .            .           .                 { return __lhn._M_hash_code == __rhn._M_hash_code; }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .               protected:
  7,966 ( 0.00%)    29 ( 0.00%)  24 ( 0.02%)   2,276 ( 0.00%)     0              0            2,276 ( 0.00%)   0           0                 _Hashtable_base() = default;
      .              .            .                .              .              .                .            .           .           
  3,927 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0              0              0            2,244 ( 0.00%)   0           0                 _Hashtable_base(const _Hash& __hash, const _Equal& __eq)
  5,610 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)   2,244 ( 0.00%)     0              0            1,122 ( 0.00%)   0           0                 : __hash_code_base(__hash), _EqualEBO(__eq)
  1,683 ( 0.00%)     0            0            1,122 ( 0.00%)     0              0                0            0           0                 { }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 bool
 27,492 ( 0.01%)    58 ( 0.00%)  38 ( 0.03%)   2,291 ( 0.00%)     0              0           16,037 ( 0.02%)   4 ( 0.00%)  0                 _M_equals(const _Key& __k, __hash_code __c,
      .              .            .                .              .              .                .            .           .           		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
      .              .            .                .              .              .                .            .           .                 {
      .              .            .                .              .              .                .            .           .           	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
      .              .            .                .              .              .                .            .           .           	  "key equality predicate must be invocable with two arguments of "
      .              .            .                .              .              .                .            .           .           	  "key type");
 43,951 ( 0.01%) 1,164 ( 0.04%) 189 ( 0.15%)   8,089 ( 0.01%)     0              0            6,967 ( 0.01%)   0           0           	return _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));
 13,746 ( 0.00%)    20 ( 0.00%)  16 ( 0.01%)  11,455 ( 0.01%)     0              0                0            0           0                 }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 template<typename _Kt>
      .              .            .                .              .              .                .            .           .           	bool
      .              .            .                .              .              .                .            .           .           	_M_equals_tr(const _Kt& __k, __hash_code __c,
      .              .            .                .              .              .                .            .           .           		     const _Hash_node_value<_Value,
      .              .            .                .              .              .                .            .           .           					    __hash_cached::value>& __n) const
      .              .            .                .              .              .                .            .           .           	{
      .              .            .                .              .              .                .            .           .           	  static_assert(
-- line 1626 ----------------------------------------
-- line 1642 ----------------------------------------
      .              .            .                .              .              .                .            .           .                 void
      .              .            .                .              .              .                .            .           .                 _M_swap(_Hashtable_base& __x)
      .              .            .                .              .              .                .            .           .                 {
      .              .            .                .              .              .                .            .           .           	__hash_code_base::_M_swap(__x);
      .              .            .                .              .              .                .            .           .           	std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
      .              .            .                .              .              .                .            .           .                 }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 const _Equal&
 11,690 ( 0.00%)     0            0            3,507 ( 0.00%)     0              0            3,507 ( 0.01%)   0           0                 _M_eq() const { return _EqualEBO::_M_cget(); }
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /**
      .              .            .                .              .              .                .            .           .              *  Primary class template  _Equality.
      .              .            .                .              .              .                .            .           .              *
      .              .            .                .              .              .                .            .           .              *  This is for implementing equality comparison for unordered
      .              .            .                .              .              .                .            .           .              *  containers, per N3068, by John Lakos and Pablo Halpern.
      .              .            .                .              .              .                .            .           .              *  Algorithmically, we follow closely the reference implementations
-- line 1658 ----------------------------------------
-- line 1794 ----------------------------------------
      .              .            .                .              .              .                .            .           .                 return true;
      .              .            .                .              .              .                .            .           .               }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             /**
      .              .            .                .              .              .                .            .           .              * This type deals with all allocation and keeps an allocator instance
      .              .            .                .              .              .                .            .           .              * through inheritance to benefit from EBO when possible.
      .              .            .                .              .              .                .            .           .              */
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
 43,230 ( 0.01%)   561 ( 0.02%) 561 ( 0.44%)  11,790 ( 0.01%)     0              0           11,790 ( 0.02%)   0           0               struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
      .              .            .                .              .              .                .            .           .               {
      .              .            .                .              .              .                .            .           .               private:
      .              .            .                .              .              .                .            .           .                 using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
      .              .            .                .              .              .                .            .           .               public:
      .              .            .                .              .              .                .            .           .                 using __node_type = typename _NodeAlloc::value_type;
      .              .            .                .              .              .                .            .           .                 using __node_alloc_type = _NodeAlloc;
      .              .            .                .              .              .                .            .           .                 // Use __gnu_cxx to benefit from _S_always_equal and al.
      .              .            .                .              .              .                .            .           .                 using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;
-- line 1810 ----------------------------------------
-- line 1815 ----------------------------------------
      .              .            .                .              .              .                .            .           .                 using __node_ptr = __node_type*;
      .              .            .                .              .              .                .            .           .                 using __node_base = _Hash_node_base;
      .              .            .                .              .              .                .            .           .                 using __node_base_ptr = __node_base*;
      .              .            .                .              .              .                .            .           .                 using __buckets_alloc_type =
      .              .            .                .              .              .                .            .           .           	__alloc_rebind<__node_alloc_type, __node_base_ptr>;
      .              .            .                .              .              .                .            .           .                 using __buckets_alloc_traits = std::allocator_traits<__buckets_alloc_type>;
      .              .            .                .              .              .                .            .           .                 using __buckets_ptr = __node_base_ptr*;
      .              .            .                .              .              .                .            .           .           
  6,259 ( 0.00%)     0            0            1,707 ( 0.00%)     0              0            1,707 ( 0.00%)   0           0                 _Hashtable_alloc() = default;
      .              .            .                .              .              .                .            .           .                 _Hashtable_alloc(const _Hashtable_alloc&) = default;
      .              .            .                .              .              .                .            .           .                 _Hashtable_alloc(_Hashtable_alloc&&) = default;
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 template<typename _Alloc>
 20,196 ( 0.00%)     0            0                0              0              0           10,098 ( 0.01%)   0           0           	_Hashtable_alloc(_Alloc&& __a)
 26,928 ( 0.01%) 1,128 ( 0.04%)  84 ( 0.07%)   6,732 ( 0.01%)     0              0            6,732 ( 0.01%)   0           0           	: __ebo_node_alloc(std::forward<_Alloc>(__a))
 10,098 ( 0.00%)     0            0            6,732 ( 0.01%)     0              0                0            0           0           	{ }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 __node_alloc_type&
342,700 ( 0.08%)   597 ( 0.02%)  22 ( 0.02%)       0              0              0          137,080 ( 0.20%) 155 ( 0.06%)  3 ( 0.00%)        _M_node_allocator()
342,700 ( 0.08%) 1,151 ( 0.04%)  23 ( 0.02%) 205,620 ( 0.19%)     0              0           68,540 ( 0.10%)   2 ( 0.00%)  0                 { return __ebo_node_alloc::_M_get(); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 const __node_alloc_type&
 14,025 ( 0.00%) 1,103 ( 0.04%)   8 ( 0.01%)       0              0              0            5,610 ( 0.01%)   0           0                 _M_node_allocator() const
 14,025 ( 0.00%)     0            0            8,415 ( 0.01%)     0              0            2,805 ( 0.00%)   0           0                 { return __ebo_node_alloc::_M_cget(); }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 // Allocate a node and construct an element within it.
      .              .            .                .              .              .                .            .           .                 template<typename... _Args>
      .              .            .                .              .              .                .            .           .           	__node_ptr
      .              .            .                .              .              .                .            .           .           	_M_allocate_node(_Args&&... __args);
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .                 // Destroy the element within a node and deallocate the node.
      .              .            .                .              .              .                .            .           .                 void
-- line 1846 ----------------------------------------
-- line 1862 ----------------------------------------
      .              .            .                .              .              .                .            .           .                 _M_deallocate_buckets(__buckets_ptr, std::size_t __bkt_count);
      .              .            .                .              .              .                .            .           .               };
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             // Definitions of class template _Hashtable_alloc's out-of-line member
      .              .            .                .              .              .                .            .           .             // functions.
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
      .              .            .                .              .              .                .            .           .               template<typename... _Args>
      .              .            .                .              .              .                .            .           .                 auto
123,716 ( 0.03%)    29 ( 0.00%)  28 ( 0.02%)       0              0              0           78,200 ( 0.11%)   0           0                 _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
      .              .            .                .              .              .                .            .           .                 -> __node_ptr
      .              .            .                .              .              .                .            .           .                 {
106,204 ( 0.02%)    20 ( 0.00%)  20 ( 0.02%)  15,172 ( 0.01%)     0              0           45,516 ( 0.07%)   7 ( 0.00%)  0           	auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
 60,688 ( 0.01%)     3 ( 0.00%)   3 ( 0.00%)  15,172 ( 0.01%)     0              0           30,344 ( 0.04%)   0           0           	__node_ptr __n = std::__to_address(__nptr);
      .              .            .                .              .              .                .            .           .           	__try
      .              .            .                .              .              .                .            .           .           	  {
 91,032 ( 0.02%)     5 ( 0.00%)   5 ( 0.00%)  15,172 ( 0.01%)     0              0           30,344 ( 0.04%)   0           0           	    ::new ((void*)__n) __node_type;
248,602 ( 0.06%)   608 ( 0.02%)  49 ( 0.04%)  46,686 ( 0.04%)     0              0           61,858 ( 0.09%)   0           0           	    __node_alloc_traits::construct(_M_node_allocator(),
      .              .            .                .              .              .                .            .           .           					   __n->_M_valptr(),
      .              .            .                .              .              .                .            .           .           					   std::forward<_Args>(__args)...);
 30,343 ( 0.01%)     0            0           15,172 ( 0.01%)     0              0                0            0           0           	    return __n;
      .              .            .                .              .              .                .            .           .           	  }
      .              .            .                .              .              .                .            .           .           	__catch(...)
      .              .            .                .              .              .                .            .           .           	  {
      .              .            .                .              .              .                .            .           .           	    __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
      .              .            .                .              .              .                .            .           .           	    __throw_exception_again;
      .              .            .                .              .              .                .            .           .           	  }
 77,030 ( 0.02%)   582 ( 0.02%)  84 ( 0.07%)  61,858 ( 0.06%)     0              0                0            0           0                 }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
      .              .            .                .              .              .                .            .           .               void
106,176 ( 0.02%) 1,128 ( 0.04%)  13 ( 0.01%)       0              0              0           60,672 ( 0.09%)   0           0               _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
      .              .            .                .              .              .                .            .           .               {
166,848 ( 0.04%)     0            0           30,336 ( 0.03%)     0              0           45,504 ( 0.07%)   0           0                 __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
 75,840 ( 0.02%)   566 ( 0.02%)  64 ( 0.05%)  30,336 ( 0.03%)     0              0           15,168 ( 0.02%)   0           0                 _M_deallocate_node_ptr(__n);
 60,672 ( 0.01%)     0            0           45,504 ( 0.04%)     0              0                0            0           0               }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
      .              .            .                .              .              .                .            .           .               void
 91,008 ( 0.02%)   561 ( 0.02%)   2 ( 0.00%)       0              0              0           45,504 ( 0.07%)   0           0               _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
      .              .            .                .              .              .                .            .           .               {
      .              .            .                .              .              .                .            .           .                 typedef typename __node_alloc_traits::pointer _Ptr;
 60,672 ( 0.01%)     4 ( 0.00%)   3 ( 0.00%)  15,168 ( 0.01%)     0              0           30,336 ( 0.04%)   0           0                 auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      .              .            .                .              .              .                .            .           .                 __n->~__node_type();
136,512 ( 0.03%)     0            0           30,336 ( 0.03%)     0              0           30,336 ( 0.04%)   0           0                 __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
 45,504 ( 0.01%)     0            0           30,336 ( 0.03%)     0              0                0            0           0               }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
      .              .            .                .              .              .                .            .           .               void
 23,646 ( 0.01%)     0            0                0              0              0           11,823 ( 0.02%)   0           0               _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
      .              .            .                .              .              .                .            .           .               {
 42,159 ( 0.01%)   567 ( 0.02%)  24 ( 0.02%)  19,109 ( 0.02%)     0              0                0            0           0                 while (__n)
      .              .            .                .              .              .                .            .           .           	{
 30,336 ( 0.01%)     0            0           15,168 ( 0.01%)     0              0           15,168 ( 0.02%)   0           0           	  __node_ptr __tmp = __n;
 60,672 ( 0.01%)     0            0           15,168 ( 0.01%)     0              0           30,336 ( 0.04%)   0           0           	  __n = __n->_M_next();
 75,840 ( 0.02%)     0            0           30,336 ( 0.03%)     0              0           15,168 ( 0.02%)   0           0           	  _M_deallocate_node(__tmp);
      .              .            .                .              .              .                .            .           .           	}
 15,764 ( 0.00%)     0            0            7,882 ( 0.01%)     0              0                0            0           0               }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
      .              .            .                .              .              .                .            .           .               auto
 39,320 ( 0.01%)   567 ( 0.02%)  26 ( 0.02%)   3,932 ( 0.00%)     0              0           19,660 ( 0.03%)   8 ( 0.00%)  0               _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
      .              .            .                .              .              .                .            .           .               -> __buckets_ptr
      .              .            .                .              .              .                .            .           .               {
 31,456 ( 0.01%)     2 ( 0.00%)   2 ( 0.00%)   3,932 ( 0.00%)     0              0            7,864 ( 0.01%)   0           0                 __buckets_alloc_type __alloc(_M_node_allocator());
      .              .            .                .              .              .                .            .           .           
 23,592 ( 0.01%)     3 ( 0.00%)   3 ( 0.00%)   3,932 ( 0.00%)     0              0            7,864 ( 0.01%)   0           0                 auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
 15,728 ( 0.00%)     0            0            3,932 ( 0.00%)     0              0            7,864 ( 0.01%)   0           0                 __buckets_ptr __p = std::__to_address(__ptr);
 23,592 ( 0.01%)     2 ( 0.00%)   2 ( 0.00%)   7,864 ( 0.01%)     0              0            3,932 ( 0.01%)   0           0                 __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
  7,864 ( 0.00%)     3 ( 0.00%)   3 ( 0.00%)   3,932 ( 0.00%)     0              0                0            0           0                 return __p;
 35,388 ( 0.01%)     0            0           19,660 ( 0.02%)     0              0            3,932 ( 0.01%)   0           0               }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .             template<typename _NodeAlloc>
      .              .            .                .              .              .                .            .           .               void
 43,208 ( 0.01%)   563 ( 0.02%) 143 ( 0.11%)   3,928 ( 0.00%)     0              0           23,568 ( 0.03%)   0           0               _Hashtable_alloc<_NodeAlloc>::
      .              .            .                .              .              .                .            .           .               _M_deallocate_buckets(__buckets_ptr __bkts,
      .              .            .                .              .              .                .            .           .           			  std::size_t __bkt_count)
      .              .            .                .              .              .                .            .           .               {
      .              .            .                .              .              .                .            .           .                 typedef typename __buckets_alloc_traits::pointer _Ptr;
 15,712 ( 0.00%)     0            0            3,928 ( 0.00%)     0              0            7,856 ( 0.01%)   0           0                 auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
 31,424 ( 0.01%)   563 ( 0.02%)   6 ( 0.00%)   3,928 ( 0.00%)     0              0            7,856 ( 0.01%)   0           0                 __buckets_alloc_type __alloc(_M_node_allocator());
 23,568 ( 0.01%)     0            0            7,856 ( 0.01%)     0              0            3,928 ( 0.01%)   0           0                 __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
 35,352 ( 0.01%)   562 ( 0.02%)  36 ( 0.03%)  19,640 ( 0.02%)     0              0            3,928 ( 0.01%)   0           0               }
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .            ///@} hashtable-detail
      .              .            .                .              .              .                .            .           .           } // namespace __detail
      .              .            .                .              .              .                .            .           .           /// @endcond
      .              .            .                .              .              .                .            .           .           _GLIBCXX_END_NAMESPACE_VERSION
      .              .            .                .              .              .                .            .           .           } // namespace std
      .              .            .                .              .              .                .            .           .           
      .              .            .                .              .              .                .            .           .           #endif // _HASHTABLE_POLICY_H
-- line 1951 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_construct.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr       DLmr       Dw               D1mw         DLmw        

-- line 101 ----------------------------------------
      .              .            .                .          .          .                .            .           .             /**
      .              .            .                .          .          .                .            .           .              * Constructs an object in existing memory by invoking an allocated
      .              .            .                .          .          .                .            .           .              * object's constructor with an initializer.
      .              .            .                .          .          .                .            .           .              */
      .              .            .                .          .          .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .          .          .                .            .           .             template<typename _Tp, typename... _Args>
      .              .            .                .          .          .                .            .           .               _GLIBCXX20_CONSTEXPR
      .              .            .                .          .          .                .            .           .               inline void
490,612 ( 0.11%)   566 ( 0.02%)   6 ( 0.00%)       0          0          0          233,452 ( 0.34%)   0           0               _Construct(_Tp* __p, _Args&&... __args)
      .              .            .                .          .          .                .            .           .               {
      .              .            .                .          .          .                .            .           .           #if __cplusplus >= 202002L && __has_builtin(__builtin_is_constant_evaluated)
      .              .            .                .          .          .                .            .           .                 if (__builtin_is_constant_evaluated())
      .              .            .                .          .          .                .            .           .           	{
      .              .            .                .          .          .                .            .           .           	  // Allow std::_Construct to be used in constant expressions.
      .              .            .                .          .          .                .            .           .           	  std::construct_at(__p, std::forward<_Args>(__args)...);
      .              .            .                .          .          .                .            .           .           	  return;
      .              .            .                .          .          .                .            .           .           	}
      .              .            .                .          .          .                .            .           .           #endif
793,289 ( 0.18%) 1,123 ( 0.04%) 198 ( 0.16%) 209,695 ( 0.19%) 5 ( 0.00%) 0          264,423 ( 0.39%) 124 ( 0.05%) 15 ( 0.02%)        ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
288,180 ( 0.07%)     4 ( 0.00%)   4 ( 0.00%) 202,453 ( 0.18%) 0          0                0            0           0               }
      .              .            .                .          .          .                .            .           .           #else
      .              .            .                .          .          .                .            .           .             template<typename _T1, typename _T2>
      .              .            .                .          .          .                .            .           .               inline void
      .              .            .                .          .          .                .            .           .               _Construct(_T1* __p, const _T2& __value)
      .              .            .                .          .          .                .            .           .               {
      .              .            .                .          .          .                .            .           .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
      .              .            .                .          .          .                .            .           .                 // 402. wrong new expression in [some_]allocator::construct
      .              .            .                .          .          .                .            .           .                 ::new(static_cast<void*>(__p)) _T1(__value);
-- line 128 ----------------------------------------
-- line 138 ----------------------------------------
      .              .            .                .          .          .                .            .           .               _GLIBCXX20_CONSTEXPR void
      .              .            .                .          .          .                .            .           .               _Destroy(_ForwardIterator __first, _ForwardIterator __last);
      .              .            .                .          .          .                .            .           .           
      .              .            .                .          .          .                .            .           .             /**
      .              .            .                .          .          .                .            .           .              * Destroy the object pointed to by a pointer type.
      .              .            .                .          .          .                .            .           .              */
      .              .            .                .          .          .                .            .           .             template<typename _Tp>
      .              .            .                .          .          .                .            .           .               _GLIBCXX14_CONSTEXPR inline void
 44,915 ( 0.01%)     1 ( 0.00%)   0                0          0          0           17,966 ( 0.03%)   0           0               _Destroy(_Tp* __pointer)
      .              .            .                .          .          .                .            .           .               {
      .              .            .                .          .          .                .            .           .           #if __cplusplus > 201703L
      .              .            .                .          .          .                .            .           .                 std::destroy_at(__pointer);
      .              .            .                .          .          .                .            .           .           #else
 26,949 ( 0.01%)     0            0            8,983 ( 0.01%) 0          0            8,983 ( 0.01%)   0           0                 __pointer->~_Tp();
      .              .            .                .          .          .                .            .           .           #endif
 26,949 ( 0.01%)     0            0           17,966 ( 0.02%) 0          0                0            0           0               }
      .              .            .                .          .          .                .            .           .           
      .              .            .                .          .          .                .            .           .             template<bool>
      .              .            .                .          .          .                .            .           .               struct _Destroy_aux
      .              .            .                .          .          .                .            .           .               {
      .              .            .                .          .          .                .            .           .                 template<typename _ForwardIterator>
      .              .            .                .          .          .                .            .           .           	static _GLIBCXX20_CONSTEXPR void
 20,226 ( 0.00%)     1 ( 0.00%)   0                0          0          0           10,113 ( 0.01%)   0           0           	__destroy(_ForwardIterator __first, _ForwardIterator __last)
      .              .            .                .          .          .                .            .           .           	{
 49,416 ( 0.01%)     0            0           33,691 ( 0.03%) 0          0                0            0           0           	  for (; __first != __last; ++__first)
 44,915 ( 0.01%)     0            0            8,983 ( 0.01%) 0          0           17,966 ( 0.03%)   0           0           	    std::_Destroy(std::__addressof(*__first));
 13,484 ( 0.00%)     0            0            6,742 ( 0.01%) 0          0                0            0           0           	}
      .              .            .                .          .          .                .            .           .               };
      .              .            .                .          .          .                .            .           .           
      .              .            .                .          .          .                .            .           .             template<>
      .              .            .                .          .          .                .            .           .               struct _Destroy_aux<true>
      .              .            .                .          .          .                .            .           .               {
      .              .            .                .          .          .                .            .           .                 template<typename _ForwardIterator>
      .              .            .                .          .          .                .            .           .                   static void
186,216 ( 0.04%) 1,126 ( 0.04%)  32 ( 0.03%)  46,554 ( 0.04%) 0          0           69,831 ( 0.10%)   0           0                   __destroy(_ForwardIterator, _ForwardIterator) { }
      .              .            .                .          .          .                .            .           .               };
      .              .            .                .          .          .                .            .           .           
      .              .            .                .          .          .                .            .           .             /**
      .              .            .                .          .          .                .            .           .              * Destroy a range of objects.  If the value_type of the object has
      .              .            .                .          .          .                .            .           .              * a trivial destructor, the compiler should optimize all of this
      .              .            .                .          .          .                .            .           .              * away, otherwise the objects' destructors must be invoked.
      .              .            .                .          .          .                .            .           .              */
      .              .            .                .          .          .                .            .           .             template<typename _ForwardIterator>
      .              .            .                .          .          .                .            .           .               _GLIBCXX20_CONSTEXPR inline void
159,888 ( 0.04%)   579 ( 0.02%)  15 ( 0.01%)       0          0          0           79,944 ( 0.12%)   0           0               _Destroy(_ForwardIterator __first, _ForwardIterator __last)
      .              .            .                .          .          .                .            .           .               {
      .              .            .                .          .          .                .            .           .                 typedef typename iterator_traits<_ForwardIterator>::value_type
      .              .            .                .          .          .                .            .           .                                  _Value_type;
      .              .            .                .          .          .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .          .          .                .            .           .                 // A deleted destructor is trivial, this ensures we reject such types:
      .              .            .                .          .          .                .            .           .                 static_assert(is_destructible<_Value_type>::value,
      .              .            .                .          .          .                .            .           .           		    "value type is destructible");
      .              .            .                .          .          .                .            .           .           #endif
      .              .            .                .          .          .                .            .           .           #if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated
      .              .            .                .          .          .                .            .           .                 if (std::is_constant_evaluated())
      .              .            .                .          .          .                .            .           .           	return _Destroy_aux<false>::__destroy(__first, __last);
      .              .            .                .          .          .                .            .           .           #endif
      .              .            .                .          .          .                .            .           .                 std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
133,240 ( 0.03%)   561 ( 0.02%) 291 ( 0.23%)  53,296 ( 0.05%) 0          0           26,648 ( 0.04%)   0           0           	__destroy(__first, __last);
 79,944 ( 0.02%)   561 ( 0.02%)  18 ( 0.01%)  53,296 ( 0.05%) 0          0                0            0           0               }
      .              .            .                .          .          .                .            .           .           
      .              .            .                .          .          .                .            .           .             template<bool>
      .              .            .                .          .          .                .            .           .               struct _Destroy_n_aux
      .              .            .                .          .          .                .            .           .               {
      .              .            .                .          .          .                .            .           .                 template<typename _ForwardIterator, typename _Size>
      .              .            .                .          .          .                .            .           .           	static _GLIBCXX20_CONSTEXPR _ForwardIterator
      .              .            .                .          .          .                .            .           .           	__destroy_n(_ForwardIterator __first, _Size __count)
      .              .            .                .          .          .                .            .           .           	{
-- line 205 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/basic_string.tcc
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr       DLmr       Dw               D1mw         DLmw        

-- line 198 ----------------------------------------
      .              .            .                .          .          .                .            .           .           	  }
      .              .            .                .          .          .                .            .           .           
      .              .            .                .          .          .                .            .           .           	_M_set_length(__len);
      .              .            .                .          .          .                .            .           .                 }
      .              .            .                .          .          .                .            .           .           
      .              .            .                .          .          .                .            .           .             template<typename _CharT, typename _Traits, typename _Alloc>
      .              .            .                .          .          .                .            .           .               template<typename _InIterator>
      .              .            .                .          .          .                .            .           .                 void
550,561 ( 0.13%) 1,167 ( 0.04%) 673 ( 0.53%)  50,051 ( 0.05%) 0          0          300,306 ( 0.44%)  92 ( 0.04%)  0                 basic_string<_CharT, _Traits, _Alloc>::
      .              .            .                .          .          .                .            .           .                 _M_construct(_InIterator __beg, _InIterator __end,
      .              .            .                .          .          .                .            .           .           		   std::forward_iterator_tag)
      .              .            .                .          .          .                .            .           .                 {
      .              .            .                .          .          .                .            .           .           	// NB: Not required, but considered best practice.
400,408 ( 0.09%) 1,158 ( 0.04%) 607 ( 0.48%)  50,051 ( 0.05%) 0          0           50,051 ( 0.07%) 104 ( 0.04%) 14 ( 0.02%)  	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
      .              .            .                .          .          .                .            .           .           	  std::__throw_logic_error(__N("basic_string::"
      .              .            .                .          .          .                .            .           .           				       "_M_construct null not valid"));
      .              .            .                .          .          .                .            .           .           
300,306 ( 0.07%)   587 ( 0.02%) 250 ( 0.20%) 100,102 ( 0.09%) 0          0          100,102 ( 0.15%)   0           0           	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
      .              .            .                .          .          .                .            .           .           
150,153 ( 0.03%)     0            0           50,051 ( 0.05%) 0          0                0            0           0           	if (__dnew > size_type(_S_local_capacity))
      .              .            .                .          .          .                .            .           .           	  {
 74,602 ( 0.02%)     0            0           13,564 ( 0.01%) 0          0           13,564 ( 0.02%)   0           0           	    _M_data(_M_create(__dnew, size_type(0)));
 33,910 ( 0.01%)     8 ( 0.00%)   0           13,564 ( 0.01%) 7 ( 0.00%) 1 ( 0.00%)   6,782 ( 0.01%)   0           0           	    _M_capacity(__dnew);
      .              .            .                .          .          .                .            .           .           	  }
      .              .            .                .          .          .                .            .           .           
      .              .            .                .          .          .                .            .           .           	// Check for out_of_range and length_error exceptions.
      .              .            .                .          .          .                .            .           .           	__try
450,459 ( 0.10%)   628 ( 0.02%) 281 ( 0.22%) 150,153 ( 0.14%) 0          0          100,102 ( 0.15%)   0           0           	  { this->_S_copy_chars(_M_data(), __beg, __end); }
      .              .            .                .          .          .                .            .           .           	__catch(...)
      .              .            .                .          .          .                .            .           .           	  {
      .              .            .                .          .          .                .            .           .           	    _M_dispose();
      .              .            .                .          .          .                .            .           .           	    __throw_exception_again;
      .              .            .                .          .          .                .            .           .           	  }
      .              .            .                .          .          .                .            .           .           
250,255 ( 0.06%) 2,290 ( 0.08%) 369 ( 0.29%) 100,102 ( 0.09%) 0          0           50,051 ( 0.07%)   0           0           	_M_set_length(__dnew);
350,357 ( 0.08%)   590 ( 0.02%) 407 ( 0.32%) 250,255 ( 0.23%) 7 ( 0.00%) 0                0            0           0                 }
      .              .            .                .          .          .                .            .           .           
      .              .            .                .          .          .                .            .           .             template<typename _CharT, typename _Traits, typename _Alloc>
      .              .            .                .          .          .                .            .           .               void
      .              .            .                .          .          .                .            .           .               basic_string<_CharT, _Traits, _Alloc>::
      .              .            .                .          .          .                .            .           .               _M_construct(size_type __n, _CharT __c)
      .              .            .                .          .          .                .            .           .               {
      .              .            .                .          .          .                .            .           .                 if (__n > size_type(_S_local_capacity))
      .              .            .                .          .          .                .            .           .           	{
-- line 241 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/ext/aligned_buffer.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr       DLmr       Dw              D1mw       DLmw       

-- line 56 ----------------------------------------
      .              .            .                .          .          .               .          .          .                 alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 __aligned_membuf() = default;
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 // Can be used to avoid value-initialization zeroing _M_storage.
      .              .            .                .          .          .               .          .          .                 __aligned_membuf(std::nullptr_t) { }
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 void*
  5,048 ( 0.00%)     3 ( 0.00%)   1 ( 0.00%)       0          0          0           2,524 ( 0.00%) 0          0                 _M_addr() noexcept
  3,786 ( 0.00%)     0            0            3,786 ( 0.00%) 0          0               0          0          0                 { return static_cast<void*>(&_M_storage); }
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 const void*
 47,000 ( 0.01%)   335 ( 0.01%)   8 ( 0.01%)       0          0          0          23,500 ( 0.03%) 0          0                 _M_addr() const noexcept
 35,250 ( 0.01%)     0            0           35,250 ( 0.03%) 0          0               0          0          0                 { return static_cast<const void*>(&_M_storage); }
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 _Tp*
      .              .            .                .          .          .               .          .          .                 _M_ptr() noexcept
      .              .            .                .          .          .               .          .          .                 { return static_cast<_Tp*>(_M_addr()); }
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 const _Tp*
      .              .            .                .          .          .               .          .          .                 _M_ptr() const noexcept
      .              .            .                .          .          .               .          .          .                 { return static_cast<const _Tp*>(_M_addr()); }
-- line 77 ----------------------------------------
-- line 94 ----------------------------------------
      .              .            .                .          .          .               .          .          .           	std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 __aligned_buffer() = default;
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 // Can be used to avoid value-initialization
      .              .            .                .          .          .               .          .          .                 __aligned_buffer(std::nullptr_t) { }
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 void*
189,888 ( 0.04%)   835 ( 0.03%)  43 ( 0.03%)       0          0          0          94,944 ( 0.14%) 0          0                 _M_addr() noexcept
      .              .            .                .          .          .               .          .          .                 {
 47,472 ( 0.01%)   560 ( 0.02%) 182 ( 0.14%)  47,472 ( 0.04%) 0          0               0          0          0                   return static_cast<void*>(&_M_storage);
 94,944 ( 0.02%)     0            0           94,944 ( 0.09%) 0          0               0          0          0                 }
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 const void*
  4,736 ( 0.00%)   593 ( 0.02%) 210 ( 0.16%)       0          0          0           2,368 ( 0.00%) 0          0                 _M_addr() const noexcept
      .              .            .                .          .          .               .          .          .                 {
  1,184 ( 0.00%)     0            0            1,184 ( 0.00%) 0          0               0          0          0                   return static_cast<const void*>(&_M_storage);
  2,368 ( 0.00%)     0            0            2,368 ( 0.00%) 0          0               0          0          0                 }
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 _Tp*
237,360 ( 0.06%) 1,424 ( 0.05%)  23 ( 0.02%)       0          0          0          94,944 ( 0.14%) 0          0                 _M_ptr() noexcept
237,360 ( 0.06%)   530 ( 0.02%)   2 ( 0.00%) 142,416 ( 0.13%) 0          0          47,472 ( 0.07%) 0          0                 { return static_cast<_Tp*>(_M_addr()); }
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .                 const _Tp*
  5,920 ( 0.00%)   561 ( 0.02%) 520 ( 0.41%)       0          0          0           2,368 ( 0.00%) 0          0                 _M_ptr() const noexcept
  5,920 ( 0.00%)   561 ( 0.02%) 559 ( 0.44%)   3,552 ( 0.00%) 0          0           1,184 ( 0.00%) 0          0                 { return static_cast<const _Tp*>(_M_addr()); }
      .              .            .                .          .          .               .          .          .               };
      .              .            .                .          .          .               .          .          .           #endif
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .           } // namespace
      .              .            .                .          .          .               .          .          .           
      .              .            .                .          .          .               .          .          .           #endif /* _ALIGNED_BUFFER_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/hashtable.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr              D1mr           DLmr           Dw              D1mw        DLmw        

-- line 289 ----------------------------------------
      .              .            .               .              .              .               .           .           .           	__detail::_ReuseOrAllocNode<__node_alloc_type>;
      .              .            .               .              .              .               .           .           .                 using __alloc_node_gen_t =
      .              .            .               .              .              .               .           .           .           	__detail::_AllocNode<__node_alloc_type>;
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 // Simple RAII type for managing a node containing an element
      .              .            .               .              .              .               .           .           .                 struct _Scoped_node
      .              .            .               .              .              .               .           .           .                 {
      .              .            .               .              .              .               .           .           .           	// Take ownership of a node with a constructed element.
 10,098 ( 0.00%)     0            0               0              0              0           6,732 ( 0.01%)  0           0           	_Scoped_node(__node_ptr __n, __hashtable_alloc* __h)
 15,147 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%) 10,098 ( 0.01%)     0              0           3,366 ( 0.00%)  0           0           	: _M_h(__h), _M_node(__n) { }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	// Allocate a node and construct an element within it.
      .              .            .               .              .              .               .           .           .           	template<typename... _Args>
 24,972 ( 0.01%) 1,683 ( 0.06%)  61 ( 0.05%)      0              0              0          16,485 ( 0.02%)  0           0           	  _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)
  8,487 ( 0.00%)     0            0           5,658 ( 0.01%)     0              0           2,829 ( 0.00%)  0           0           	  : _M_h(__h),
 31,311 ( 0.01%)   598 ( 0.02%)  52 ( 0.04%)  9,657 ( 0.01%)     0              0           9,657 ( 0.01%)  0           0           	    _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
 13,071 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)  9,657 ( 0.01%)     0              0               0           0           0           	  { }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	// Destroy element and deallocate node.
 54,144 ( 0.01%)   578 ( 0.02%)  25 ( 0.02%) 18,048 ( 0.02%)     0              0           9,024 ( 0.01%)  0           0           	~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	_Scoped_node(const _Scoped_node&) = delete;
      .              .            .               .              .              .               .           .           .           	_Scoped_node& operator=(const _Scoped_node&) = delete;
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	__hashtable_alloc* _M_h;
      .              .            .               .              .              .               .           .           .           	__node_ptr _M_node;
      .              .            .               .              .              .               .           .           .                 };
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 template<typename _Ht>
      .              .            .               .              .              .               .           .           .           	static constexpr
      .              .            .               .              .              .               .           .           .           	typename conditional<std::is_lvalue_reference<_Ht>::value,
      .              .            .               .              .              .               .           .           .           			     const value_type&, value_type&&>::type
 53,300 ( 0.01%)     0            0               0              0              0          21,320 ( 0.03%)  0           0           	__fwd_value_for(value_type& __val) noexcept
 53,300 ( 0.01%)   561 ( 0.02%)  26 ( 0.02%) 31,980 ( 0.03%)     0              0          10,660 ( 0.02%)  0           0           	{ return std::move(__val); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 // Compile-time diagnostics.
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 // _Hash_code_base has everything protected, so use this derived type to
      .              .            .               .              .              .               .           .           .                 // access it.
      .              .            .               .              .              .               .           .           .                 struct __hash_code_base_access : __hash_code_base
      .              .            .               .              .              .               .           .           .                 { using __hash_code_base::_M_bucket_index; };
      .              .            .               .              .              .               .           .           .           
-- line 330 ----------------------------------------
-- line 399 ----------------------------------------
      .              .            .               .              .              .               .           .           .                 // interesting in move semantic to leave hashtable with only 1 bucket
      .              .            .               .              .              .               .           .           .                 // which is not allocated so that we can have those operations noexcept
      .              .            .               .              .              .               .           .           .                 // qualified.
      .              .            .               .              .              .               .           .           .                 // Note that we can't leave hashtable with 0 bucket without adding
      .              .            .               .              .              .               .           .           .                 // numerous checks in the code to avoid 0 modulus.
      .              .            .               .              .              .               .           .           .                 __node_base_ptr		_M_single_bucket	= nullptr;
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 void
 19,642 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      0              0              0          11,224 ( 0.02%)  0           0                 _M_update_bbegin()
      .              .            .               .              .              .               .           .           .                 {
 19,642 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)  2,806 ( 0.00%)     0              0           2,806 ( 0.00%)  0           0           	if (_M_begin())
 42,090 ( 0.01%)     0            0          14,030 ( 0.01%)     0              0           8,418 ( 0.01%)  0           0           	  _M_buckets[_M_bucket_index(*_M_begin())] = &_M_before_begin;
 16,836 ( 0.00%)     0            0          11,224 ( 0.01%)     0              0               0           0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 void
 16,836 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      0              0              0           8,418 ( 0.01%)  0           0                 _M_update_bbegin(__node_ptr __n)
      .              .            .               .              .              .               .           .           .                 {
  8,418 ( 0.00%)     0            0           5,612 ( 0.01%)     0              0           2,806 ( 0.00%) 11 ( 0.00%)  0           	_M_before_begin._M_nxt = __n;
  8,418 ( 0.00%)     0            0           2,806 ( 0.00%)     0              0           2,806 ( 0.00%)  0           0           	_M_update_bbegin();
  8,418 ( 0.00%)     0            0           5,612 ( 0.01%)     0              0               0           0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 bool
 25,285 ( 0.01%)     3 ( 0.00%)   3 ( 0.00%)      0              0              0          15,171 ( 0.02%)  0           0                 _M_uses_single_bucket(__buckets_ptr __bkts) const
 45,513 ( 0.01%)     0            0          20,228 ( 0.02%)     0              0               0           0           0                 { return __builtin_expect(__bkts == &_M_single_bucket, false); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 bool
      .              .            .               .              .              .               .           .           .                 _M_uses_single_bucket() const
      .              .            .               .              .              .               .           .           .                 { return _M_uses_single_bucket(_M_buckets); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 __hashtable_alloc&
      .              .            .               .              .              .               .           .           .                 _M_base_alloc() { return *this; }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 __buckets_ptr
 23,592 ( 0.01%)   565 ( 0.02%)   8 ( 0.01%)      0              0              0          11,796 ( 0.02%)  0           0                 _M_allocate_buckets(size_type __bkt_count)
      .              .            .               .              .              .               .           .           .                 {
 19,660 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)  3,932 ( 0.00%)     0              0               0           0           0           	if (__builtin_expect(__bkt_count == 1, false))
      .              .            .               .              .              .               .           .           .           	  {
      .              .            .               .              .              .               .           .           .           	    _M_single_bucket = nullptr;
      .              .            .               .              .              .               .           .           .           	    return &_M_single_bucket;
      .              .            .               .              .              .               .           .           .           	  }
      .              .            .               .              .              .               .           .           .           
 23,592 ( 0.01%)     3 ( 0.00%)   2 ( 0.00%)  7,864 ( 0.01%)     0              0           3,932 ( 0.01%)  0           0           	return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
  7,864 ( 0.00%)     0            0           7,864 ( 0.01%)     0              0               0           0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 void
 35,399 ( 0.01%)   566 ( 0.02%)  20 ( 0.02%)      0              0              0          20,228 ( 0.03%)  0           0                 _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count)
      .              .            .               .              .              .               .           .           .                 {
 35,399 ( 0.01%)     3 ( 0.00%)   3 ( 0.00%) 10,114 ( 0.01%)     0              0           5,057 ( 0.01%)  0           0           	if (_M_uses_single_bucket(__bkts))
  1,129 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      0              0              0               0           0           0           	  return;
      .              .            .               .              .              .               .           .           .           
 27,496 ( 0.01%)     0            0          11,784 ( 0.01%)     0              0           3,928 ( 0.01%)  0           0           	__hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
 10,114 ( 0.00%)     0            0          10,114 ( 0.01%)     0              0               0           0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 void
 25,280 ( 0.01%)     5 ( 0.00%)   5 ( 0.00%)      0              0              0          10,112 ( 0.01%)  0           0                 _M_deallocate_buckets()
 55,616 ( 0.01%)    10 ( 0.00%)   9 ( 0.01%) 35,392 ( 0.03%)     0              0           5,056 ( 0.01%)  0           0                 { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 // Gets bucket begin, deals with the fact that non-empty buckets contain
      .              .            .               .              .              .               .           .           .                 // their before begin node.
      .              .            .               .              .              .               .           .           .                 __node_ptr
      .              .            .               .              .              .               .           .           .                 _M_bucket_begin(size_type __bkt) const;
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 __node_ptr
 60,672 ( 0.01%)   894 ( 0.03%)  21 ( 0.02%)      0              0              0          30,336 ( 0.04%)  0           0                 _M_begin() const
 60,672 ( 0.01%)     0            0          60,672 ( 0.05%) 2,410 ( 0.51%) 1,155 ( 1.14%)      0           0           0                 { return static_cast<__node_ptr>(_M_before_begin._M_nxt); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 // Assign *this using another _Hashtable instance. Whether elements
      .              .            .               .              .              .               .           .           .                 // are copied or moved depends on the _Ht reference.
      .              .            .               .              .              .               .           .           .                 template<typename _Ht>
      .              .            .               .              .              .               .           .           .           	void
      .              .            .               .              .              .               .           .           .           	_M_assign_elements(_Ht&&);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 template<typename _Ht, typename _NodeGenerator>
-- line 471 ----------------------------------------
-- line 476 ----------------------------------------
      .              .            .               .              .              .               .           .           .                 _M_move_assign(_Hashtable&&, true_type);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 void
      .              .            .               .              .              .               .           .           .                 _M_move_assign(_Hashtable&&, false_type);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 void
      .              .            .               .              .              .               .           .           .                 _M_reset() noexcept;
      .              .            .               .              .              .               .           .           .           
  6,732 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)    561 ( 0.00%)     0              0           3,927 ( 0.01%)  0           0                 _Hashtable(const _Hash& __h, const _Equal& __eq,
      .              .            .               .              .              .               .           .           .           		 const allocator_type& __a)
      .              .            .               .              .              .               .           .           .                 : __hashtable_base(__h, __eq),
  4,488 ( 0.00%)     5 ( 0.00%)   5 ( 0.00%)    561 ( 0.00%)     0              0           1,122 ( 0.00%)  0           0           	__hashtable_alloc(__node_alloc_type(__a)),
 19,074 ( 0.00%)    10 ( 0.00%)  10 ( 0.01%)  7,293 ( 0.01%)   433 ( 0.09%)     1 ( 0.00%)  5,049 ( 0.01%)  8 ( 0.00%)  0           	__enable_default_ctor(_Enable_default_constructor_tag{})
  3,927 ( 0.00%)   561 ( 0.02%)  80 ( 0.06%)  2,805 ( 0.00%)     0              0               0           0           0                 { }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 template<bool _No_realloc = true>
      .              .            .               .              .              .               .           .           .           	static constexpr bool
      .              .            .               .              .              .               .           .           .           	_S_nothrow_move()
      .              .            .               .              .              .               .           .           .           	{
      .              .            .               .              .              .               .           .           .           #if __cplusplus <= 201402L
      .              .            .               .              .              .               .           .           .           	  return __and_<__bool_constant<_No_realloc>,
      .              .            .               .              .              .               .           .           .           			is_nothrow_copy_constructible<_Hash>,
-- line 497 ----------------------------------------
-- line 520 ----------------------------------------
      .              .            .               .              .              .               .           .           .                 template<typename _InputIterator>
      .              .            .               .              .              .               .           .           .           	_Hashtable(_InputIterator __first, _InputIterator __last,
      .              .            .               .              .              .               .           .           .           		   size_type __bkt_count_hint,
      .              .            .               .              .              .               .           .           .           		   const _Hash&, const _Equal&, const allocator_type&,
      .              .            .               .              .              .               .           .           .           		   false_type __uks);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .               public:
      .              .            .               .              .              .               .           .           .                 // Constructor, destructor, assignment, swap
 19,346 ( 0.00%)   512 ( 0.02%)  25 ( 0.02%)  6,828 ( 0.01%)   563 ( 0.12%)   116 ( 0.11%)  5,690 ( 0.01%)  4 ( 0.00%)  3 ( 0.00%)        _Hashtable() = default;
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 _Hashtable(const _Hashtable&);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 _Hashtable(const _Hashtable&, const allocator_type&);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 explicit
      .              .            .               .              .              .               .           .           .                 _Hashtable(size_type __bkt_count_hint,
      .              .            .               .              .              .               .           .           .           		 const _Hash& __hf = _Hash(),
-- line 536 ----------------------------------------
-- line 561 ----------------------------------------
      .              .            .               .              .              .               .           .           .           		   size_type __bkt_count_hint = 0,
      .              .            .               .              .              .               .           .           .           		   const _Hash& __hf = _Hash(),
      .              .            .               .              .              .               .           .           .           		   const key_equal& __eql = key_equal(),
      .              .            .               .              .              .               .           .           .           		   const allocator_type& __a = allocator_type())
      .              .            .               .              .              .               .           .           .           	: _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
      .              .            .               .              .              .               .           .           .           		     __unique_keys{})
      .              .            .               .              .              .               .           .           .           	{ }
      .              .            .               .              .              .               .           .           .           
  7,854 ( 0.00%)   561 ( 0.02%) 280 ( 0.22%)      0              0              0           4,488 ( 0.01%)  0           0                 _Hashtable(initializer_list<value_type> __l,
      .              .            .               .              .              .               .           .           .           		 size_type __bkt_count_hint = 0,
      .              .            .               .              .              .               .           .           .           		 const _Hash& __hf = _Hash(),
      .              .            .               .              .              .               .           .           .           		 const key_equal& __eql = key_equal(),
      .              .            .               .              .              .               .           .           .           		 const allocator_type& __a = allocator_type())
      .              .            .               .              .              .               .           .           .                 : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint,
 11,781 ( 0.00%)     2 ( 0.00%)   1 ( 0.00%)  2,805 ( 0.00%)     0              0           2,244 ( 0.00%)  0           0           		   __hf, __eql, __a, __unique_keys{})
  2,244 ( 0.00%)     0            0           1,683 ( 0.00%)     0              0               0           0           0                 { }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 _Hashtable&
      .              .            .               .              .              .               .           .           .                 operator=(const _Hashtable& __ht);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 _Hashtable&
      .              .            .               .              .              .               .           .           .                 operator=(_Hashtable&& __ht)
      .              .            .               .              .              .               .           .           .                 noexcept(__node_alloc_traits::_S_nothrow_move()
      .              .            .               .              .              .               .           .           .           	       && is_nothrow_move_assignable<_Hash>::value
-- line 584 ----------------------------------------
-- line 613 ----------------------------------------
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 void
      .              .            .               .              .              .               .           .           .                 swap(_Hashtable&)
      .              .            .               .              .              .               .           .           .                 noexcept(__and_<__is_nothrow_swappable<_Hash>,
      .              .            .               .              .              .               .           .           .           		      __is_nothrow_swappable<_Equal>>::value);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 // Basic container operations
      .              .            .               .              .              .               .           .           .                 iterator
 13,464 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)  1,683 ( 0.00%)     0              0           5,049 ( 0.01%)  0           0                 begin() noexcept
 23,562 ( 0.01%)   573 ( 0.02%)   7 ( 0.01%) 10,098 ( 0.01%)     0              0           3,366 ( 0.00%)  0           0                 { return iterator(_M_begin()); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 const_iterator
      .              .            .               .              .              .               .           .           .                 begin() const noexcept
      .              .            .               .              .              .               .           .           .                 { return const_iterator(_M_begin()); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 iterator
 18,008 ( 0.00%) 2,266 ( 0.08%) 944 ( 0.74%)  2,251 ( 0.00%)     0              0           6,753 ( 0.01%)  0           0                 end() noexcept
 22,510 ( 0.01%)     0            0          11,255 ( 0.01%)     0              0           2,251 ( 0.00%)  0           0                 { return iterator(nullptr); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 const_iterator
      .              .            .               .              .              .               .           .           .                 end() const noexcept
      .              .            .               .              .              .               .           .           .                 { return const_iterator(nullptr); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 const_iterator
      .              .            .               .              .              .               .           .           .                 cbegin() const noexcept
      .              .            .               .              .              .               .           .           .                 { return const_iterator(_M_begin()); }
-- line 638 ----------------------------------------
-- line 782 ----------------------------------------
      .              .            .               .              .              .               .           .           .           	       typename = __has_is_transparent_t<_Equal, _Kt>>
      .              .            .               .              .              .               .           .           .           	pair<const_iterator, const_iterator>
      .              .            .               .              .              .               .           .           .           	_M_equal_range_tr(const _Kt& __k) const;
      .              .            .               .              .              .               .           .           .           #endif // C++20
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .               private:
      .              .            .               .              .              .               .           .           .                 // Bucket index computation helpers.
      .              .            .               .              .              .               .           .           .                 size_type
 80,874 ( 0.02%) 1,137 ( 0.04%) 281 ( 0.22%)      0              0              0          40,437 ( 0.06%)  0           0                 _M_bucket_index(const __node_value_type& __n) const noexcept
121,311 ( 0.03%)    14 ( 0.00%)  13 ( 0.01%) 80,874 ( 0.07%)    20 ( 0.00%)     0          13,479 ( 0.02%)  0           0                 { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 size_type
 40,842 ( 0.01%)   586 ( 0.02%)  23 ( 0.02%)      0              0              0          20,421 ( 0.03%)  0           0                 _M_bucket_index(__hash_code __c) const
 61,263 ( 0.01%)   165 ( 0.01%)  14 ( 0.01%) 40,842 ( 0.04%)   194 ( 0.04%)    16 ( 0.02%)  6,807 ( 0.01%)  0           0                 { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 // Find and insert helper functions and types
      .              .            .               .              .              .               .           .           .                 // Find the node before the one matching the criteria.
      .              .            .               .              .              .               .           .           .                 __node_base_ptr
      .              .            .               .              .              .               .           .           .                 _M_find_before_node(size_type, const key_type&, __hash_code) const;
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 template<typename _Kt>
      .              .            .               .              .              .               .           .           .           	__node_base_ptr
      .              .            .               .              .              .               .           .           .           	_M_find_before_node_tr(size_type, const _Kt&, __hash_code) const;
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 __node_ptr
 45,448 ( 0.01%)    23 ( 0.00%)  23 ( 0.02%)      0              0              0          28,405 ( 0.04%)  0           0                 _M_find_node(size_type __bkt, const key_type& __key,
      .              .            .               .              .              .               .           .           .           		   __hash_code __c) const
      .              .            .               .              .              .               .           .           .                 {
 39,767 ( 0.01%)   163 ( 0.01%)  29 ( 0.02%) 22,724 ( 0.02%)     0              0          11,362 ( 0.02%)  0           0           	__node_base_ptr __before_n = _M_find_before_node(__bkt, __key, __c);
 11,362 ( 0.00%)     0            0           5,681 ( 0.01%)     0              0               0           0           0           	if (__before_n)
  3,507 ( 0.00%)    16 ( 0.00%)  14 ( 0.01%)  2,338 ( 0.00%)     0              0               0           0           0           	  return static_cast<__node_ptr>(__before_n->_M_nxt);
  4,512 ( 0.00%)     7 ( 0.00%)   6 ( 0.00%)      0              0              0               0           0           0           	return nullptr;
 11,362 ( 0.00%)     0            0          11,362 ( 0.01%)     0              0               0           0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 template<typename _Kt>
      .              .            .               .              .              .               .           .           .           	__node_ptr
      .              .            .               .              .              .               .           .           .           	_M_find_node_tr(size_type __bkt, const _Kt& __key,
      .              .            .               .              .              .               .           .           .           			__hash_code __c) const
      .              .            .               .              .              .               .           .           .           	{
      .              .            .               .              .              .               .           .           .           	  auto __before_n = _M_find_before_node_tr(__bkt, __key, __c);
      .              .            .               .              .              .               .           .           .           	  if (__before_n)
-- line 822 ----------------------------------------
-- line 906 ----------------------------------------
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 iterator
      .              .            .               .              .              .               .           .           .                 _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .               public:
      .              .            .               .              .              .               .           .           .                 // Emplace
      .              .            .               .              .              .               .           .           .                 template<typename... _Args>
      .              .            .               .              .              .               .           .           .           	__ireturn_type
 13,464 ( 0.00%)     0            0               0              0              0           6,732 ( 0.01%)  0           0           	emplace(_Args&&... __args)
 22,440 ( 0.01%)     1 ( 0.00%)   0           8,976 ( 0.01%)     0              0           4,488 ( 0.01%)  0           0           	{ return _M_emplace(__unique_keys{}, std::forward<_Args>(__args)...); }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 template<typename... _Args>
      .              .            .               .              .              .               .           .           .           	iterator
      .              .            .               .              .              .               .           .           .           	emplace_hint(const_iterator __hint, _Args&&... __args)
      .              .            .               .              .              .               .           .           .           	{
      .              .            .               .              .              .               .           .           .           	  return _M_emplace(__hint, __unique_keys{},
      .              .            .               .              .              .               .           .           .           			    std::forward<_Args>(__args)...);
      .              .            .               .              .              .               .           .           .           	}
-- line 923 ----------------------------------------
-- line 1112 ----------------------------------------
      .              .            .               .              .              .               .           .           .                 __node_base_ptr __n = _M_buckets[__bkt];
      .              .            .               .              .              .               .           .           .                 return __n ? static_cast<__node_ptr>(__n->_M_nxt) : nullptr;
      .              .            .               .              .              .               .           .           .               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
  5,610 ( 0.00%)     7 ( 0.00%)   1 ( 0.00%)      0              0              0           3,927 ( 0.01%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               _Hashtable(size_type __bkt_count_hint,
      .              .            .               .              .              .               .           .           .           	       const _Hash& __h, const _Equal& __eq, const allocator_type& __a)
  3,366 ( 0.00%)     0            0           2,244 ( 0.00%)     0              0             561 ( 0.00%)  0           0               : _Hashtable(__h, __eq, __a)
      .              .            .               .              .              .               .           .           .               {
  3,927 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)  1,122 ( 0.00%)     0              0           1,122 ( 0.00%)  0           0                 auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);
  2,244 ( 0.00%)     0            0           1,683 ( 0.00%)     0              0               0           0           0                 if (__bkt_count > _M_bucket_count)
      .              .            .               .              .              .               .           .           .           	{
      .              .            .               .              .              .               .           .           .           	  _M_buckets = _M_allocate_buckets(__bkt_count);
      .              .            .               .              .              .               .           .           .           	  _M_bucket_count = __bkt_count;
      .              .            .               .              .              .               .           .           .           	}
  2,244 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)  1,683 ( 0.00%)     0              0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               template<typename _InputIterator>
  6,171 ( 0.00%)   561 ( 0.02%)  64 ( 0.05%)      0              0              0           4,488 ( 0.01%)  0           0                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .                 _Hashtable(_InputIterator __f, _InputIterator __l,
      .              .            .               .              .              .               .           .           .           		 size_type __bkt_count_hint,
      .              .            .               .              .              .               .           .           .           		 const _Hash& __h, const _Equal& __eq,
      .              .            .               .              .              .               .           .           .           		 const allocator_type& __a, true_type /* __uks */)
  3,927 ( 0.00%)     0            0           2,805 ( 0.00%)     0              0             561 ( 0.00%)  0           0                 : _Hashtable(__bkt_count_hint, __h, __eq, __a)
      .              .            .               .              .              .               .           .           .                 {
  8,976 ( 0.00%)   561 ( 0.02%) 142 ( 0.11%)  6,171 ( 0.01%)     0              0               0           0           0           	for (; __f != __l; ++__f)
  8,415 ( 0.00%)     0            0           3,366 ( 0.00%)     0              0           1,683 ( 0.00%)  0           0           	  this->insert(*__f);
  2,244 ( 0.00%)     2 ( 0.00%)   1 ( 0.00%)  1,683 ( 0.00%)     0              0               0           0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               template<typename _InputIterator>
      .              .            .               .              .              .               .           .           .                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1157 ----------------------------------------
-- line 1177 ----------------------------------------
      .              .            .               .              .              .               .           .           .           	  this->insert(*__f);
      .              .            .               .              .              .               .           .           .                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               auto
     30 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      3 ( 0.00%)     0              0              15 ( 0.00%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               operator=(const _Hashtable& __ht)
      .              .            .               .              .              .               .           .           .               -> _Hashtable&
      .              .            .               .              .              .               .           .           .               {
      9 ( 0.00%)     0            0               6 ( 0.00%)     0              0               0           0           0                 if (&__ht == this)
      .              .            .               .              .              .               .           .           .           	return *this;
      .              .            .               .              .              .               .           .           .           
      9 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      0              0              0               3 ( 0.00%)  0           0                 if (__node_alloc_traits::_S_propagate_on_copy_assign())
      .              .            .               .              .              .               .           .           .           	{
      .              .            .               .              .              .               .           .           .           	  auto& __this_alloc = this->_M_node_allocator();
      .              .            .               .              .              .               .           .           .           	  auto& __that_alloc = __ht._M_node_allocator();
      .              .            .               .              .              .               .           .           .           	  if (!__node_alloc_traits::_S_always_equal()
      .              .            .               .              .              .               .           .           .           	      && __this_alloc != __that_alloc)
      .              .            .               .              .              .               .           .           .           	    {
      .              .            .               .              .              .               .           .           .           	      // Replacement allocator cannot free existing storage.
      .              .            .               .              .              .               .           .           .           	      this->_M_deallocate_nodes(_M_begin());
-- line 1201 ----------------------------------------
-- line 1220 ----------------------------------------
      .              .            .               .              .              .               .           .           .           		  __throw_exception_again;
      .              .            .               .              .              .               .           .           .           		}
      .              .            .               .              .              .               .           .           .           	      return *this;
      .              .            .               .              .              .               .           .           .           	    }
      .              .            .               .              .              .               .           .           .           	  std::__alloc_on_copy(__this_alloc, __that_alloc);
      .              .            .               .              .              .               .           .           .           	}
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 // Reuse allocated buckets and nodes.
     15 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)      6 ( 0.00%)     0              0               3 ( 0.00%)  0           0                 _M_assign_elements(__ht);
      3 ( 0.00%)     0            0               3 ( 0.00%)     0              0               0           0           0                 return *this;
     18 ( 0.00%)     0            0              15 ( 0.00%)     0              0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               template<typename _Ht>
      .              .            .               .              .              .               .           .           .                 void
     30 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      3 ( 0.00%)     0              0              15 ( 0.00%)  0           0                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .                 _M_assign_elements(_Ht&& __ht)
      .              .            .               .              .              .               .           .           .                 {
      3 ( 0.00%)     0            0               0              0              0               3 ( 0.00%)  0           0           	__buckets_ptr __former_buckets = nullptr;
      9 ( 0.00%)     0            0               6 ( 0.00%)     0              0               3 ( 0.00%)  0           0           	std::size_t __former_bucket_count = _M_bucket_count;
     21 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      3 ( 0.00%)     0              0               9 ( 0.00%)  0           0           	const __rehash_state& __former_state = _M_rehash_policy._M_state();
      .              .            .               .              .              .               .           .           .           
     18 ( 0.00%)     0            0              12 ( 0.00%)     0              0               0           0           0           	if (_M_bucket_count != __ht._M_bucket_count)
      .              .            .               .              .              .               .           .           .           	  {
      3 ( 0.00%)     0            0               2 ( 0.00%)     0              0               1 ( 0.00%)  0           0           	    __former_buckets = _M_buckets;
      8 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      4 ( 0.00%)     0              0               2 ( 0.00%)  0           0           	    _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
      5 ( 0.00%)     0            0               3 ( 0.00%)     0              0               1 ( 0.00%)  0           0           	    _M_bucket_count = __ht._M_bucket_count;
      .              .            .               .              .              .               .           .           .           	  }
      .              .            .               .              .              .               .           .           .           	else
     12 ( 0.00%)     0            0               4 ( 0.00%)     0              0               2 ( 0.00%)  0           0           	  __builtin_memset(_M_buckets, 0,
      4 ( 0.00%)     0            0               4 ( 0.00%)     0              0               0           0           0           			   _M_bucket_count * sizeof(__node_base_ptr));
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	__try
      .              .            .               .              .              .               .           .           .           	  {
      9 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      3 ( 0.00%)     0              0               3 ( 0.00%)  0           0           	    __hashtable_base::operator=(std::forward<_Ht>(__ht));
     12 ( 0.00%)     0            0               9 ( 0.00%)     0              0               3 ( 0.00%)  0           0           	    _M_element_count = __ht._M_element_count;
     18 ( 0.00%)     0            0              12 ( 0.00%)     0              0               6 ( 0.00%)  0           0           	    _M_rehash_policy = __ht._M_rehash_policy;
     27 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      6 ( 0.00%)     0              0               6 ( 0.00%)  0           0           	    __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
      6 ( 0.00%)     0            0               3 ( 0.00%)     0              0               3 ( 0.00%)  0           0           	    _M_before_begin._M_nxt = nullptr;
     27 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      6 ( 0.00%)     0              0               6 ( 0.00%)  0           0           	    _M_assign(std::forward<_Ht>(__ht), __roan);
      6 ( 0.00%)     0            0               3 ( 0.00%)     0              0               0           0           0           	    if (__former_buckets)
      6 ( 0.00%)     0            0               3 ( 0.00%)     0              0               1 ( 0.00%)  0           0           	      _M_deallocate_buckets(__former_buckets, __former_bucket_count);
      9 ( 0.00%)     0            0               0              0              0               3 ( 0.00%)  0           0           	  }
      .              .            .               .              .              .               .           .           .           	__catch(...)
      .              .            .               .              .              .               .           .           .           	  {
      .              .            .               .              .              .               .           .           .           	    if (__former_buckets)
      .              .            .               .              .              .               .           .           .           	      {
      .              .            .               .              .              .               .           .           .           		// Restore previous buckets.
      .              .            .               .              .              .               .           .           .           		_M_deallocate_buckets();
      .              .            .               .              .              .               .           .           .           		_M_rehash_policy._M_reset(__former_state);
      .              .            .               .              .              .               .           .           .           		_M_buckets = __former_buckets;
      .              .            .               .              .              .               .           .           .           		_M_bucket_count = __former_bucket_count;
      .              .            .               .              .              .               .           .           .           	      }
      .              .            .               .              .              .               .           .           .           	    __builtin_memset(_M_buckets, 0,
      .              .            .               .              .              .               .           .           .           			     _M_bucket_count * sizeof(__node_base_ptr));
      .              .            .               .              .              .               .           .           .           	    __throw_exception_again;
      .              .            .               .              .              .               .           .           .           	  }
     21 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)     15 ( 0.00%)     0              0               0           0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               template<typename _Ht, typename _NodeGenerator>
      .              .            .               .              .              .               .           .           .                 void
 22,464 ( 0.01%) 1,123 ( 0.04%)   2 ( 0.00%)      0              0              0          14,040 ( 0.02%)  0           0                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .                 _M_assign(_Ht&& __ht, const _NodeGenerator& __node_gen)
      .              .            .               .              .              .               .           .           .                 {
  2,808 ( 0.00%)     0            0               0              0              0           2,808 ( 0.00%)  0           0           	__buckets_ptr __buckets = nullptr;
 11,232 ( 0.00%)     0            0           5,616 ( 0.01%)     0              0               0           0           0           	if (!_M_buckets)
 28,050 ( 0.01%)   559 ( 0.02%)   1 ( 0.00%) 14,025 ( 0.01%)     0              0           8,415 ( 0.01%)  0           0           	  _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	__try
      .              .            .               .              .              .               .           .           .           	  {
 11,232 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)  5,616 ( 0.01%)     0              0               0           0           0           	    if (!__ht._M_before_begin._M_nxt)
      2 ( 0.00%)     0            0               0              0              0               0           0           0           	      return;
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	    // First deal with the special first node pointed to by
      .              .            .               .              .              .               .           .           .           	    // _M_before_begin.
 11,224 ( 0.00%)     0            0           2,806 ( 0.00%)     0              0           5,612 ( 0.01%)  0           0           	    __node_ptr __ht_n = __ht._M_begin();
      .              .            .               .              .              .               .           .           .           	    __node_ptr __this_n
 33,672 ( 0.01%) 1,121 ( 0.04%)   2 ( 0.00%)  5,612 ( 0.01%)     0              0          11,224 ( 0.02%)  6 ( 0.00%)  0           	      = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
 22,448 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)  8,418 ( 0.01%)     0              0           2,806 ( 0.00%)  0           0           	    this->_M_copy_code(*__this_n, *__ht_n);
 14,030 ( 0.00%) 1,122 ( 0.04%)   1 ( 0.00%)  5,612 ( 0.01%)     0              0           2,806 ( 0.00%)  0           0           	    _M_update_bbegin(__this_n);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	    // Then deal with other nodes.
  5,612 ( 0.00%)     0            0           2,806 ( 0.00%)     0              0           2,806 ( 0.00%)  0           0           	    __node_ptr __prev_n = __this_n;
 66,766 ( 0.02%)   562 ( 0.02%)   3 ( 0.00%) 21,320 ( 0.02%)     0              0          21,320 ( 0.03%)  0           0           	    for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
      .              .            .               .              .              .               .           .           .           	      {
 94,248 ( 0.02%) 1,103 ( 0.04%)   9 ( 0.01%) 15,708 ( 0.01%)     0              0          31,416 ( 0.05%) 12 ( 0.00%)  0           		__this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
 23,562 ( 0.01%)     0            0          15,708 ( 0.01%)     0              0           7,854 ( 0.01%) 21 ( 0.01%)  0           		__prev_n->_M_nxt = __this_n;
 62,832 ( 0.01%)   561 ( 0.02%)   1 ( 0.00%) 23,562 ( 0.02%)     0              0           7,854 ( 0.01%)  0           0           		this->_M_copy_code(*__this_n, *__ht_n);
 54,978 ( 0.01%)     0            0          15,708 ( 0.01%)     0              0          15,708 ( 0.02%)  0           0           		size_type __bkt = _M_bucket_index(*__this_n);
 62,832 ( 0.01%)     0            0          31,416 ( 0.03%)     5 ( 0.00%)     0               0           0           0           		if (!_M_buckets[__bkt])
 23,562 ( 0.01%)     0            0          13,464 ( 0.01%)     0              0           3,366 ( 0.00%)  0           0           		  _M_buckets[__bkt] = __prev_n;
 15,708 ( 0.00%)     0            0           7,854 ( 0.01%)     0              0           7,854 ( 0.01%)  0           0           		__prev_n = __this_n;
      .              .            .               .              .              .               .           .           .           	      }
      .              .            .               .              .              .               .           .           .           	  }
      .              .            .               .              .              .               .           .           .           	__catch(...)
      .              .            .               .              .              .               .           .           .           	  {
      .              .            .               .              .              .               .           .           .           	    clear();
      .              .            .               .              .              .               .           .           .           	    if (__buckets)
      .              .            .               .              .              .               .           .           .           	      _M_deallocate_buckets();
      .              .            .               .              .              .               .           .           .           	    __throw_exception_again;
      .              .            .               .              .              .               .           .           .           	  }
 11,230 ( 0.00%) 1,124 ( 0.04%) 140 ( 0.11%)  8,424 ( 0.01%)     0              0               0           0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               void
      .              .            .               .              .              .               .           .           .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1338 ----------------------------------------
-- line 1398 ----------------------------------------
      .              .            .               .              .              .               .           .           .           	  __ht.clear();
      .              .            .               .              .              .               .           .           .           	}
      .              .            .               .              .              .               .           .           .               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
 28,050 ( 0.01%)   561 ( 0.02%) 129 ( 0.10%)  2,805 ( 0.00%)     0              0          14,025 ( 0.02%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               _Hashtable(const _Hashtable& __ht)
      .              .            .               .              .              .               .           .           .               : __hashtable_base(__ht),
      .              .            .               .              .              .               .           .           .                 __map_base(__ht),
      .              .            .               .              .              .               .           .           .                 __rehash_base(__ht),
      .              .            .               .              .              .               .           .           .                 __hashtable_alloc(
 11,220 ( 0.00%)   561 ( 0.02%)  21 ( 0.02%)  2,805 ( 0.00%)     0              0           2,805 ( 0.00%)  0           0           	__node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
      .              .            .               .              .              .               .           .           .                 __enable_default_ctor(__ht),
  5,610 ( 0.00%)   561 ( 0.02%)  22 ( 0.02%)  2,805 ( 0.00%)     0              0           2,805 ( 0.00%)  0           0                 _M_buckets(nullptr),
 11,220 ( 0.00%)     0            0           8,415 ( 0.01%)    56 ( 0.01%)     3 ( 0.00%)  2,805 ( 0.00%)  0           0                 _M_bucket_count(__ht._M_bucket_count),
 11,220 ( 0.00%)     0            0           8,415 ( 0.01%)     0              0           2,805 ( 0.00%)  0           0                 _M_element_count(__ht._M_element_count),
 67,320 ( 0.02%)   561 ( 0.02%)  27 ( 0.02%) 19,635 ( 0.02%)     0              0          19,635 ( 0.03%) 46 ( 0.02%)  4 ( 0.00%)        _M_rehash_policy(__ht._M_rehash_policy)
      .              .            .               .              .              .               .           .           .               {
 14,025 ( 0.00%)     0            0           2,805 ( 0.00%)     0              0           2,805 ( 0.00%)  0           0                 __alloc_node_gen_t __alloc_node_gen(*this);
 16,830 ( 0.00%)    26 ( 0.00%)  24 ( 0.02%)  5,610 ( 0.01%)     0              0           2,805 ( 0.00%)  0           0                 _M_assign(__ht, __alloc_node_gen);
 19,635 ( 0.00%)    24 ( 0.00%)  22 ( 0.02%) 14,025 ( 0.01%)     7 ( 0.00%)     0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
-- line 1430 ----------------------------------------
-- line 1520 ----------------------------------------
      .              .            .               .              .              .               .           .           .           	  __ht.clear();
      .              .            .               .              .              .               .           .           .           	}
      .              .            .               .              .              .               .           .           .               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
 19,650 ( 0.00%)   563 ( 0.02%) 258 ( 0.20%)      0              0              0           7,860 ( 0.01%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               ~_Hashtable() noexcept
      .              .            .               .              .              .               .           .           .               {
 11,790 ( 0.00%)     1 ( 0.00%)   0           3,930 ( 0.00%)     0              0           3,930 ( 0.01%)  0           0                 clear();
 11,790 ( 0.00%)     0            0           3,930 ( 0.00%)     0              0           3,930 ( 0.01%)  0           0                 _M_deallocate_buckets();
 23,580 ( 0.01%)   562 ( 0.02%) 248 ( 0.19%) 11,790 ( 0.01%)     0              0           3,930 ( 0.01%)  0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               void
      .              .            .               .              .              .               .           .           .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1542 ----------------------------------------
-- line 1580 ----------------------------------------
      .              .            .               .              .              .               .           .           .                 __x._M_update_bbegin();
      .              .            .               .              .              .               .           .           .               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               auto
  5,112 ( 0.00%)   576 ( 0.02%)  62 ( 0.05%)    568 ( 0.00%)     0              0           2,272 ( 0.00%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               find(const key_type& __k)
      .              .            .               .              .              .               .           .           .               -> iterator
      .              .            .               .              .              .               .           .           .               {
  3,408 ( 0.00%)   560 ( 0.02%)  78 ( 0.06%)  1,136 ( 0.00%)     0              0           1,136 ( 0.00%)  0           0                 __hash_code __code = this->_M_hash_code(__k);
  3,408 ( 0.00%)     0            0           1,136 ( 0.00%)     0              0           1,136 ( 0.00%)  0           0                 std::size_t __bkt = _M_bucket_index(__code);
  6,816 ( 0.00%)     0            0           2,840 ( 0.00%)     0              0           1,136 ( 0.00%)  0           0                 return iterator(_M_find_node(__bkt, __k, __code));
  2,840 ( 0.00%)     0            0           2,272 ( 0.00%)     0              0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               auto
      .              .            .               .              .              .               .           .           .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1604 ----------------------------------------
-- line 1819 ----------------------------------------
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             // Find the node before the one whose key compares equal to k in the bucket
      .              .            .               .              .              .               .           .           .             // bkt. Return nullptr if no node is found.
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               auto
 45,448 ( 0.01%)   584 ( 0.02%)  26 ( 0.02%)      0              0              0          28,405 ( 0.04%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               _M_find_before_node(size_type __bkt, const key_type& __k,
      .              .            .               .              .              .               .           .           .           			__hash_code __code) const
      .              .            .               .              .              .               .           .           .               -> __node_base_ptr
      .              .            .               .              .              .               .           .           .               {
 39,767 ( 0.01%)   562 ( 0.02%)   4 ( 0.00%) 22,724 ( 0.02%)   674 ( 0.14%)    66 ( 0.06%)  5,681 ( 0.01%)  0           0                 __node_base_ptr __prev_p = _M_buckets[__bkt];
 11,362 ( 0.00%)     0            0           5,681 ( 0.01%)     0              0               0           0           0                 if (!__prev_p)
  6,780 ( 0.00%)     7 ( 0.00%)   7 ( 0.01%)      0              0              0               0           0           0           	return nullptr;
      .              .            .               .              .              .               .           .           .           
  6,873 ( 0.00%)    16 ( 0.00%)  15 ( 0.01%)  4,582 ( 0.00%)    16 ( 0.00%)     6 ( 0.01%)  2,291 ( 0.00%)  0           0                 for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
      .              .            .               .              .              .               .           .           .           	   __p = __p->_M_next())
      .              .            .               .              .              .               .           .           .           	{
 20,619 ( 0.00%)   571 ( 0.02%)  30 ( 0.02%)  9,164 ( 0.01%)     0              0           2,291 ( 0.00%)  0           0           	  if (this->_M_equals(__k, __code, *__p))
  2,338 ( 0.00%)     0            0           1,169 ( 0.00%)     0              0               0           0           0           	    return __prev_p;
      .              .            .               .              .              .               .           .           .           
 14,586 ( 0.00%)     0            0           3,927 ( 0.00%)     8 ( 0.00%)     0           1,122 ( 0.00%)  0           0           	  if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
  1,122 ( 0.00%)     0            0               0              0              0               0           0           0           	    break;
      .              .            .               .              .              .               .           .           .           	  __prev_p = __p;
      .              .            .               .              .              .               .           .           .           	}
      .              .            .               .              .              .               .           .           .           
  1,122 ( 0.00%)     0            0               0              0              0               0           0           0                 return nullptr;
 11,362 ( 0.00%)   586 ( 0.02%)  39 ( 0.03%) 11,362 ( 0.01%)     0              0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               template<typename _Kt>
      .              .            .               .              .              .               .           .           .                 auto
      .              .            .               .              .              .               .           .           .                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
-- line 1857 ----------------------------------------
-- line 1878 ----------------------------------------
      .              .            .               .              .              .               .           .           .           	return nullptr;
      .              .            .               .              .              .               .           .           .                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               void
 40,608 ( 0.01%)     0            0               0              0              0          27,072 ( 0.04%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               _M_insert_bucket_begin(size_type __bkt, __node_ptr __node)
      .              .            .               .              .              .               .           .           .               {
 36,096 ( 0.01%)    32 ( 0.00%)  30 ( 0.02%) 18,048 ( 0.02%)     1 ( 0.00%)     0               0           0           0                 if (_M_buckets[__bkt])
      .              .            .               .              .              .               .           .           .           	{
      .              .            .               .              .              .               .           .           .           	  // Bucket is not empty, we just need to insert the new node
      .              .            .               .              .              .               .           .           .           	  // after the bucket before begin.
 10,098 ( 0.00%)     0            0           6,732 ( 0.01%)     0              0           1,122 ( 0.00%)  0           0           	  __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
  8,976 ( 0.00%)     0            0           5,610 ( 0.01%)     0              0           1,122 ( 0.00%)  0           0           	  _M_buckets[__bkt]->_M_nxt = __node;
      .              .            .               .              .              .               .           .           .           	}
      .              .            .               .              .              .               .           .           .                 else
      .              .            .               .              .              .               .           .           .           	{
      .              .            .               .              .              .               .           .           .           	  // The bucket is empty, the new node is inserted at the
      .              .            .               .              .              .               .           .           .           	  // beginning of the singly-linked list and the bucket will
      .              .            .               .              .              .               .           .           .           	  // contain _M_before_begin pointer.
 13,560 ( 0.00%)   586 ( 0.02%)  47 ( 0.04%) 10,170 ( 0.01%)     0              0           3,390 ( 0.00%)  7 ( 0.00%)  0           	  __node->_M_nxt = _M_before_begin._M_nxt;
 10,170 ( 0.00%)     0            0           6,780 ( 0.01%)     0              0           3,390 ( 0.00%)  0           0           	  _M_before_begin._M_nxt = __node;
      .              .            .               .              .              .               .           .           .           
 13,560 ( 0.00%)     0            0           6,780 ( 0.01%)     0              0               0           0           0           	  if (__node->_M_nxt)
      .              .            .               .              .              .               .           .           .           	    // We must update former begin bucket that is pointing to
      .              .            .               .              .              .               .           .           .           	    // _M_before_begin.
 31,612 ( 0.01%)   575 ( 0.02%)  22 ( 0.02%) 11,290 ( 0.01%)     0              0           6,774 ( 0.01%) 93 ( 0.04%) 21 ( 0.03%)  	    _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;
      .              .            .               .              .              .               .           .           .           
 27,120 ( 0.01%)    35 ( 0.00%)  35 ( 0.03%) 13,560 ( 0.01%)     0              0           3,390 ( 0.00%)  0           0           	  _M_buckets[__bkt] = &_M_before_begin;
      .              .            .               .              .              .               .           .           .           	}
 28,194 ( 0.01%)   561 ( 0.02%)  86 ( 0.07%) 18,048 ( 0.02%)     0              0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               void
      .              .            .               .              .              .               .           .           .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1920 ----------------------------------------
-- line 1952 ----------------------------------------
      .              .            .               .              .              .               .           .           .               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               template<typename... _Args>
      .              .            .               .              .              .               .           .           .                 auto
 26,928 ( 0.01%) 1,122 ( 0.04%)   2 ( 0.00%)  2,244 ( 0.00%)     0              0          15,708 ( 0.02%)  0           0                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .                 _M_emplace(true_type /* __uks */, _Args&&... __args)
      .              .            .               .              .              .               .           .           .                 -> pair<iterator, bool>
      .              .            .               .              .              .               .           .           .                 {
      .              .            .               .              .              .               .           .           .           	// First build the node to get access to the hash code
 20,196 ( 0.00%)     0            0           4,488 ( 0.00%)     0              0           4,488 ( 0.01%)  0           0           	_Scoped_node __node { this, std::forward<_Args>(__args)...  };
 22,440 ( 0.01%)   561 ( 0.02%)  46 ( 0.04%)  2,244 ( 0.00%)     0              0           6,732 ( 0.01%)  0           0           	const key_type& __k = _ExtractKey{}(__node._M_node->_M_v());
 13,464 ( 0.00%)     0            0           4,488 ( 0.00%)     0              0           4,488 ( 0.01%)  0           0           	__hash_code __code = this->_M_hash_code(__k);
 13,464 ( 0.00%)   561 ( 0.02%)  76 ( 0.06%)  4,488 ( 0.00%)     0              0           4,488 ( 0.01%)  0           0           	size_type __bkt = _M_bucket_index(__code);
 20,196 ( 0.00%)     0            0          11,220 ( 0.01%)     0              0           4,488 ( 0.01%)  0           0           	if (__node_ptr __p = _M_find_node(__bkt, __k, __code))
      .              .            .               .              .              .               .           .           .           	  // There is already an equivalent node, no insertion
      .              .            .               .              .              .               .           .           .           	  return std::make_pair(iterator(__p), false);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	// Insert the node
 17,952 ( 0.00%) 1,122 ( 0.04%) 612 ( 0.48%)  8,976 ( 0.01%)     0              0           4,488 ( 0.01%)  0           0           	auto __pos = _M_insert_unique_node(__bkt, __code, __node._M_node);
  2,244 ( 0.00%)     0            0               0              0              0           2,244 ( 0.00%)  0           0           	__node._M_node = nullptr;
 20,196 ( 0.00%)     0            0           4,488 ( 0.00%)     0              0           4,488 ( 0.01%)  0           0           	return { __pos, true };
 31,416 ( 0.01%)   561 ( 0.02%)  38 ( 0.03%) 15,708 ( 0.01%)     0              0           2,244 ( 0.00%)  0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               template<typename... _Args>
      .              .            .               .              .              .               .           .           .                 auto
      .              .            .               .              .              .               .           .           .                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
-- line 1986 ----------------------------------------
-- line 2000 ----------------------------------------
      .              .            .               .              .              .               .           .           .           	return __pos;
      .              .            .               .              .              .               .           .           .                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               auto
 54,144 ( 0.01%)    57 ( 0.00%)  30 ( 0.02%)  4,512 ( 0.00%)     0              0          31,584 ( 0.05%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               _M_insert_unique_node(size_type __bkt, __hash_code __code,
      .              .            .               .              .              .               .           .           .           			  __node_ptr __node, size_type __n_elt)
      .              .            .               .              .              .               .           .           .               -> iterator
      .              .            .               .              .              .               .           .           .               {
 31,584 ( 0.01%)    46 ( 0.00%)  33 ( 0.03%)  4,512 ( 0.00%)     0              0          13,536 ( 0.02%)  0           0                 const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      .              .            .               .              .              .               .           .           .                 std::pair<bool, std::size_t> __do_rehash
 58,656 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%) 27,072 ( 0.02%)     0              0          13,536 ( 0.02%)  0           0           	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
      .              .            .               .              .              .               .           .           .           					  __n_elt);
      .              .            .               .              .              .               .           .           .           
 13,536 ( 0.00%)   111 ( 0.00%)  26 ( 0.02%)  4,512 ( 0.00%)     0              0               0           0           0                 if (__do_rehash.first)
      .              .            .               .              .              .               .           .           .           	{
  6,756 ( 0.00%)     0            0           3,378 ( 0.00%)     0              0           1,126 ( 0.00%)  0           0           	  _M_rehash(__do_rehash.second, __saved_state);
  6,756 ( 0.00%)     0            0           2,252 ( 0.00%)     0              0           2,252 ( 0.00%)  0           0           	  __bkt = _M_bucket_index(__code);
      .              .            .               .              .              .               .           .           .           	}
      .              .            .               .              .              .               .           .           .           
 31,584 ( 0.01%)   586 ( 0.02%)  25 ( 0.02%) 13,536 ( 0.01%)     0              0           4,512 ( 0.01%)  0           0                 this->_M_store_code(*__node, __code);
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .                 // Always insert at the beginning of the bucket.
 27,072 ( 0.01%)     0            0          13,536 ( 0.01%)     0              0           4,512 ( 0.01%)  0           0                 _M_insert_bucket_begin(__bkt, __node);
 22,560 ( 0.01%)     0            0          13,536 ( 0.01%)     0              0           4,512 ( 0.01%)  0           0                 ++_M_element_count;
 27,072 ( 0.01%) 1,146 ( 0.04%)  38 ( 0.03%)  9,024 ( 0.01%)     0              0           4,512 ( 0.01%)  0           0                 return iterator(__node);
 22,560 ( 0.01%)     0            0          18,048 ( 0.02%)     0              0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               auto
      .              .            .               .              .              .               .           .           .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2039 ----------------------------------------
-- line 2087 ----------------------------------------
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             // Insert v if no element with its key is already present.
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               template<typename _Arg, typename _NodeGenerator>
      .              .            .               .              .              .               .           .           .                 auto
 21,879 ( 0.01%)   561 ( 0.02%) 290 ( 0.23%)  1,683 ( 0.00%)     0              0          13,464 ( 0.02%)  0           0                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           		 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .                 _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen,
      .              .            .               .              .              .               .           .           .           		true_type /* __uks */)
      .              .            .               .              .              .               .           .           .                 -> pair<iterator, bool>
      .              .            .               .              .              .               .           .           .                 {
 10,098 ( 0.00%)   561 ( 0.02%)  32 ( 0.03%)  1,683 ( 0.00%)     0              0           3,366 ( 0.00%)  0           0           	const key_type& __k = _ExtractKey{}(__v);
 10,098 ( 0.00%)     0            0           3,366 ( 0.00%)     0              0           3,366 ( 0.00%)  0           0           	__hash_code __code = this->_M_hash_code(__k);
 10,098 ( 0.00%)   561 ( 0.02%)   9 ( 0.01%)  3,366 ( 0.00%)     0              0           3,366 ( 0.00%)  0           0           	size_type __bkt = _M_bucket_index(__code);
      .              .            .               .              .              .               .           .           .           
 15,147 ( 0.00%)     0            0           8,415 ( 0.01%)     0              0           3,366 ( 0.00%)  0           0           	if (__node_ptr __node = _M_find_node(__bkt, __k, __code))
      .              .            .               .              .              .               .           .           .           	  return { iterator(__node), false };
      .              .            .               .              .              .               .           .           .           
 23,562 ( 0.01%) 1,122 ( 0.04%)   6 ( 0.00%)  5,049 ( 0.00%)     0              0           5,049 ( 0.01%)  0           0           	_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };
      .              .            .               .              .              .               .           .           .           	auto __pos
 13,464 ( 0.00%)    10 ( 0.00%)   1 ( 0.00%)  6,732 ( 0.01%)     0              0           3,366 ( 0.00%)  0           0           	  = _M_insert_unique_node(__bkt, __code, __node._M_node);
  1,683 ( 0.00%)     0            0               0              0              0           1,683 ( 0.00%)  0           0           	__node._M_node = nullptr;
 15,147 ( 0.00%)     0            0           3,366 ( 0.00%)     0              0           3,366 ( 0.00%)  0           0           	return { __pos, true };
 23,562 ( 0.01%)   562 ( 0.02%)  25 ( 0.02%) 11,781 ( 0.01%)     0              0           1,683 ( 0.00%)  0           0                 }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             // Insert v unconditionally.
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               template<typename _Arg, typename _NodeGenerator>
      .              .            .               .              .              .               .           .           .                 auto
-- line 2121 ----------------------------------------
-- line 2308 ----------------------------------------
      .              .            .               .              .              .               .           .           .                 return iterator(__n);
      .              .            .               .              .              .               .           .           .               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               void
 19,690 ( 0.00%)     6 ( 0.00%)   5 ( 0.00%)      0              0              0           7,876 ( 0.01%)  8 ( 0.00%)  0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               clear() noexcept
      .              .            .               .              .              .               .           .           .               {
 31,504 ( 0.01%)   562 ( 0.02%) 189 ( 0.15%)  7,876 ( 0.01%)     0              0           7,876 ( 0.01%)  0           0                 this->_M_deallocate_nodes(_M_begin());
 23,628 ( 0.01%)     5 ( 0.00%)   4 ( 0.00%)  7,876 ( 0.01%)   434 ( 0.09%)   419 ( 0.41%)  3,938 ( 0.01%)  0           0                 __builtin_memset(_M_buckets, 0,
  7,876 ( 0.00%)     0            0           7,876 ( 0.01%)     0              0               0           0           0           		       _M_bucket_count * sizeof(__node_base_ptr));
  7,876 ( 0.00%)     0            0           3,938 ( 0.00%)     0              0           3,938 ( 0.01%)  0           0                 _M_element_count = 0;
  7,876 ( 0.00%)    23 ( 0.00%)  22 ( 0.02%)  3,938 ( 0.00%)     0              0           3,938 ( 0.01%)  0           0                 _M_before_begin._M_nxt = nullptr;
 11,814 ( 0.00%)     0            0           7,876 ( 0.01%)     0              0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               void
      .              .            .               .              .              .               .           .           .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2333 ----------------------------------------
-- line 2347 ----------------------------------------
      .              .            .               .              .              .               .           .           .           	_M_rehash_policy._M_reset(__saved_state);
      .              .            .               .              .              .               .           .           .               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               void
  9,008 ( 0.00%)    20 ( 0.00%)  12 ( 0.01%)      0              0              0           5,630 ( 0.01%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               _M_rehash(size_type __bkt_count, const __rehash_state& __state)
      .              .            .               .              .              .               .           .           .               {
      .              .            .               .              .              .               .           .           .                 __try
      .              .            .               .              .              .               .           .           .           	{
  5,630 ( 0.00%)     0            0           2,252 ( 0.00%)     0              0           1,126 ( 0.00%)  0           0           	  _M_rehash_aux(__bkt_count, __unique_keys{});
      .              .            .               .              .              .               .           .           .           	}
      .              .            .               .              .              .               .           .           .                 __catch(...)
      .              .            .               .              .              .               .           .           .           	{
      .              .            .               .              .              .               .           .           .           	  // A failure here means that buckets allocation failed.  We only
      .              .            .               .              .              .               .           .           .           	  // have to restore hash policy previous state.
      .              .            .               .              .              .               .           .           .           	  _M_rehash_policy._M_reset(__state);
      .              .            .               .              .              .               .           .           .           	  __throw_exception_again;
      .              .            .               .              .              .               .           .           .           	}
  4,504 ( 0.00%)    16 ( 0.00%)   9 ( 0.01%)  3,378 ( 0.00%)     0              0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             // Rehash when there is no equivalent elements.
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               void
  6,756 ( 0.00%) 1,125 ( 0.04%)   5 ( 0.00%)      0              0              0           3,378 ( 0.00%)  0           0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      .              .            .               .              .              .               .           .           .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      .              .            .               .              .              .               .           .           .               _M_rehash_aux(size_type __bkt_count, true_type /* __uks */)
      .              .            .               .              .              .               .           .           .               {
  6,756 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)  2,252 ( 0.00%)     0              0           2,252 ( 0.00%)  0           0                 __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
  4,504 ( 0.00%)     0            0           1,126 ( 0.00%)     0              0           2,252 ( 0.00%)  0           0                 __node_ptr __p = _M_begin();
  2,252 ( 0.00%)     0            0           1,126 ( 0.00%)     0              0           1,126 ( 0.00%)  0           0                 _M_before_begin._M_nxt = nullptr;
  1,126 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)      0              0              0           1,126 ( 0.00%)  0           0                 std::size_t __bbegin_bkt = 0;
  3,378 ( 0.00%)     7 ( 0.00%)   7 ( 0.01%)  1,126 ( 0.00%)     0              0               0           0           0                 while (__p)
      .              .            .               .              .              .               .           .           .           	{
      .              .            .               .              .              .               .           .           .           	  __node_ptr __next = __p->_M_next();
      .              .            .               .              .              .               .           .           .           	  std::size_t __bkt
      .              .            .               .              .              .               .           .           .           	    = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
      .              .            .               .              .              .               .           .           .           	  if (!__new_buckets[__bkt])
      .              .            .               .              .              .               .           .           .           	    {
      .              .            .               .              .              .               .           .           .           	      __p->_M_nxt = _M_before_begin._M_nxt;
      .              .            .               .              .              .               .           .           .           	      _M_before_begin._M_nxt = __p;
-- line 2394 ----------------------------------------
-- line 2401 ----------------------------------------
      .              .            .               .              .              .               .           .           .           	    {
      .              .            .               .              .              .               .           .           .           	      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
      .              .            .               .              .              .               .           .           .           	      __new_buckets[__bkt]->_M_nxt = __p;
      .              .            .               .              .              .               .           .           .           	    }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .           	  __p = __next;
      .              .            .               .              .              .               .           .           .           	}
      .              .            .               .              .              .               .           .           .           
  3,378 ( 0.00%)     0            0           1,126 ( 0.00%)     0              0           1,126 ( 0.00%)  0           0                 _M_deallocate_buckets();
  3,378 ( 0.00%)     0            0           2,252 ( 0.00%)     0              0           1,126 ( 0.00%)  0           0                 _M_bucket_count = __bkt_count;
  3,378 ( 0.00%)     0            0           2,252 ( 0.00%)     0              0           1,126 ( 0.00%)  0           0                 _M_buckets = __new_buckets;
  3,378 ( 0.00%)     0            0           2,252 ( 0.00%)     0              0               0           0           0               }
      .              .            .               .              .              .               .           .           .           
      .              .            .               .              .              .               .           .           .             // Rehash when there can be equivalent elements, preserve their relative
      .              .            .               .              .              .               .           .           .             // order.
      .              .            .               .              .              .               .           .           .             template<typename _Key, typename _Value, typename _Alloc,
      .              .            .               .              .              .               .           .           .           	   typename _ExtractKey, typename _Equal,
      .              .            .               .              .              .               .           .           .           	   typename _Hash, typename _RangeHash, typename _Unused,
      .              .            .               .              .              .               .           .           .           	   typename _RehashPolicy, typename _Traits>
      .              .            .               .              .              .               .           .           .               void
-- line 2420 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/x86_64-linux-gnu/qt5/QtCore/qstring.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr        Dr               D1mr       DLmr       Dw              D1mw       DLmw       

-- line 675 ----------------------------------------
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .               const ushort *utf16() const;
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .           #if defined(Q_COMPILER_REF_QUALIFIERS) && !defined(QT_COMPILING_QSTRING_COMPAT_CPP) && !defined(Q_CLANG_QDOC)
      .              .           .                .          .          .               .          .          .               Q_REQUIRED_RESULT QByteArray toLatin1() const &
      .              .           .                .          .          .               .          .          .               { return toLatin1_helper(*this); }
      .              .           .                .          .          .               .          .          .               Q_REQUIRED_RESULT QByteArray toLatin1() &&
      .              .           .                .          .          .               .          .          .               { return toLatin1_helper_inplace(*this); }
     90 ( 0.00%)    13 ( 0.00%)  1 ( 0.00%)      10 ( 0.00%) 0          0              40 ( 0.00%) 0          0               Q_REQUIRED_RESULT QByteArray toUtf8() const &
    110 ( 0.00%)     0           0               70 ( 0.00%) 0          0              10 ( 0.00%) 0          0               { return toUtf8_helper(*this); }
  5,049 ( 0.00%) 1,122 ( 0.04%)  4 ( 0.00%)     561 ( 0.00%) 0          0           2,244 ( 0.00%) 0          0               Q_REQUIRED_RESULT QByteArray toUtf8() &&
  6,171 ( 0.00%)     0           0            3,927 ( 0.00%) 0          0             561 ( 0.00%) 0          0               { return toUtf8_helper(*this); }
      .              .           .                .          .          .               .          .          .               Q_REQUIRED_RESULT QByteArray toLocal8Bit() const &
      .              .           .                .          .          .               .          .          .               { return toLocal8Bit_helper(isNull() ? nullptr : constData(), size()); }
      .              .           .                .          .          .               .          .          .               Q_REQUIRED_RESULT QByteArray toLocal8Bit() &&
      .              .           .                .          .          .               .          .          .               { return toLocal8Bit_helper(isNull() ? nullptr : constData(), size()); }
      .              .           .                .          .          .               .          .          .           #else
      .              .           .                .          .          .               .          .          .               Q_REQUIRED_RESULT QByteArray toLatin1() const;
      .              .           .                .          .          .               .          .          .               Q_REQUIRED_RESULT QByteArray toUtf8() const;
      .              .           .                .          .          .               .          .          .               Q_REQUIRED_RESULT QByteArray toLocal8Bit() const;
-- line 694 ----------------------------------------
-- line 696 ----------------------------------------
      .              .           .                .          .          .               .          .          .               Q_REQUIRED_RESULT QVector<uint> toUcs4() const;
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .               // note - this are all inline so we can benefit from strlen() compile time optimizations
      .              .           .                .          .          .               .          .          .               static inline QString fromLatin1(const char *str, int size = -1)
      .              .           .                .          .          .               .          .          .               {
      .              .           .                .          .          .               .          .          .                   QStringDataPtr dataPtr = { fromLatin1_helper(str, (str && size == -1) ? int(strlen(str)) : size) };
      .              .           .                .          .          .               .          .          .                   return QString(dataPtr);
      .              .           .                .          .          .               .          .          .               }
 26,950 ( 0.01%)   532 ( 0.02%)  2 ( 0.00%)   2,695 ( 0.00%) 0          0          13,475 ( 0.02%) 0          0               static inline QString fromUtf8(const char *str, int size = -1)
      .              .           .                .          .          .               .          .          .               {
 26,950 ( 0.01%)   457 ( 0.02%)  1 ( 0.00%)  13,475 ( 0.01%) 0          0           2,695 ( 0.00%) 0          0                   return fromUtf8_helper(str, (str && size == -1) ? int(strlen(str)) : size);
 16,170 ( 0.00%)   561 ( 0.02%) 73 ( 0.06%)  13,475 ( 0.01%) 0          0               0          0          0               }
      .              .           .                .          .          .               .          .          .               static inline QString fromLocal8Bit(const char *str, int size = -1)
      .              .           .                .          .          .               .          .          .               {
      .              .           .                .          .          .               .          .          .                   return fromLocal8Bit_helper(str, (str && size == -1) ? int(strlen(str)) : size);
      .              .           .                .          .          .               .          .          .               }
      .              .           .                .          .          .               .          .          .               static inline QString fromLatin1(const QByteArray &str)
      .              .           .                .          .          .               .          .          .               { return str.isNull() ? QString() : fromLatin1(str.data(), qstrnlen(str.constData(), str.size())); }
      .              .           .                .          .          .               .          .          .               static inline QString fromUtf8(const QByteArray &str)
      .              .           .                .          .          .               .          .          .               { return str.isNull() ? QString() : fromUtf8(str.data(), qstrnlen(str.constData(), str.size())); }
-- line 715 ----------------------------------------
-- line 827 ----------------------------------------
      .              .           .                .          .          .               .          .          .               QString(char (&)[N]) = delete;
      .              .           .                .          .          .               .          .          .               template <int N>
      .              .           .                .          .          .               .          .          .               inline QString &operator=(const char (&ch)[N])
      .              .           .                .          .          .               .          .          .               { return (*this = fromUtf8(ch, N - 1)); }
      .              .           .                .          .          .               .          .          .               template <int N>
      .              .           .                .          .          .               .          .          .               QString &operator=(char (&)[N]) = delete;
      .              .           .                .          .          .               .          .          .           #endif
      .              .           .                .          .          .               .          .          .           #if !defined(QT_NO_CAST_FROM_ASCII) && !defined(QT_RESTRICTED_CAST_FROM_ASCII)
113,652 ( 0.03%)     4 ( 0.00%)  3 ( 0.00%)       0          0          0          56,826 ( 0.08%) 0          0               inline QT_ASCII_CAST_WARN QString(const char *ch)
246,246 ( 0.06%)   561 ( 0.02%)  1 ( 0.00%)  75,768 ( 0.07%) 0          0          56,826 ( 0.08%) 0          0                   : d(fromAscii_helper(ch, ch ? int(strlen(ch)) : -1))
 56,826 ( 0.01%)     0           0           37,884 ( 0.03%) 0          0               0          0          0               {}
      .              .           .                .          .          .               .          .          .               inline QT_ASCII_CAST_WARN QString(const QByteArray &a)
      .              .           .                .          .          .               .          .          .                   : d(fromAscii_helper(a.constData(), qstrnlen(a.constData(), a.size())))
      .              .           .                .          .          .               .          .          .               {}
      .              .           .                .          .          .               .          .          .               inline QT_ASCII_CAST_WARN QString &operator=(const char *ch)
      .              .           .                .          .          .               .          .          .               { return (*this = fromUtf8(ch)); }
      .              .           .                .          .          .               .          .          .               inline QT_ASCII_CAST_WARN QString &operator=(const QByteArray &a)
      .              .           .                .          .          .               .          .          .               { return (*this = fromUtf8(a)); }
      .              .           .                .          .          .               .          .          .               inline QT_ASCII_CAST_WARN QString &operator=(char c)
-- line 845 ----------------------------------------
-- line 1303 ----------------------------------------
      .              .           .                .          .          .               .          .          .           };
      .              .           .                .          .          .               .          .          .           Q_DECLARE_TYPEINFO(QCharRef, Q_MOVABLE_TYPE);
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .           inline void QCharRef::setRow(uchar arow) { QChar(*this).setRow(arow); }
      .              .           .                .          .          .               .          .          .           inline void QCharRef::setCell(uchar acell) { QChar(*this).setCell(acell); }
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .           inline QString::QString() noexcept : d(Data::sharedNull()) {}
455,924 ( 0.11%)   564 ( 0.02%) 54 ( 0.04%) 143,976 ( 0.13%) 2 ( 0.00%) 0          95,984 ( 0.14%) 0          0           inline QString::~QString() { if (!d->ref.deref()) Data::deallocate(d); }
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .           inline void QString::reserve(int asize)
      .              .           .                .          .          .               .          .          .           {
      .              .           .                .          .          .               .          .          .               if (d->ref.isShared() || uint(asize) >= d->alloc)
      .              .           .                .          .          .               .          .          .                   reallocData(qMax(asize, d->size) + 1u);
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .               if (!d->capacityReserved) {
      .              .           .                .          .          .               .          .          .                   // cannot set unconditionally, since d could be the shared_null/shared_empty (which is const)
-- line 1319 ----------------------------------------
-- line 1545 ----------------------------------------
      .              .           .                .          .          .               .          .          .           inline QT_ASCII_CAST_WARN const QString operator+(const QByteArray &ba, const QString &s)
      .              .           .                .          .          .               .          .          .           { QString t = QString::fromUtf8(ba); t += s; return t; }
      .              .           .                .          .          .               .          .          .           inline QT_ASCII_CAST_WARN const QString operator+(const QString &s, const QByteArray &ba)
      .              .           .                .          .          .               .          .          .           { QString t(s); t += QString::fromUtf8(ba); return t; }
      .              .           .                .          .          .               .          .          .           #  endif // QT_NO_CAST_FROM_ASCII
      .              .           .                .          .          .               .          .          .           #endif // QT_USE_QSTRINGBUILDER
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .           inline std::string QString::toStdString() const
    320 ( 0.00%)    17 ( 0.00%)  6 ( 0.00%)      90 ( 0.00%) 0          0              80 ( 0.00%) 0          0           { return toUtf8().toStdString(); }
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .           inline QString QString::fromStdString(const std::string &s)
 80,850 ( 0.02%) 1,683 ( 0.06%) 32 ( 0.03%)  26,950 ( 0.02%) 0          0          21,560 ( 0.03%) 0          0           { return fromUtf8(s.data(), int(s.size())); }
      .              .           .                .          .          .               .          .          .           
      .              .           .                .          .          .               .          .          .           inline std::wstring QString::toStdWString() const
      .              .           .                .          .          .               .          .          .           {
      .              .           .                .          .          .               .          .          .               std::wstring str;
      .              .           .                .          .          .               .          .          .               str.resize(length());
      .              .           .                .          .          .               .          .          .           #if __cplusplus >= 201703L
      .              .           .                .          .          .               .          .          .               str.resize(toWCharArray(str.data()));
      .              .           .                .          .          .               .          .          .           #else
-- line 1564 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr           DLmr         Dw               D1mw         DLmw        

-- line 89 ----------------------------------------
      .              .            .                .              .            .                .            .           .                  	pointer;
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 struct _Vector_impl_data
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	pointer _M_start;
      .              .            .                .              .            .                .            .           .           	pointer _M_finish;
      .              .            .                .              .            .                .            .           .           	pointer _M_end_of_storage;
      .              .            .                .              .            .                .            .           .           
 91,184 ( 0.02%) 1,141 ( 0.04%)  36 ( 0.03%)       0              0            0           45,592 ( 0.07%)   0           0           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
136,776 ( 0.03%) 1,138 ( 0.04%)  42 ( 0.03%)  68,388 ( 0.06%)     0            0           68,388 ( 0.10%)  17 ( 0.01%)  1 ( 0.00%)  	: _M_start(), _M_finish(), _M_end_of_storage()
 68,388 ( 0.02%)     0            0           45,592 ( 0.04%)     0            0                0            0           0           	{ }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
     15 ( 0.00%)     0            0                0              0            0                9 ( 0.00%)   0           0           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
     24 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)      18 ( 0.00%)     0            0                6 ( 0.00%)   0           0           	: _M_start(__x._M_start), _M_finish(__x._M_finish),
     12 ( 0.00%)     0            0                9 ( 0.00%)     0            0                3 ( 0.00%)   0           0           	  _M_end_of_storage(__x._M_end_of_storage)
     39 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)      27 ( 0.00%)     0            0                9 ( 0.00%)   0           0           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           	void
 58,110 ( 0.01%)     0            0                0              0            0           34,866 ( 0.05%)   0           0           	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .           	{
 46,488 ( 0.01%)     0            0           34,866 ( 0.03%)     0            0           11,622 ( 0.02%)   0           0           	  _M_start = __x._M_start;
 46,488 ( 0.01%)     0            0           34,866 ( 0.03%)     0            0           11,622 ( 0.02%)   0           0           	  _M_finish = __x._M_finish;
 46,488 ( 0.01%)     0            0           34,866 ( 0.03%)     0            0           11,622 ( 0.02%)   0           0           	  _M_end_of_storage = __x._M_end_of_storage;
 34,866 ( 0.01%)     0            0           23,244 ( 0.02%)     0            0                0            0           0           	}
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           	void
 34,866 ( 0.01%)    34 ( 0.00%)   2 ( 0.00%)   3,874 ( 0.00%)     0            0           15,496 ( 0.02%)   0           0           	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .           	{
      .              .            .                .              .            .                .            .           .           	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
      .              .            .                .              .            .                .            .           .           	  // information used by TBAA.
 11,622 ( 0.00%)     0            0                0              0            0            3,874 ( 0.01%)   0           0           	  _Vector_impl_data __tmp;
 19,370 ( 0.00%)     0            0            3,874 ( 0.00%)     0            0            3,874 ( 0.01%)   0           0           	  __tmp._M_copy_data(*this);
 19,370 ( 0.00%)     0            0            7,748 ( 0.01%)     0            0            3,874 ( 0.01%)   0           0           	  _M_copy_data(__x);
 19,370 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)   3,874 ( 0.00%)     0            0            3,874 ( 0.01%)   0           0           	  __x._M_copy_data(__tmp);
 23,244 ( 0.01%)     0            0           15,496 ( 0.01%)     0            0                0            0           0           	}
      .              .            .                .              .            .                .            .           .                 };
      .              .            .                .              .            .                .            .           .           
207,845 ( 0.05%)    66 ( 0.00%)  24 ( 0.02%)  56,685 ( 0.05%)     0            0           56,685 ( 0.08%)   0           0                 struct _Vector_impl
      .              .            .                .              .            .                .            .           .           	: public _Tp_alloc_type, public _Vector_impl_data
      .              .            .                .              .            .                .            .           .                 {
 36,375 ( 0.01%) 1,140 ( 0.04%) 253 ( 0.20%)       0              0            0           14,550 ( 0.02%)   0           0           	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
      .              .            .                .              .            .                .            .           .           	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
 43,650 ( 0.01%)   565 ( 0.02%) 187 ( 0.15%)  14,550 ( 0.01%)     0            0           14,550 ( 0.02%)   0           0           	: _Tp_alloc_type()
 21,825 ( 0.01%)    11 ( 0.00%)   1 ( 0.00%)  14,550 ( 0.01%)     0            0                0            0           0           	{ }
      .              .            .                .              .            .                .            .           .           
 69,882 ( 0.02%)   579 ( 0.02%)  21 ( 0.02%)       0              0            0           34,941 ( 0.05%)   0           0           	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
 93,176 ( 0.02%) 1,122 ( 0.04%) 107 ( 0.08%)  34,941 ( 0.03%)     0            0           23,294 ( 0.03%)   0           0           	: _Tp_alloc_type(__a)
 34,941 ( 0.01%)     0            0           23,294 ( 0.02%)     0            0                0            0           0           	{ }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .              .            .                .            .           .           	// Not defaulted, to enforce noexcept(true) even when
      .              .            .                .              .            .                .            .           .           	// !is_nothrow_move_constructible<_Tp_alloc_type>.
     21 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0              0            0               12 ( 0.00%)   0           0           	_Vector_impl(_Vector_impl&& __x) noexcept
     45 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)      12 ( 0.00%)     0            0               12 ( 0.00%)   0           0           	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
     12 ( 0.00%)     0            0                9 ( 0.00%)     0            0                0            0           0           	{ }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           	_Vector_impl(_Tp_alloc_type&& __a) noexcept
      .              .            .                .              .            .                .            .           .           	: _Tp_alloc_type(std::move(__a))
      .              .            .                .              .            .                .            .           .           	{ }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
      .              .            .                .              .            .                .            .           .           	: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
      .              .            .                .              .            .                .            .           .           	{ }
-- line 153 ----------------------------------------
-- line 268 ----------------------------------------
      .              .            .                .              .            .                .            .           .           #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
      .              .            .                .              .            .                .            .           .           #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
      .              .            .                .              .            .                .            .           .                 };
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .               public:
      .              .            .                .              .            .                .            .           .                 typedef _Alloc allocator_type;
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 _Tp_alloc_type&
236,796 ( 0.05%) 2,307 ( 0.09%) 587 ( 0.46%)       0              0            0          118,398 ( 0.17%)   0           0                 _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
177,597 ( 0.04%)     0            0          177,597 ( 0.16%)     0            0                0            0           0                 { return this->_M_impl; }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 const _Tp_alloc_type&
 68,220 ( 0.02%)   602 ( 0.02%)  45 ( 0.04%)       0              0            0           34,110 ( 0.05%)  95 ( 0.04%) 13 ( 0.02%)        _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
 51,165 ( 0.01%)     0            0           51,165 ( 0.05%)     0            0                0            0           0                 { return this->_M_impl; }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 allocator_type
      .              .            .                .              .            .                .            .           .                 get_allocator() const _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 { return allocator_type(_M_get_Tp_allocator()); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
 80,025 ( 0.02%)   562 ( 0.02%)   9 ( 0.01%)  21,825 ( 0.02%)     0            0           21,825 ( 0.03%)   0           0                 _Vector_base() = default;
      .              .            .                .              .            .                .            .           .           #else
      .              .            .                .              .            .                .            .           .                 _Vector_base() { }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
 23,244 ( 0.01%)   561 ( 0.02%)  26 ( 0.02%)       0              0            0           11,622 ( 0.02%)   0           0                 _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
 30,992 ( 0.01%)     0            0           15,496 ( 0.01%)     0            0            3,874 ( 0.01%)   0           0                 : _M_impl(__a) { }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Kept for ABI compatibility.
      .              .            .                .              .            .                .            .           .           #if !_GLIBCXX_INLINE_VERSION
      .              .            .                .              .            .                .            .           .                 _Vector_base(size_t __n)
      .              .            .                .              .            .                .            .           .                 : _M_impl()
      .              .            .                .              .            .                .            .           .                 { _M_create_storage(__n); }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
 62,184 ( 0.01%)    18 ( 0.00%)  16 ( 0.01%)       0              0            0           38,865 ( 0.06%)   0           0                 _Vector_base(size_t __n, const allocator_type& __a)
 38,865 ( 0.01%)     0            0           15,546 ( 0.01%)     0            0            7,773 ( 0.01%)   0           0                 : _M_impl(__a)
 69,957 ( 0.02%)    44 ( 0.00%)  18 ( 0.01%)  38,865 ( 0.04%)     0            0            7,773 ( 0.01%)   0           0                 { _M_create_storage(__n); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
     42 ( 0.00%)     0            0               12 ( 0.00%)     0            0               12 ( 0.00%)   0           0                 _Vector_base(_Vector_base&&) = default;
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Kept for ABI compatibility.
      .              .            .                .              .            .                .            .           .           # if !_GLIBCXX_INLINE_VERSION
      .              .            .                .              .            .                .            .           .                 _Vector_base(_Tp_alloc_type&& __a) noexcept
      .              .            .                .              .            .                .            .           .                 : _M_impl(std::move(__a)) { }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      .              .            .                .              .            .                .            .           .                 : _M_impl(__a)
-- line 316 ----------------------------------------
-- line 325 ----------------------------------------
      .              .            .                .              .            .                .            .           .                 }
      .              .            .                .              .            .                .            .           .           # endif
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
      .              .            .                .              .            .                .            .           .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
      .              .            .                .              .            .                .            .           .                 { }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
 94,475 ( 0.02%)   593 ( 0.02%) 320 ( 0.25%)       0              0            0           37,790 ( 0.06%)   0           0                 ~_Vector_base() _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 {
132,265 ( 0.03%)     0            0           56,685 ( 0.05%)     0            0           18,895 ( 0.03%)   0           0           	_M_deallocate(_M_impl._M_start,
167,143 ( 0.04%)   569 ( 0.02%)  15 ( 0.01%)  75,580 ( 0.07%)     0            0                0            0           0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
113,370 ( 0.03%)     0            0           56,685 ( 0.05%)     0            0           18,895 ( 0.03%)   0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .               public:
      .              .            .                .              .            .                .            .           .                 _Vector_impl _M_impl;
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 pointer
120,978 ( 0.03%)    62 ( 0.00%)  47 ( 0.04%)       0              0            0           60,489 ( 0.09%)   0           0                 _M_allocate(size_t __n)
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
161,254 ( 0.04%)   562 ( 0.02%) 338 ( 0.26%)  60,469 ( 0.05%)     0            0           20,153 ( 0.03%)   0           0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
 40,326 ( 0.01%)   561 ( 0.02%)  27 ( 0.02%)  40,326 ( 0.04%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 void
218,995 ( 0.05%) 1,156 ( 0.04%)  16 ( 0.01%)       0              0            0          125,140 ( 0.18%)   0           0                 _M_deallocate(pointer __p, size_t __n)
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 62,570 ( 0.01%)     0            0           31,285 ( 0.03%)     0            0                0            0           0           	if (__p)
120,744 ( 0.03%)     0            0           60,372 ( 0.05%)     0            0           20,124 ( 0.03%)   0           0           	  _Tr::deallocate(_M_impl, __p, __n);
 93,855 ( 0.02%)     0            0           62,570 ( 0.06%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .               protected:
      .              .            .                .              .            .                .            .           .                 void
 46,638 ( 0.01%)    19 ( 0.00%)  16 ( 0.01%)       0              0            0           23,319 ( 0.03%)   0           0                 _M_create_storage(size_t __n)
      .              .            .                .              .            .                .            .           .                 {
 54,411 ( 0.01%)   562 ( 0.02%)   9 ( 0.01%)  23,319 ( 0.02%)     0            0           15,546 ( 0.02%)   0           0           	this->_M_impl._M_start = this->_M_allocate(__n);
 31,092 ( 0.01%)   561 ( 0.02%) 323 ( 0.25%)  23,319 ( 0.02%)     0            0            7,773 ( 0.01%)   0           0           	this->_M_impl._M_finish = this->_M_impl._M_start;
 66,042 ( 0.02%)   573 ( 0.02%)   9 ( 0.01%)  31,092 ( 0.03%)     0            0            7,773 ( 0.01%)   0           0           	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 23,319 ( 0.01%)     0            0           15,546 ( 0.01%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .               };
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .             /**
      .              .            .                .              .            .                .            .           .              *  @brief A standard container which offers fixed time access to
      .              .            .                .              .            .                .            .           .              *  individual elements in any order.
      .              .            .                .              .            .                .            .           .              *
      .              .            .                .              .            .                .            .           .              *  @ingroup sequences
      .              .            .                .              .            .                .            .           .              *
-- line 372 ----------------------------------------
-- line 445 ----------------------------------------
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	// Instantiating std::__relocate_a might cause an error outside the
      .              .            .                .              .            .                .            .           .           	// immediate context (in __relocate_object_a's noexcept-specifier),
      .              .            .                .              .            .                .            .           .           	// so only do it if we know the type can be move-inserted into *this.
      .              .            .                .              .            .                .            .           .           	return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
      .              .            .                .              .            .                .            .           .                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 static pointer
136,216 ( 0.03%)   565 ( 0.02%)  24 ( 0.02%)       0              0            0           85,135 ( 0.12%)   0           0                 _S_do_relocate(pointer __first, pointer __last, pointer __result,
      .              .            .                .              .            .                .            .           .           		     _Tp_alloc_type& __alloc, true_type) noexcept
      .              .            .                .              .            .                .            .           .                 {
102,162 ( 0.02%)     3 ( 0.00%)   3 ( 0.00%)  68,108 ( 0.06%)     0            0           17,027 ( 0.02%)   0           0           	return std::__relocate_a(__first, __last, __result, __alloc);
 34,054 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)  34,054 ( 0.03%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 static pointer
      .              .            .                .              .            .                .            .           .                 _S_do_relocate(pointer, pointer, pointer __result,
      .              .            .                .              .            .                .            .           .           		     _Tp_alloc_type&, false_type) noexcept
      .              .            .                .              .            .                .            .           .                 { return __result; }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 static pointer
136,216 ( 0.03%)     3 ( 0.00%)   3 ( 0.00%)       0              0            0           85,135 ( 0.12%)   0           0                 _S_relocate(pointer __first, pointer __last, pointer __result,
      .              .            .                .              .            .                .            .           .           		  _Tp_alloc_type& __alloc) noexcept
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	using __do_it = __bool_constant<_S_use_relocate()>;
102,162 ( 0.02%)     0            0           68,108 ( 0.06%)     0            0           17,027 ( 0.02%)   0           0           	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
 34,054 ( 0.01%)     0            0           34,054 ( 0.03%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           #endif // C++11
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .               protected:
      .              .            .                .              .            .                .            .           .                 using _Base::_M_allocate;
      .              .            .                .              .            .                .            .           .                 using _Base::_M_deallocate;
      .              .            .                .              .            .                .            .           .                 using _Base::_M_impl;
      .              .            .                .              .            .                .            .           .                 using _Base::_M_get_Tp_allocator;
      .              .            .                .              .            .                .            .           .           
-- line 478 ----------------------------------------
-- line 479 ----------------------------------------
      .              .            .                .              .            .                .            .           .               public:
      .              .            .                .              .            .                .            .           .                 // [23.2.4.1] construct/copy/destroy
      .              .            .                .              .            .                .            .           .                 // (assign() and get_allocator() are also listed in this section)
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Creates a %vector with no elements.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
 80,025 ( 0.02%)   579 ( 0.02%)  15 ( 0.01%)  21,825 ( 0.02%)     0            0           21,825 ( 0.03%)   1 ( 0.00%)  0                 vector() = default;
      .              .            .                .              .            .                .            .           .           #else
      .              .            .                .              .            .                .            .           .                 vector() { }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Creates a %vector with no elements.
      .              .            .                .              .            .                .            .           .                  *  @param  __a  An allocator object.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 explicit
 23,244 ( 0.01%)   561 ( 0.02%)   2 ( 0.00%)       0              0            0           11,622 ( 0.02%)   0           0                 vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
 30,992 ( 0.01%)     0            0           15,496 ( 0.01%)     0            0            3,874 ( 0.01%)   0           0                 : _Base(__a) { }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Creates a %vector with default constructed elements.
      .              .            .                .              .            .                .            .           .                  *  @param  __n  The number of elements to initially create.
      .              .            .                .              .            .                .            .           .                  *  @param  __a  An allocator.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This constructor fills the %vector with @a __n default
      .              .            .                .              .            .                .            .           .                  *  constructed elements.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 explicit
 30,992 ( 0.01%)   561 ( 0.02%)   9 ( 0.01%)       0              0            0           19,370 ( 0.03%)   0           0                 vector(size_type __n, const allocator_type& __a = allocator_type())
 46,488 ( 0.01%)     0            0           15,496 ( 0.01%)     0            0            7,748 ( 0.01%)   0           0                 : _Base(_S_check_init_len(__n, __a), __a)
 34,866 ( 0.01%)   561 ( 0.02%)   1 ( 0.00%)  19,370 ( 0.02%)     0            0            3,874 ( 0.01%)   0           0                 { _M_default_initialize(__n); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Creates a %vector with copies of an exemplar element.
      .              .            .                .              .            .                .            .           .                  *  @param  __n  The number of elements to initially create.
      .              .            .                .              .            .                .            .           .                  *  @param  __value  An element to copy.
      .              .            .                .              .            .                .            .           .                  *  @param  __a  An allocator.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This constructor fills the %vector with @a __n copies of @a __value.
      .              .            .                .              .            .                .            .           .                  */
 34,866 ( 0.01%)     0            0                0              0            0           23,244 ( 0.03%)   0           0                 vector(size_type __n, const value_type& __value,
      .              .            .                .              .            .                .            .           .           	     const allocator_type& __a = allocator_type())
 46,488 ( 0.01%)   555 ( 0.02%)   1 ( 0.00%)  15,496 ( 0.01%)     0            0            7,748 ( 0.01%)   0           0                 : _Base(_S_check_init_len(__n, __a), __a)
 38,740 ( 0.01%)    14 ( 0.00%)   2 ( 0.00%)  23,244 ( 0.02%)     0            0            3,874 ( 0.01%)   0           0                 { _M_fill_initialize(__n, __value); }
      .              .            .                .              .            .                .            .           .           #else
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Creates a %vector with copies of an exemplar element.
      .              .            .                .              .            .                .            .           .                  *  @param  __n  The number of elements to initially create.
      .              .            .                .              .            .                .            .           .                  *  @param  __value  An element to copy.
      .              .            .                .              .            .                .            .           .                  *  @param  __a  An allocator.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 533 ----------------------------------------
-- line 545 ----------------------------------------
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  All the elements of @a __x are copied, but any unused capacity in
      .              .            .                .              .            .                .            .           .                  *  @a __x  will not be copied
      .              .            .                .              .            .                .            .           .                  *  (i.e. capacity() == size() in the new %vector).
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  The newly-created %vector uses a copy of the allocator object used
      .              .            .                .              .            .                .            .           .                  *  by @a __x (unless the allocator traits dictate a different object).
      .              .            .                .              .            .                .            .           .                  */
    300 ( 0.00%)    35 ( 0.00%)  34 ( 0.03%)      25 ( 0.00%)     0            0              175 ( 0.00%)   0           0                 vector(const vector& __x)
      .              .            .                .              .            .                .            .           .                 : _Base(__x.size(),
    525 ( 0.00%)    22 ( 0.00%)  21 ( 0.02%)      75 ( 0.00%)     0            0              125 ( 0.00%)   0           0           	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      .              .            .                .              .            .                .            .           .                 {
     50 ( 0.00%)     0            0               25 ( 0.00%)     0            0               25 ( 0.00%)   0           0           	this->_M_impl._M_finish =
    350 ( 0.00%)    19 ( 0.00%)  18 ( 0.01%)     100 ( 0.00%)     0            0               75 ( 0.00%)   0           0           	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
      .              .            .                .              .            .                .            .           .           				      this->_M_impl._M_start,
    100 ( 0.00%)     0            0               25 ( 0.00%)     0            0               25 ( 0.00%)   0           0           				      _M_get_Tp_allocator());
    250 ( 0.00%)    11 ( 0.00%)  10 ( 0.01%)     175 ( 0.00%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  %Vector move constructor.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  The newly-created %vector contains the exact contents of the
      .              .            .                .              .            .                .            .           .                  *  moved instance.
      .              .            .                .              .            .                .            .           .                  *  The contents of the moved instance are a valid, but unspecified
      .              .            .                .              .            .                .            .           .                  *  %vector.
      .              .            .                .              .            .                .            .           .                  */
     42 ( 0.00%)     0            0               12 ( 0.00%)     0            0               12 ( 0.00%)   0           0                 vector(vector&&) noexcept = default;
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /// Copy constructor with alternative allocator
      .              .            .                .              .            .                .            .           .                 vector(const vector& __x, const allocator_type& __a)
      .              .            .                .              .            .                .            .           .                 : _Base(__x.size(), __a)
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	this->_M_impl._M_finish =
      .              .            .                .              .            .                .            .           .           	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
      .              .            .                .              .            .                .            .           .           				      this->_M_impl._M_start,
-- line 580 ----------------------------------------
-- line 670 ----------------------------------------
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  The dtor only erases the elements, and note that if the
      .              .            .                .              .            .                .            .           .                  *  elements themselves are pointers, the pointed-to memory is
      .              .            .                .              .            .                .            .           .                  *  not touched in any way.  Managing the pointer is the user's
      .              .            .                .              .            .                .            .           .                  *  responsibility.
      .              .            .                .              .            .                .            .           .                  */
 94,475 ( 0.02%) 1,130 ( 0.04%)  70 ( 0.05%)       0              0            0           37,790 ( 0.06%)   0           0                 ~vector() _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 {
132,265 ( 0.03%) 1,109 ( 0.04%) 561 ( 0.44%)  75,580 ( 0.07%)    40 ( 0.01%)   0           18,895 ( 0.03%)   0           0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
 75,580 ( 0.02%)     0            0           18,895 ( 0.02%)     0            0           18,895 ( 0.03%)   0           0           		      _M_get_Tp_allocator());
      .              .            .                .              .            .                .            .           .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
113,370 ( 0.03%)    17 ( 0.00%)  13 ( 0.01%)  56,685 ( 0.05%)     0            0           18,895 ( 0.03%)   0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  %Vector assignment operator.
      .              .            .                .              .            .                .            .           .                  *  @param  __x  A %vector of identical element and allocator types.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  All the elements of @a __x are copied, but any unused capacity in
      .              .            .                .              .            .                .            .           .                  *  @a __x will not be copied.
      .              .            .                .              .            .                .            .           .                  *
-- line 691 ----------------------------------------
-- line 741 ----------------------------------------
      .              .            .                .              .            .                .            .           .                  *  @param  __val  Value to be assigned.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This function fills a %vector with @a __n copies of the given
      .              .            .                .              .            .                .            .           .                  *  value.  Note that the assignment completely changes the
      .              .            .                .              .            .                .            .           .                  *  %vector and that the resulting %vector's size is the same as
      .              .            .                .              .            .                .            .           .                  *  the number of elements assigned.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 void
 50,309 ( 0.01%)   561 ( 0.02%)  14 ( 0.01%)       0              0            0           28,748 ( 0.04%)   0           0                 assign(size_type __n, const value_type& __val)
 64,683 ( 0.01%)     0            0           35,935 ( 0.03%)     0            0            7,187 ( 0.01%)   0           0                 { _M_fill_assign(__n, __val); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Assigns a range to a %vector.
      .              .            .                .              .            .                .            .           .                  *  @param  __first  An input iterator.
      .              .            .                .              .            .                .            .           .                  *  @param  __last   An input iterator.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This function fills a %vector with copies of the elements in the
      .              .            .                .              .            .                .            .           .                  *  range [__first,__last).
-- line 758 ----------------------------------------
-- line 803 ----------------------------------------
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // iterators
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns a read/write iterator that points to the first
      .              .            .                .              .            .                .            .           .                  *  element in the %vector.  Iteration is done in ordinary
      .              .            .                .              .            .                .            .           .                  *  element order.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 iterator
 77,496 ( 0.02%)    50 ( 0.00%)  21 ( 0.02%)   9,687 ( 0.01%)     0            0           29,061 ( 0.04%)   0           0                 begin() _GLIBCXX_NOEXCEPT
106,557 ( 0.02%)   566 ( 0.02%)  97 ( 0.08%)  58,122 ( 0.05%)     0            0            9,687 ( 0.01%)   0           0                 { return iterator(this->_M_impl._M_start); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns a read-only (constant) iterator that points to the
      .              .            .                .              .            .                .            .           .                  *  first element in the %vector.  Iteration is done in ordinary
      .              .            .                .              .            .                .            .           .                  *  element order.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 const_iterator
 40,240 ( 0.01%)   588 ( 0.02%) 160 ( 0.13%)   5,030 ( 0.00%)     0            0           15,090 ( 0.02%)   0           0                 begin() const _GLIBCXX_NOEXCEPT
 55,330 ( 0.01%)   561 ( 0.02%) 195 ( 0.15%)  30,180 ( 0.03%)     0            0            5,030 ( 0.01%)   0           0                 { return const_iterator(this->_M_impl._M_start); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns a read/write iterator that points one past the last
      .              .            .                .              .            .                .            .           .                  *  element in the %vector.  Iteration is done in ordinary
      .              .            .                .              .            .                .            .           .                  *  element order.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 iterator
150,912 ( 0.03%) 2,329 ( 0.09%) 595 ( 0.47%)  18,864 ( 0.02%)     0            0           56,592 ( 0.08%)   6 ( 0.00%)  0                 end() _GLIBCXX_NOEXCEPT
226,368 ( 0.05%)    34 ( 0.00%)  22 ( 0.02%) 113,184 ( 0.10%)     0            0           18,864 ( 0.03%)   0           0                 { return iterator(this->_M_impl._M_finish); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns a read-only (constant) iterator that points one past
      .              .            .                .              .            .                .            .           .                  *  the last element in the %vector.  Iteration is done in
      .              .            .                .              .            .                .            .           .                  *  ordinary element order.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 const_iterator
 40,240 ( 0.01%)   589 ( 0.02%) 244 ( 0.19%)   5,030 ( 0.00%)     0            0           15,090 ( 0.02%)   0           0                 end() const _GLIBCXX_NOEXCEPT
 60,360 ( 0.01%)   867 ( 0.03%) 235 ( 0.18%)  30,180 ( 0.03%)     0            0            5,030 ( 0.01%)   0           0                 { return const_iterator(this->_M_impl._M_finish); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns a read/write reverse iterator that points to the
      .              .            .                .              .            .                .            .           .                  *  last element in the %vector.  Iteration is done in reverse
      .              .            .                .              .            .                .            .           .                  *  element order.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 reverse_iterator
      .              .            .                .              .            .                .            .           .                 rbegin() _GLIBCXX_NOEXCEPT
-- line 847 ----------------------------------------
-- line 876 ----------------------------------------
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns a read-only (constant) iterator that points to the
      .              .            .                .              .            .                .            .           .                  *  first element in the %vector.  Iteration is done in ordinary
      .              .            .                .              .            .                .            .           .                  *  element order.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 const_iterator
     96 ( 0.00%)    16 ( 0.00%)  16 ( 0.01%)      12 ( 0.00%)     0            0               36 ( 0.00%)   0           0                 cbegin() const noexcept
    132 ( 0.00%)     0            0               72 ( 0.00%)     0            0               12 ( 0.00%)   0           0                 { return const_iterator(this->_M_impl._M_start); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns a read-only (constant) iterator that points one past
      .              .            .                .              .            .                .            .           .                  *  the last element in the %vector.  Iteration is done in
      .              .            .                .              .            .                .            .           .                  *  ordinary element order.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 const_iterator
      .              .            .                .              .            .                .            .           .                 cend() const noexcept
-- line 893 ----------------------------------------
-- line 910 ----------------------------------------
      .              .            .                .              .            .                .            .           .                 const_reverse_iterator
      .              .            .                .              .            .                .            .           .                 crend() const noexcept
      .              .            .                .              .            .                .            .           .                 { return const_reverse_iterator(begin()); }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // [23.2.4.2] capacity
      .              .            .                .              .            .                .            .           .                 /**  Returns the number of elements in the %vector.  */
      .              .            .                .              .            .                .            .           .                 size_type
414,704 ( 0.10%) 3,813 ( 0.14%)  48 ( 0.04%)       0              0            0          207,352 ( 0.30%) 158 ( 0.06%) 96 ( 0.12%)        size() const _GLIBCXX_NOEXCEPT
994,866 ( 0.23%) 1,738 ( 0.06%)  74 ( 0.06%) 622,056 ( 0.56%) 1,026 ( 0.22%) 121 ( 0.12%)       0            0           0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**  Returns the size() of the largest possible %vector.  */
      .              .            .                .              .            .                .            .           .                 size_type
 85,150 ( 0.02%)   576 ( 0.02%)  15 ( 0.01%)       0              0            0           34,060 ( 0.05%)   0           0                 max_size() const _GLIBCXX_NOEXCEPT
119,210 ( 0.03%)   576 ( 0.02%)  73 ( 0.06%)  51,090 ( 0.05%)     0            0           34,060 ( 0.05%)   0           0                 { return _S_max_size(_M_get_Tp_allocator()); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Resizes the %vector to the specified number of elements.
      .              .            .                .              .            .                .            .           .                  *  @param  __new_size  Number of elements the %vector should contain.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This function will %resize the %vector to the specified
      .              .            .                .              .            .                .            .           .                  *  number of elements.  If the number is smaller than the
      .              .            .                .              .            .                .            .           .                  *  %vector's current size the %vector is truncated, otherwise
      .              .            .                .              .            .                .            .           .                  *  default constructed elements are appended.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 void
      6 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0              0            0                3 ( 0.00%)   0           0                 resize(size_type __new_size)
      .              .            .                .              .            .                .            .           .                 {
      7 ( 0.00%)     0            0                2 ( 0.00%)     0            0                1 ( 0.00%)   0           0           	if (__new_size > size())
     11 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       3 ( 0.00%)     0            0                2 ( 0.00%)   0           0           	  _M_default_append(__new_size - size());
      .              .            .                .              .            .                .            .           .           	else if (__new_size < size())
      .              .            .                .              .            .                .            .           .           	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
      4 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       2 ( 0.00%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Resizes the %vector to the specified number of elements.
      .              .            .                .              .            .                .            .           .                  *  @param  __new_size  Number of elements the %vector should contain.
      .              .            .                .              .            .                .            .           .                  *  @param  __x  Data with which new elements should be populated.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This function will %resize the %vector to the specified
      .              .            .                .              .            .                .            .           .                  *  number of elements.  If the number is smaller than the
-- line 951 ----------------------------------------
-- line 990 ----------------------------------------
      .              .            .                .              .            .                .            .           .                 { _M_shrink_to_fit(); }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns the total number of elements that the %vector can
      .              .            .                .              .            .                .            .           .                  *  hold before needing to allocate more memory.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 size_type
 46,508 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)       0              0            0           23,254 ( 0.03%)   0           0                 capacity() const _GLIBCXX_NOEXCEPT
 23,254 ( 0.01%)     0            0           23,254 ( 0.02%)     7 ( 0.00%)   1 ( 0.00%)       0            0           0                 { return size_type(this->_M_impl._M_end_of_storage
116,258 ( 0.03%)   561 ( 0.02%)   8 ( 0.01%)  46,508 ( 0.04%)     0            0                0            0           0           			 - this->_M_impl._M_start); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns true if the %vector is empty.  (Thus begin() would
      .              .            .                .              .            .                .            .           .                  *  equal end().)
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 _GLIBCXX_NODISCARD bool
     32 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       4 ( 0.00%)     0            0               12 ( 0.00%)   0           0                 empty() const _GLIBCXX_NOEXCEPT
     72 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      24 ( 0.00%)     0            0               20 ( 0.00%)   0           0                 { return begin() == end(); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Attempt to preallocate enough memory for specified number of
      .              .            .                .              .            .                .            .           .                  *          elements.
      .              .            .                .              .            .                .            .           .                  *  @param  __n  Number of elements required.
      .              .            .                .              .            .                .            .           .                  *  @throw  std::length_error  If @a n exceeds @c max_size().
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This function attempts to reserve enough memory for the
-- line 1016 ----------------------------------------
-- line 1035 ----------------------------------------
      .              .            .                .              .            .                .            .           .                  *  @return  Read/write reference to data.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This operator allows for easy, array-style, data access.
      .              .            .                .              .            .                .            .           .                  *  Note that data access with this operator is unchecked and
      .              .            .                .              .            .                .            .           .                  *  out_of_range lookups are not defined. (For checked lookups
      .              .            .                .              .            .                .            .           .                  *  see at().)
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 reference
315,575 ( 0.07%) 1,729 ( 0.06%) 373 ( 0.29%)       0              0            0          189,345 ( 0.28%)   0           0                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	__glibcxx_requires_subscript(__n);
345,872 ( 0.08%) 1,120 ( 0.04%)  13 ( 0.01%) 189,345 ( 0.17%)     4 ( 0.00%)   0                0            0           0           	return *(this->_M_impl._M_start + __n);
126,230 ( 0.03%)     0            0          126,230 ( 0.11%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Subscript access to the data contained in the %vector.
      .              .            .                .              .            .                .            .           .                  *  @param __n The index of the element for which data should be
      .              .            .                .              .            .                .            .           .                  *  accessed.
      .              .            .                .              .            .                .            .           .                  *  @return  Read-only (constant) reference to data.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This operator allows for easy, array-style, data access.
      .              .            .                .              .            .                .            .           .                  *  Note that data access with this operator is unchecked and
      .              .            .                .              .            .                .            .           .                  *  out_of_range lookups are not defined. (For checked lookups
      .              .            .                .              .            .                .            .           .                  *  see at().)
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 const_reference
173,070 ( 0.04%)   547 ( 0.02%)   1 ( 0.00%)       0              0            0          103,842 ( 0.15%)   0           0                 operator[](size_type __n) const _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	__glibcxx_requires_subscript(__n);
276,912 ( 0.06%)     0            0          103,842 ( 0.09%)     6 ( 0.00%)   0                0            0           0           	return *(this->_M_impl._M_start + __n);
 69,228 ( 0.02%)     0            0           69,228 ( 0.06%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .               protected:
      .              .            .                .              .            .                .            .           .                 /// Safety check used only from at().
      .              .            .                .              .            .                .            .           .                 void
      .              .            .                .              .            .                .            .           .                 _M_range_check(size_type __n) const
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	if (__n >= this->size())
      .              .            .                .              .            .                .            .           .           	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
-- line 1073 ----------------------------------------
-- line 1135 ----------------------------------------
      .              .            .                .              .            .                .            .           .           	return *begin();
      .              .            .                .              .            .                .            .           .                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns a read/write reference to the data at the last
      .              .            .                .              .            .                .            .           .                  *  element of the %vector.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 reference
 73,424 ( 0.02%)    18 ( 0.00%)   8 ( 0.01%)   9,178 ( 0.01%)     0            0           27,534 ( 0.04%)   0           0                 back() _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	__glibcxx_requires_nonempty();
110,136 ( 0.03%)   567 ( 0.02%)   9 ( 0.01%)   9,178 ( 0.01%)     0            0           45,890 ( 0.07%)   0           0           	return *(end() - 1);
 45,890 ( 0.01%)    12 ( 0.00%)   2 ( 0.00%)  36,712 ( 0.03%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Returns a read-only (constant) reference to the data at the
      .              .            .                .              .            .                .            .           .                  *  last element of the %vector.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 const_reference
      .              .            .                .              .            .                .            .           .                 back() const _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 {
-- line 1155 ----------------------------------------
-- line 1179 ----------------------------------------
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This is a typical stack operation.  The function creates an
      .              .            .                .              .            .                .            .           .                  *  element at the end of the %vector and assigns the given data
      .              .            .                .              .            .                .            .           .                  *  to it.  Due to the nature of a %vector this operation can be
      .              .            .                .              .            .                .            .           .                  *  done in constant time if the %vector has preallocated space
      .              .            .                .              .            .                .            .           .                  *  available.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 void
  3,630 ( 0.00%)    10 ( 0.00%)   5 ( 0.00%)       0              0            0            1,815 ( 0.00%)   0           0                 push_back(const value_type& __x)
      .              .            .                .              .            .                .            .           .                 {
  3,630 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)   2,420 ( 0.00%)     0            0                0            0           0           	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      .              .            .                .              .            .                .            .           .           	  {
      .              .            .                .              .            .                .            .           .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
  3,976 ( 0.00%)   452 ( 0.02%) 100 ( 0.08%)   2,272 ( 0.00%)     0            0              568 ( 0.00%)   0           0           	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
      .              .            .                .              .            .                .            .           .           				     __x);
  2,840 ( 0.00%)     0            0            1,704 ( 0.00%)     0            0              568 ( 0.00%)   0           0           	    ++this->_M_impl._M_finish;
      .              .            .                .              .            .                .            .           .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
      .              .            .                .              .            .                .            .           .           	  }
      .              .            .                .              .            .                .            .           .           	else
    333 ( 0.00%)    16 ( 0.00%)   9 ( 0.01%)     111 ( 0.00%)     0            0               74 ( 0.00%)   0           0           	  _M_realloc_insert(end(), __x);
  2,383 ( 0.00%)     4 ( 0.00%)   1 ( 0.00%)   1,210 ( 0.00%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .              .            .                .            .           .                 void
 54,756 ( 0.01%)   575 ( 0.02%)   9 ( 0.01%)       0              0            0           27,378 ( 0.04%)   0           0                 push_back(value_type&& __x)
100,386 ( 0.02%)     0            0           36,504 ( 0.03%)     0            0           18,252 ( 0.03%)   0           0                 { emplace_back(std::move(__x)); }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 template<typename... _Args>
      .              .            .                .              .            .                .            .           .           #if __cplusplus > 201402L
      .              .            .                .              .            .                .            .           .           	reference
      .              .            .                .              .            .                .            .           .           #else
      .              .            .                .              .            .                .            .           .           	void
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           	emplace_back(_Args&&... __args);
-- line 1212 ----------------------------------------
-- line 1217 ----------------------------------------
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  This is a typical stack operation. It shrinks the %vector by one.
      .              .            .                .              .            .                .            .           .                  *
      .              .            .                .              .            .                .            .           .                  *  Note that no data is returned, and if the last element's
      .              .            .                .              .            .                .            .           .                  *  data is needed, it should be retrieved before pop_back() is
      .              .            .                .              .            .                .            .           .                  *  called.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 void
    205 ( 0.00%)     0            0                0              0            0               82 ( 0.00%)   0           0                 pop_back() _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	__glibcxx_requires_nonempty();
    205 ( 0.00%)     5 ( 0.00%)   5 ( 0.00%)     123 ( 0.00%)     0            0               41 ( 0.00%)   0           0           	--this->_M_impl._M_finish;
    246 ( 0.00%)     0            0              123 ( 0.00%)     0            0               41 ( 0.00%)   0           0           	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      .              .            .                .              .            .                .            .           .           	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
    123 ( 0.00%)     0            0               82 ( 0.00%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Inserts an object in %vector before specified iterator.
      .              .            .                .              .            .                .            .           .                  *  @param  __position  A const_iterator into the %vector.
      .              .            .                .              .            .                .            .           .                  *  @param  __args  Arguments.
      .              .            .                .              .            .                .            .           .                  *  @return  An iterator that points to the inserted data.
      .              .            .                .              .            .                .            .           .                  *
-- line 1239 ----------------------------------------
-- line 1422 ----------------------------------------
      .              .            .                .              .            .                .            .           .                  *  frequently used the user should consider using std::list.
      .              .            .                .              .            .                .            .           .                  *  The user is also cautioned that this function only erases
      .              .            .                .              .            .                .            .           .                  *  the element, and that if the element is itself a pointer,
      .              .            .                .              .            .                .            .           .                  *  the pointed-to memory is not touched in any way.  Managing
      .              .            .                .              .            .                .            .           .                  *  the pointer is the user's responsibility.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 iterator
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
    120 ( 0.00%)     0            0               12 ( 0.00%)     0            0               60 ( 0.00%)   0           0                 erase(const_iterator __position)
    348 ( 0.00%)    13 ( 0.00%)  11 ( 0.01%)      96 ( 0.00%)     0            0               84 ( 0.00%)   0           0                 { return _M_erase(begin() + (__position - cbegin())); }
      .              .            .                .              .            .                .            .           .           #else
      .              .            .                .              .            .                .            .           .                 erase(iterator __position)
      .              .            .                .              .            .                .            .           .                 { return _M_erase(__position); }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  @brief  Remove a range of elements.
      .              .            .                .              .            .                .            .           .                  *  @param  __first  Iterator pointing to the first element to be erased.
-- line 1439 ----------------------------------------
-- line 1500 ----------------------------------------
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .               protected:
      .              .            .                .              .            .                .            .           .                 /**
      .              .            .                .              .            .                .            .           .                  *  Memory expansion handler.  Uses the member allocation function to
      .              .            .                .              .            .                .            .           .                  *  obtain @a n bytes of memory, and then copies [first,last) into it.
      .              .            .                .              .            .                .            .           .                  */
      .              .            .                .              .            .                .            .           .                 template<typename _ForwardIterator>
      .              .            .                .              .            .                .            .           .           	pointer
 34,884 ( 0.01%)     0            0                0              0            0           23,256 ( 0.03%)   0           0           	_M_allocate_and_copy(size_type __n,
      .              .            .                .              .            .                .            .           .           			     _ForwardIterator __first, _ForwardIterator __last)
      .              .            .                .              .            .                .            .           .           	{
 23,256 ( 0.01%)   562 ( 0.02%) 150 ( 0.12%)   7,752 ( 0.01%)     0            0            7,752 ( 0.01%)   0           0           	  pointer __result = this->_M_allocate(__n);
      .              .            .                .              .            .                .            .           .           	  __try
      .              .            .                .              .            .                .            .           .           	    {
 19,380 ( 0.00%)     0            0           11,628 ( 0.01%)     0            0            3,876 ( 0.01%)   0           0           	      std::__uninitialized_copy_a(__first, __last, __result,
 15,504 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)   3,876 ( 0.00%)     0            0            3,876 ( 0.01%)   0           0           					  _M_get_Tp_allocator());
  7,752 ( 0.00%)     0            0            3,876 ( 0.00%)     0            0                0            0           0           	      return __result;
      .              .            .                .              .            .                .            .           .           	    }
      .              .            .                .              .            .                .            .           .           	  __catch(...)
      .              .            .                .              .            .                .            .           .           	    {
      .              .            .                .              .            .                .            .           .           	      _M_deallocate(__result, __n);
      .              .            .                .              .            .                .            .           .           	      __throw_exception_again;
      .              .            .                .              .            .                .            .           .           	    }
 11,628 ( 0.00%)   562 ( 0.02%) 149 ( 0.12%)  11,628 ( 0.01%)     0            0                0            0           0           	}
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Internal constructor functions follow.
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Called by the range constructor to implement [23.1.1]/9
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus < 201103L
      .              .            .                .              .            .                .            .           .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1531 ----------------------------------------
-- line 1585 ----------------------------------------
      .              .            .                .              .            .                .            .           .           	    std::__uninitialized_copy_a(__first, __last,
      .              .            .                .              .            .                .            .           .           					this->_M_impl._M_start,
      .              .            .                .              .            .                .            .           .           					_M_get_Tp_allocator());
      .              .            .                .              .            .                .            .           .           	}
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Called by the first initialize_dispatch above and by the
      .              .            .                .              .            .                .            .           .                 // vector(n,value,a) constructor.
      .              .            .                .              .            .                .            .           .                 void
 27,118 ( 0.01%)     8 ( 0.00%)   7 ( 0.01%)       0              0            0           15,496 ( 0.02%)   0           0                 _M_fill_initialize(size_type __n, const value_type& __value)
      .              .            .                .              .            .                .            .           .                 {
  7,748 ( 0.00%)     0            0            3,874 ( 0.00%)     0            0            3,874 ( 0.01%)   0           0           	this->_M_impl._M_finish =
 23,244 ( 0.01%)     0            0           15,496 ( 0.01%)     0            0            3,874 ( 0.01%)   0           0           	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
 15,496 ( 0.00%)     0            0            3,874 ( 0.00%)     0            0            3,874 ( 0.01%)   0           0           					_M_get_Tp_allocator());
 11,622 ( 0.00%)    23 ( 0.00%)  21 ( 0.02%)   7,748 ( 0.01%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
      .              .            .                .              .            .                .            .           .                 // Called by the vector(n) constructor.
      .              .            .                .              .            .                .            .           .                 void
 23,244 ( 0.01%)   561 ( 0.02%)  14 ( 0.01%)       0              0            0           11,622 ( 0.02%)   0           0                 _M_default_initialize(size_type __n)
      .              .            .                .              .            .                .            .           .                 {
  7,748 ( 0.00%)     0            0            3,874 ( 0.00%)     0            0            3,874 ( 0.01%)   0           0           	this->_M_impl._M_finish =
 23,244 ( 0.01%)     0            0           11,622 ( 0.01%)     0            0            3,874 ( 0.01%)   0           0           	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
 15,496 ( 0.00%)     0            0            3,874 ( 0.00%)     0            0            3,874 ( 0.01%)   0           0           					   _M_get_Tp_allocator());
 11,622 ( 0.00%)     0            0            7,748 ( 0.01%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Internal assign functions follow.  The *_aux functions do the actual
      .              .            .                .              .            .                .            .           .                 // assignment work for the range versions.
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Called by the range assign to implement [23.1.1]/9
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1616 ----------------------------------------
-- line 1748 ----------------------------------------
      .              .            .                .              .            .                .            .           .                 // Emplacing an rvalue of the correct type can use _M_insert_rval.
      .              .            .                .              .            .                .            .           .                 iterator
      .              .            .                .              .            .                .            .           .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
      .              .            .                .              .            .                .            .           .                 { return _M_insert_rval(__position, std::move(__v)); }
      .              .            .                .              .            .                .            .           .           #endif
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Called by _M_fill_insert, _M_insert_aux etc.
      .              .            .                .              .            .                .            .           .                 size_type
 93,654 ( 0.02%)   573 ( 0.02%)  28 ( 0.02%)   8,514 ( 0.01%)     0            0           51,084 ( 0.07%)   2 ( 0.00%)  0                 _M_check_len(size_type __n, const char* __s) const
      .              .            .                .              .            .                .            .           .                 {
119,196 ( 0.03%)    26 ( 0.00%)   8 ( 0.01%)  25,542 ( 0.02%)     0            0           17,028 ( 0.02%)   0           0           	if (max_size() - size() < __n)
      .              .            .                .              .            .                .            .           .           	  __throw_length_error(__N(__s));
      .              .            .                .              .            .                .            .           .           
136,224 ( 0.03%) 1,146 ( 0.04%) 122 ( 0.10%)  25,542 ( 0.02%)     0            0           42,570 ( 0.06%)   0           0           	const size_type __len = size() + (std::max)(size(), __n);
 93,654 ( 0.02%)    18 ( 0.00%)   7 ( 0.01%)  42,570 ( 0.04%)     0            0           17,028 ( 0.02%)   0           0           	return (__len < size() || __len > max_size()) ? max_size() : __len;
 51,084 ( 0.01%)   565 ( 0.02%)  17 ( 0.01%)  42,570 ( 0.04%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Called by constructors to check initial size.
      .              .            .                .              .            .                .            .           .                 static size_type
 77,480 ( 0.02%)   561 ( 0.02%)  13 ( 0.01%)   7,748 ( 0.01%)     0            0           38,740 ( 0.06%)   0           0                 _S_check_init_len(size_type __n, const allocator_type& __a)
      .              .            .                .              .            .                .            .           .                 {
116,220 ( 0.03%)     7 ( 0.00%)   6 ( 0.00%)  15,496 ( 0.01%)     0            0           23,244 ( 0.03%)   0           0           	if (__n > _S_max_size(_Tp_alloc_type(__a)))
      .              .            .                .              .            .                .            .           .           	  __throw_length_error(
      .              .            .                .              .            .                .            .           .           	      __N("cannot create std::vector larger than max_size()"));
  7,748 ( 0.00%)     0            0            7,748 ( 0.01%)     0            0                0            0           0           	return __n;
 46,488 ( 0.01%)   298 ( 0.01%)  24 ( 0.02%)  38,740 ( 0.04%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 static size_type
198,224 ( 0.05%) 1,152 ( 0.04%)  19 ( 0.01%)  24,778 ( 0.02%)     0            0           74,334 ( 0.11%)   0           0                 _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 {
      .              .            .                .              .            .                .            .           .           	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
      .              .            .                .              .            .                .            .           .           	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
      .              .            .                .              .            .                .            .           .           	// (even if std::allocator_traits::max_size says we can).
 49,556 ( 0.01%)   574 ( 0.02%)  17 ( 0.01%)       0              0            0           24,778 ( 0.04%)   0           0           	const size_t __diffmax
      .              .            .                .              .            .                .            .           .           	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
 99,112 ( 0.02%)     3 ( 0.00%)   2 ( 0.00%)  24,778 ( 0.02%)     0            0           49,556 ( 0.07%)   0           0           	const size_t __allocmax = _Alloc_traits::max_size(__a);
148,668 ( 0.03%)   561 ( 0.02%)   1 ( 0.00%)  24,778 ( 0.02%)     0            0           24,778 ( 0.04%)   0           0           	return (std::min)(__diffmax, __allocmax);
123,890 ( 0.03%)     0            0           99,112 ( 0.09%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Internal erase functions follow.
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
      .              .            .                .              .            .                .            .           .                 // _M_assign_aux.
      .              .            .                .              .            .                .            .           .                 void
 19,878 ( 0.00%)     0            0                0              0            0            9,939 ( 0.01%)   0           0                 _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
      .              .            .                .              .            .                .            .           .                 {
 33,130 ( 0.01%)     0            0           13,252 ( 0.01%)     0            0            3,313 ( 0.00%)   0           0           	if (size_type __n = this->_M_impl._M_finish - __pos)
      .              .            .                .              .            .                .            .           .           	  {
 19,878 ( 0.00%)     0            0            9,939 ( 0.01%)     0            0            3,313 ( 0.00%)   0           0           	    std::_Destroy(__pos, this->_M_impl._M_finish,
 13,252 ( 0.00%)     0            0            3,313 ( 0.00%)     0            0            3,313 ( 0.00%)   0           0           			  _M_get_Tp_allocator());
  9,939 ( 0.00%)     0            0            6,626 ( 0.01%)     0            0            3,313 ( 0.00%)   0           0           	    this->_M_impl._M_finish = __pos;
      .              .            .                .              .            .                .            .           .           	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
      .              .            .                .              .            .                .            .           .           	  }
  9,939 ( 0.00%)     0            0            6,626 ( 0.01%)     0            0                0            0           0                 }
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 iterator
      .              .            .                .              .            .                .            .           .                 _M_erase(iterator __position);
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .                 iterator
      .              .            .                .              .            .                .            .           .                 _M_erase(iterator __first, iterator __last);
      .              .            .                .              .            .                .            .           .           
      .              .            .                .              .            .                .            .           .           #if __cplusplus >= 201103L
-- line 1809 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/andrijanabos/Desktop/02-moxit-mock-dixit/backend/src/lib/game/player.cpp
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr              D1mr           DLmr         Dw              D1mw       DLmw       

      .              .            .               .              .            .               .          .          .           #include "player.hpp"
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           #include <QJsonArray>
      .              .            .               .              .            .               .          .          .           
     51 ( 0.00%)     6 ( 0.00%)   5 ( 0.00%)      6 ( 0.00%)     0            0              27 ( 0.00%) 0          0           Player::Player(std::string userName, int id, int points, std::vector<int> hand){
     15 ( 0.00%)     3 ( 0.00%)   2 ( 0.00%)      6 ( 0.00%)     0            0               3 ( 0.00%) 0          0               m_username = userName;
      9 ( 0.00%)     0            0               6 ( 0.00%)     0            0               3 ( 0.00%) 0          0               m_id = id;
      9 ( 0.00%)     0            0               6 ( 0.00%)     0            0               3 ( 0.00%) 0          0               m_points = points;
     18 ( 0.00%)     0            0               6 ( 0.00%)     0            0               3 ( 0.00%) 0          0               m_hand = hand;
     12 ( 0.00%)     3 ( 0.00%)   2 ( 0.00%)      9 ( 0.00%)     0            0               0          0          0           }
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           Player::Player(const QJsonObject& o){
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .               m_username = o["userName"].toString().toStdString();
      .              .            .               .              .            .               .          .          .               m_id = Player::playerCnt++;
      .              .            .               .              .            .               .          .          .               m_points = 0;
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           
-- line 18 ----------------------------------------
-- line 21 ----------------------------------------
      .              .            .               .              .            .               .          .          .           Player::Player(){
      .              .            .               .              .            .               .          .          .               Player::playerCnt++;
      .              .            .               .              .            .               .          .          .               m_username = "player" + std::to_string(playerCnt);
      .              .            .               .              .            .               .          .          .               m_id = Player::playerCnt++;
      .              .            .               .              .            .               .          .          .               m_points = 0;
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           }
      .              .            .               .              .            .               .          .          .           
    216 ( 0.00%)    35 ( 0.00%)  19 ( 0.01%)      0              0            0             108 ( 0.00%) 0          0           std::string Player::username() const {
    180 ( 0.00%)    15 ( 0.00%)   0              72 ( 0.00%)     0            0              36 ( 0.00%) 0          0               return m_username;
    108 ( 0.00%)     0            0             108 ( 0.00%)     0            0               0          0          0           }
      .              .            .               .              .            .               .          .          .           
  8,072 ( 0.00%) 1,964 ( 0.07%)  28 ( 0.02%)      0              0            0           4,036 ( 0.01%) 0          0           int Player::id() const {
  4,036 ( 0.00%)     0            0           4,036 ( 0.00%) 1,427 ( 0.30%) 483 ( 0.48%)      0          0          0               return m_id;
  4,036 ( 0.00%)     0            0           4,036 ( 0.00%)     0            0               0          0          0           }
      .              .            .               .              .            .               .          .          .           
     72 ( 0.00%)    12 ( 0.00%)   0               0              0            0              36 ( 0.00%) 0          0           std::vector<int> Player::cards() const{
     72 ( 0.00%)    12 ( 0.00%)  11 ( 0.01%)     24 ( 0.00%)     0            0              12 ( 0.00%) 0          0               return m_hand;
     36 ( 0.00%)     0            0              36 ( 0.00%)     0            0               0          0          0           }
      .              .            .               .              .            .               .          .          .           
     96 ( 0.00%)    12 ( 0.00%)   4 ( 0.00%)      0              0            0              48 ( 0.00%) 0          0           int Player::points() const{
     48 ( 0.00%)     0            0              48 ( 0.00%)     5 ( 0.00%)   0               0          0          0               return m_points;
     48 ( 0.00%)     0            0              48 ( 0.00%)     0            0               0          0          0           }
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           
    180 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)      0              0            0              90 ( 0.00%) 0          0           void Player::addCard(int cardId){
    180 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)     30 ( 0.00%)     0            0              30 ( 0.00%) 0          0               m_hand.push_back(cardId);
     90 ( 0.00%)     0            0              60 ( 0.00%)     0            0               0          0          0           }
      .              .            .               .              .            .               .          .          .           
     60 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      0              0            0              36 ( 0.00%) 0          0           void Player::addPoints(int points){
     72 ( 0.00%)     0            0              48 ( 0.00%)     4 ( 0.00%)   1 ( 0.00%)     12 ( 0.00%) 0          0               m_points += points;
     36 ( 0.00%)     0            0              24 ( 0.00%)     0            0               0          0          0           }
      .              .            .               .              .            .               .          .          .           
    132 ( 0.00%)    12 ( 0.00%)  10 ( 0.01%)     12 ( 0.00%)     0            0              72 ( 0.00%) 0          0           void Player::discard(int cardId){
    540 ( 0.00%)    24 ( 0.00%)  12 ( 0.01%)    132 ( 0.00%)     0            0              60 ( 0.00%) 0          0               for(int i = 0; i < m_hand.size(); i++){
    576 ( 0.00%)    12 ( 0.00%)  10 ( 0.01%)    192 ( 0.00%)     0            0              48 ( 0.00%) 0          0                   if(m_hand[i] == cardId){
    276 ( 0.00%)     0            0              48 ( 0.00%)     0            0              72 ( 0.00%) 0          0                       m_hand.erase(m_hand.begin() + i);
     12 ( 0.00%)     0            0               0              0            0               0          0          0                       break;
      .              .            .               .              .            .               .          .          .                   }
      .              .            .               .              .            .               .          .          .               }
    108 ( 0.00%)     0            0              72 ( 0.00%)     0            0               0          0          0           }
      .              .            .               .              .            .               .          .          .           
 15,320 ( 0.00%) 1,272 ( 0.05%)  72 ( 0.06%)  1,532 ( 0.00%)     0            0           7,660 ( 0.01%) 0          0           QJsonObject Player::toJson(){
  4,596 ( 0.00%)     0            0           1,532 ( 0.00%)     0            0           1,532 ( 0.00%) 0          0               QJsonObject p;
 55,152 ( 0.01%) 1,271 ( 0.05%) 332 ( 0.26%)  3,064 ( 0.00%)     0            0          15,320 ( 0.02%) 0          0               p["username"] = QString::fromStdString(m_username);
 44,428 ( 0.01%) 2,356 ( 0.09%) 409 ( 0.32%)  4,596 ( 0.00%)    78 ( 0.02%)   0          12,256 ( 0.02%) 0          0               p["id"] = QJsonValue(m_id);
 44,428 ( 0.01%) 2,075 ( 0.08%) 281 ( 0.22%)  4,596 ( 0.00%)   538 ( 0.11%)  13 ( 0.01%) 12,256 ( 0.02%) 0          0               p["points"] = QJsonValue(m_points);
 44,428 ( 0.01%) 1,122 ( 0.04%)  14 ( 0.01%)  4,596 ( 0.00%)    41 ( 0.01%)   0          12,256 ( 0.02%) 0          0               p["color"] = QJsonValue(m_id);
      .              .            .               .              .            .               .          .          .           
  4,596 ( 0.00%)     0            0               0              0            0           1,532 ( 0.00%) 0          0               QJsonArray serializedHand;
 76,304 ( 0.02%) 2,093 ( 0.08%)  51 ( 0.04%) 23,392 ( 0.02%)     0            0           9,840 ( 0.01%) 0          0               for(size_t i=0; i<m_hand.size(); i++)
128,744 ( 0.03%)     0            0          20,328 ( 0.02%)   938 ( 0.20%) 431 ( 0.42%) 27,104 ( 0.04%) 0          0                   serializedHand.push_back(QJsonValue(m_hand[i]));
 42,896 ( 0.01%)   561 ( 0.02%)  51 ( 0.04%)  1,532 ( 0.00%)     0            0          12,256 ( 0.02%) 0          0               p["hand"] = serializedHand;
      .              .            .               .              .            .               .          .          .           
  3,064 ( 0.00%)     0            0               0              0            0               0          0          0               return p;
 15,320 ( 0.00%) 2,174 ( 0.08%)  31 ( 0.02%)  9,192 ( 0.01%)    11 ( 0.00%)   7 ( 0.01%)  1,532 ( 0.00%) 0          0           }
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           Player* Player::fromJson(const QJsonObject& o){
      .              .            .               .              .            .               .          .          .               std::string userName = o["username"].toString().toStdString();
      .              .            .               .              .            .               .          .          .               int id = o["id"].toInt();
      .              .            .               .              .            .               .          .          .               int points = o["points"].toInt();
      .              .            .               .              .            .               .          .          .           
-- line 85 ----------------------------------------
-- line 88 ----------------------------------------
      .              .            .               .              .            .               .          .          .               for(auto el : serializedHand){
      .              .            .               .              .            .               .          .          .                   deserializedHand.push_back(el.toInt());
      .              .            .               .              .            .               .          .          .               }
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .               Player* p = new Player(userName, id, points, deserializedHand);
      .              .            .               .              .            .               .          .          .               return p;
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           }
     21 ( 0.00%)     3 ( 0.00%)   3 ( 0.00%)      6 ( 0.00%)     0            0               5 ( 0.00%) 0          0           int Player::playerCnt = -1;
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           
      .              .            .               .              .            .               .          .          .           /*
      .              .            .               .              .            .               .          .          .           std::ostream &operator<<(std::ostream &out, const Player &p) {
      .              .            .               .              .            .               .          .          .               out << "username: " << p.username() << ", color: " << p.color() <<
      .              .            .               .              .            .               .          .          .               ", points: " << p.points();
      .              .            .               .              .            .               .          .          .               return out;
-- line 104 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/x86_64-linux-gnu/qt5/QtCore/qrefcount.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr       Dr              D1mr       DLmr       Dw              D1mw       DLmw       

-- line 57 ----------------------------------------
      .              .          .               .          .          .               .          .          .                   if (count == 0) // !isSharable
      .              .          .               .          .          .               .          .          .                       return false;
      .              .          .               .          .          .               .          .          .           #endif
      .              .          .               .          .          .               .          .          .                   if (count != -1) // !isStatic
      .              .          .               .          .          .               .          .          .                       atomic.ref();
      .              .          .               .          .          .               .          .          .                   return true;
      .              .          .               .          .          .               .          .          .               }
      .              .          .               .          .          .               .          .          .           
125,640 ( 0.03%)     0          0               0          0          0          50,256 ( 0.07%) 0          0               inline bool deref() noexcept {
100,512 ( 0.02%)     0          0          25,128 ( 0.02%) 0          0          50,256 ( 0.07%) 0          0                   int count = atomic.loadRelaxed();
      .              .          .               .          .          .               .          .          .           #if !defined(QT_NO_UNSHARABLE_CONTAINERS)
 50,256 ( 0.01%)     0          0          25,128 ( 0.02%) 0          0               0          0          0                   if (count == 0) // !isSharable
      .              .          .               .          .          .               .          .          .                       return false;
      .              .          .               .          .          .               .          .          .           #endif
 50,256 ( 0.01%) 1,120 ( 0.04%) 1 ( 0.00%) 25,128 ( 0.02%) 0          0               0          0          0                   if (count == -1) // isStatic
      .              .          .               .          .          .               .          .          .                       return true;
100,512 ( 0.02%)     0          0          25,128 ( 0.02%) 0          0          25,128 ( 0.04%) 0          0                   return atomic.deref();
 50,256 ( 0.01%)     0          0          50,256 ( 0.05%) 0          0               0          0          0               }
      .              .          .               .          .          .               .          .          .           
      .              .          .               .          .          .               .          .          .           #if !defined(QT_NO_UNSHARABLE_CONTAINERS)
      .              .          .               .          .          .               .          .          .               bool setSharable(bool sharable) noexcept
      .              .          .               .          .          .               .          .          .               {
      .              .          .               .          .          .               .          .          .                   Q_ASSERT(!isShared());
      .              .          .               .          .          .               .          .          .                   if (sharable)
      .              .          .               .          .          .               .          .          .                       return atomic.testAndSetRelaxed(0, 1);
      .              .          .               .          .          .               .          .          .                   else
-- line 82 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_iterator.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr         DLmr        Dw               D1mw           DLmw           

-- line 1015 ----------------------------------------
      .              .            .                .            .           .                .              .              .                 typedef typename __traits_type::difference_type 	difference_type;
      .              .            .                .            .           .                .              .              .                 typedef typename __traits_type::reference 	reference;
      .              .            .                .            .           .                .              .              .                 typedef typename __traits_type::pointer   	pointer;
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .           #if __cplusplus > 201703L && __cpp_lib_concepts
      .              .            .                .            .           .                .              .              .                 using iterator_concept = std::__detail::__iter_concept<_Iterator>;
      .              .            .                .            .           .                .              .              .           #endif
      .              .            .                .            .           .                .              .              .           
311,856 ( 0.07%)   561 ( 0.02%)   1 ( 0.00%)       0            0           0          155,928 ( 0.23%)     0              0                 _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
389,820 ( 0.09%)     0            0          233,892 ( 0.21%)   0           0           77,964 ( 0.11%) 4,123 ( 1.68%) 1,183 ( 1.44%)        : _M_current(_Iterator()) { }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 explicit _GLIBCXX20_CONSTEXPR
242,115 ( 0.06%)   640 ( 0.02%)  70 ( 0.05%)       0            0           0          145,269 ( 0.21%)     5 ( 0.00%)     0                 __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
338,961 ( 0.08%)    31 ( 0.00%)  21 ( 0.02%) 242,115 ( 0.22%) 120 ( 0.03%) 56 ( 0.06%)  48,423 ( 0.07%)     0              0                 : _M_current(__i) { }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 // Allow iterator to const_iterator conversion
      .              .            .                .            .           .                .              .              .                 template<typename _Iter>
      .              .            .                .            .           .                .              .              .                   _GLIBCXX20_CONSTEXPR
     72 ( 0.00%)     0            0                0            0           0               36 ( 0.00%)     0              0                   __normal_iterator(const __normal_iterator<_Iter,
      .              .            .                .            .           .                .              .              .           			  typename __enable_if<
      .              .            .                .            .           .                .              .              .                 	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
      .              .            .                .            .           .                .              .              .           		      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT
    108 ( 0.00%)    12 ( 0.00%)   4 ( 0.00%)      60 ( 0.00%)   0           0               24 ( 0.00%)     0              0                   : _M_current(__i.base()) { }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 // Forward iterator requirements
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 reference
171,096 ( 0.04%) 1,137 ( 0.04%)  71 ( 0.06%)       0            0           0           85,548 ( 0.12%)     0              0                 operator*() const _GLIBCXX_NOEXCEPT
171,096 ( 0.04%) 1,122 ( 0.04%) 125 ( 0.10%) 171,096 ( 0.15%)   0           0                0              0              0                 { return *_M_current; }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 pointer
      .              .            .                .            .           .                .              .              .                 operator->() const _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .                 { return _M_current; }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 __normal_iterator&
121,132 ( 0.03%)     3 ( 0.00%)   0                0            0           0           60,566 ( 0.09%)     0              0                 operator++() _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .                 {
151,415 ( 0.04%)     0            0           90,849 ( 0.08%)  44 ( 0.01%)  0           30,283 ( 0.04%)     0              0           	++_M_current;
 30,283 ( 0.01%)     3 ( 0.00%)   0           30,283 ( 0.03%)   0           0                0              0              0           	return *this;
 60,566 ( 0.01%)     0            0           60,566 ( 0.05%)   0           0                0              0              0                 }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 __normal_iterator
      .              .            .                .            .           .                .              .              .                 operator++(int) _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .                 { return __normal_iterator(_M_current++); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 // Bidirectional iterator requirements
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 __normal_iterator&
 35,992 ( 0.01%)   561 ( 0.02%)   1 ( 0.00%)       0            0           0           17,996 ( 0.03%)     0              0                 operator--() _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .                 {
 44,990 ( 0.01%)     0            0           26,994 ( 0.02%)   0           0            8,998 ( 0.01%)     0              0           	--_M_current;
  8,998 ( 0.00%)     0            0            8,998 ( 0.01%)   0           0                0              0              0           	return *this;
 17,996 ( 0.00%)     0            0           17,996 ( 0.02%)   0           0                0              0              0                 }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 __normal_iterator
      .              .            .                .            .           .                .              .              .                 operator--(int) _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .                 { return __normal_iterator(_M_current--); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 // Random access iterator requirements
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
-- line 1078 ----------------------------------------
-- line 1082 ----------------------------------------
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 __normal_iterator&
      .              .            .                .            .           .                .              .              .                 operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .                 { _M_current += __n; return *this; }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 __normal_iterator
  5,598 ( 0.00%)   576 ( 0.02%) 268 ( 0.21%)     622 ( 0.00%)   0           0            2,488 ( 0.00%)     0              0                 operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
 12,257 ( 0.00%)   576 ( 0.02%) 212 ( 0.17%)   4,976 ( 0.00%)   0           0            1,244 ( 0.00%)     0              0                 { return __normal_iterator(_M_current + __n); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 __normal_iterator&
      .              .            .                .            .           .                .              .              .                 operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .                 { _M_current -= __n; return *this; }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 __normal_iterator
 82,602 ( 0.02%)    19 ( 0.00%)  13 ( 0.01%)   9,178 ( 0.01%)   0           0           36,712 ( 0.05%)     0              0                 operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
165,687 ( 0.04%)   593 ( 0.02%)  24 ( 0.02%)  73,424 ( 0.07%)   0           0           18,356 ( 0.03%)     0              0                 { return __normal_iterator(_M_current - __n); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .                 _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .                 const _Iterator&
468,296 ( 0.11%)   579 ( 0.02%) 147 ( 0.12%)       0            0           0          234,148 ( 0.34%)     0              0                 base() const _GLIBCXX_NOEXCEPT
351,222 ( 0.08%)    20 ( 0.00%)  20 ( 0.02%) 351,222 ( 0.32%)   0           0                0              0              0                 { return _M_current; }
      .              .            .                .            .           .                .              .              .               };
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .             // Note: In what follows, the left- and right-hand-side iterators are
      .              .            .                .            .           .                .              .              .             // allowed to vary in types (conceptually in cv-qualification) so that
      .              .            .                .            .           .                .              .              .             // comparison between cv-qualified and non-cv-qualified iterators be
      .              .            .                .            .           .                .              .              .             // valid.  However, the greedy and unfriendly operators in std::rel_ops
      .              .            .                .            .           .                .              .              .             // will make overload resolution ambiguous (when in scope) if we don't
      .              .            .                .            .           .                .              .              .             // provide overloads whose operands are of the same type.  Can someone
-- line 1114 ----------------------------------------
-- line 1155 ----------------------------------------
      .              .            .                .            .           .                .              .              .               operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      .              .            .                .            .           .                .              .              .           	       const __normal_iterator<_IteratorR, _Container>& __rhs)
      .              .            .                .            .           .                .              .              .               _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .               { return __lhs.base() == __rhs.base(); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .             template<typename _Iterator, typename _Container>
      .              .            .                .            .           .                .              .              .               _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .               inline bool
 97,986 ( 0.02%)   565 ( 0.02%)  81 ( 0.06%)       0            0           0           55,992 ( 0.08%)   160 ( 0.07%)   101 ( 0.12%)      operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
      .              .            .                .            .           .                .              .              .           	       const __normal_iterator<_Iterator, _Container>& __rhs)
      .              .            .                .            .           .                .              .              .               _GLIBCXX_NOEXCEPT
181,974 ( 0.04%)     0            0           97,986 ( 0.09%)   0           0           27,996 ( 0.04%)     3 ( 0.00%)     1 ( 0.00%)      { return __lhs.base() == __rhs.base(); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .             template<typename _IteratorL, typename _IteratorR, typename _Container>
      .              .            .                .            .           .                .              .              .               _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .               inline bool
      .              .            .                .            .           .                .              .              .               operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      .              .            .                .            .           .                .              .              .           	       const __normal_iterator<_IteratorR, _Container>& __rhs)
      .              .            .                .            .           .                .              .              .               _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .               { return __lhs.base() != __rhs.base(); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .             template<typename _Iterator, typename _Container>
      .              .            .                .            .           .                .              .              .               _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .               inline bool
184,254 ( 0.04%) 1,130 ( 0.04%) 274 ( 0.21%)       0            0           0          105,288 ( 0.15%)     0              0               operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
      .              .            .                .            .           .                .              .              .           	       const __normal_iterator<_Iterator, _Container>& __rhs)
      .              .            .                .            .           .                .              .              .               _GLIBCXX_NOEXCEPT
342,186 ( 0.08%)   601 ( 0.02%)  49 ( 0.04%) 184,254 ( 0.17%)   0           0           52,644 ( 0.08%)     0              0               { return __lhs.base() != __rhs.base(); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .             // Random access iterator requirements
      .              .            .                .            .           .                .              .              .             template<typename _IteratorL, typename _IteratorR, typename _Container>
      .              .            .                .            .           .                .              .              .               inline bool
      .              .            .                .            .           .                .              .              .               operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
      .              .            .                .            .           .                .              .              .           	      const __normal_iterator<_IteratorR, _Container>& __rhs)
      .              .            .                .            .           .                .              .              .               _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .               { return __lhs.base() < __rhs.base(); }
-- line 1190 ----------------------------------------
-- line 1260 ----------------------------------------
      .              .            .                .            .           .                .              .              .               operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      .              .            .                .            .           .                .              .              .           	      const __normal_iterator<_IteratorR, _Container>& __rhs)
      .              .            .                .            .           .                .              .              .           #endif
      .              .            .                .            .           .                .              .              .               { return __lhs.base() - __rhs.base(); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .             template<typename _Iterator, typename _Container>
      .              .            .                .            .           .                .              .              .               _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .               inline typename __normal_iterator<_Iterator, _Container>::difference_type
 59,675 ( 0.01%)    25 ( 0.00%)  20 ( 0.02%)       0            0           0           34,100 ( 0.05%)     0              0               operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
      .              .            .                .            .           .                .              .              .           	      const __normal_iterator<_Iterator, _Container>& __rhs)
      .              .            .                .            .           .                .              .              .               _GLIBCXX_NOEXCEPT
119,542 ( 0.03%)   573 ( 0.02%) 328 ( 0.26%)  59,675 ( 0.05%)   0           0           17,050 ( 0.02%)     0              0               { return __lhs.base() - __rhs.base(); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .             template<typename _Iterator, typename _Container>
      .              .            .                .            .           .                .              .              .               _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .               inline __normal_iterator<_Iterator, _Container>
      .              .            .                .            .           .                .              .              .               operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
      .              .            .                .            .           .                .              .              .           	      __n, const __normal_iterator<_Iterator, _Container>& __i)
      .              .            .                .            .           .                .              .              .               _GLIBCXX_NOEXCEPT
      .              .            .                .            .           .                .              .              .               { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
-- line 1279 ----------------------------------------
-- line 1283 ----------------------------------------
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .           namespace std _GLIBCXX_VISIBILITY(default)
      .              .            .                .            .           .                .              .              .           {
      .              .            .                .            .           .                .              .              .           _GLIBCXX_BEGIN_NAMESPACE_VERSION
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .             template<typename _Iterator, typename _Container>
      .              .            .                .            .           .                .              .              .               _GLIBCXX20_CONSTEXPR
      .              .            .                .            .           .                .              .              .               _Iterator
 11,730 ( 0.00%)    17 ( 0.00%)   7 ( 0.01%)       0            0           0            4,692 ( 0.01%)   374 ( 0.15%)     0               __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
      .              .            .                .            .           .                .              .              .               _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
 14,076 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)   7,038 ( 0.01%)   0           0            2,346 ( 0.00%)     8 ( 0.00%)     0               { return __it.base(); }
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .           #if __cplusplus >= 201103L
      .              .            .                .            .           .                .              .              .             /**
      .              .            .                .            .           .                .              .              .              * @addtogroup iterators
      .              .            .                .            .           .                .              .              .              * @{
      .              .            .                .            .           .                .              .              .              */
      .              .            .                .            .           .                .              .              .           
      .              .            .                .            .           .                .              .              .           #if __cplusplus > 201703L && __cpp_lib_concepts
-- line 1301 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_pair.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr       DLmr       Dw               D1mw        DLmw        

-- line 203 ----------------------------------------
      .              .            .                .          .          .                .           .           .              *  @brief Struct holding two objects of arbitrary type.
      .              .            .                .          .          .                .           .           .              *
      .              .            .                .          .          .                .           .           .              *  @tparam _T1  Type of first object.
      .              .            .                .          .          .                .           .           .              *  @tparam _T2  Type of second object.
      .              .            .                .          .          .                .           .           .              *
      .              .            .                .          .          .                .           .           .              *  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
      .              .            .                .          .          .                .           .           .              */
      .              .            .                .          .          .                .           .           .             template<typename _T1, typename _T2>
286,110 ( 0.07%)     0            0           76,296 ( 0.07%) 0          0           76,296 ( 0.11%)  0           0               struct pair
      .              .            .                .          .          .                .           .           .               : private __pair_base<_T1, _T2>
      .              .            .                .          .          .                .           .           .               {
      .              .            .                .          .          .                .           .           .                 typedef _T1 first_type;    ///< The type of the `first` member
      .              .            .                .          .          .                .           .           .                 typedef _T2 second_type;   ///< The type of the `second` member
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .                 _T1 first;                 ///< The first member
      .              .            .                .          .          .                .           .           .                 _T2 second;                ///< The second member
      .              .            .                .          .          .                .           .           .           
-- line 219 ----------------------------------------
-- line 224 ----------------------------------------
      .              .            .                .          .          .                .           .           .           #if __cplusplus >= 201103L
      .              .            .                .          .          .                .           .           .                 template <typename _U1 = _T1,
      .              .            .                .          .          .                .           .           .                           typename _U2 = _T2,
      .              .            .                .          .          .                .           .           .                           typename enable_if<__and_<
      .              .            .                .          .          .                .           .           .                                                __is_implicitly_default_constructible<_U1>,
      .              .            .                .          .          .                .           .           .                                                __is_implicitly_default_constructible<_U2>>
      .              .            .                .          .          .                .           .           .                                              ::value, bool>::type = true>
      .              .            .                .          .          .                .           .           .           #endif
292,970 ( 0.07%)     2 ( 0.00%)   1 ( 0.00%)       0          0          0          117,188 ( 0.17%)  0           0                 _GLIBCXX_CONSTEXPR pair()
476,500 ( 0.11%)   561 ( 0.02%)  30 ( 0.02%) 234,376 ( 0.21%) 0          0          117,188 ( 0.17%)  0           0                 : first(), second() { }
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .           #if __cplusplus >= 201103L
      .              .            .                .          .          .                .           .           .                 template <typename _U1 = _T1,
      .              .            .                .          .          .                .           .           .                           typename _U2 = _T2,
      .              .            .                .          .          .                .           .           .                           typename enable_if<__and_<
      .              .            .                .          .          .                .           .           .                                  is_default_constructible<_U1>,
      .              .            .                .          .          .                .           .           .                                  is_default_constructible<_U2>,
      .              .            .                .          .          .                .           .           .                                  __not_<
-- line 241 ----------------------------------------
-- line 306 ----------------------------------------
      .              .            .                .          .          .                .           .           .           			 && !_PCCFP<_U1, _U2>::template
      .              .            .                .          .          .                .           .           .           			   _ImplicitlyConvertiblePair<_U1, _U2>(),
      .              .            .                .          .          .                .           .           .                                    bool>::type=false>
      .              .            .                .          .          .                .           .           .           	explicit constexpr pair(const pair<_U1, _U2>& __p)
      .              .            .                .          .          .                .           .           .           	: first(__p.first), second(__p.second) { }
      .              .            .                .          .          .                .           .           .           #endif
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .           #if __cplusplus >= 201103L
283,866 ( 0.07%)   561 ( 0.02%) 153 ( 0.12%)  86,394 ( 0.08%) 4 ( 0.00%) 0           74,052 ( 0.11%)  1 ( 0.00%)  0                 constexpr pair(const pair&) = default;	///< Copy constructor
      .              .            .                .          .          .                .           .           .                 constexpr pair(pair&&) = default;		///< Move constructor
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .                 // DR 811.
      .              .            .                .          .          .                .           .           .                 template<typename _U1, typename
      .              .            .                .          .          .                .           .           .           	       enable_if<_PCCP::template
      .              .            .                .          .          .                .           .           .           			   _MoveCopyPair<true, _U1, _T2>(),
      .              .            .                .          .          .                .           .           .                                    bool>::type=true>
      .              .            .                .          .          .                .           .           .                  constexpr pair(_U1&& __x, const _T2& __y)
-- line 322 ----------------------------------------
-- line 344 ----------------------------------------
      .              .            .                .          .          .                .           .           .                  : first(__x), second(std::forward<_U2>(__y)) { }
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .                 template<typename _U1, typename _U2, typename
      .              .            .                .          .          .                .           .           .           	       enable_if<_PCCP::template
      .              .            .                .          .          .                .           .           .           			   _MoveConstructiblePair<_U1, _U2>()
      .              .            .                .          .          .                .           .           .           			  && _PCCP::template
      .              .            .                .          .          .                .           .           .           			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
      .              .            .                .          .          .                .           .           .                                    bool>::type=true>
 63,954 ( 0.01%) 1,123 ( 0.04%)   8 ( 0.01%)   1,683 ( 0.00%) 0          0           37,026 ( 0.05%)  0           0           	constexpr pair(_U1&& __x, _U2&& __y)
168,861 ( 0.04%) 6,171 ( 0.23%) 380 ( 0.30%)  62,271 ( 0.06%) 0          0           38,148 ( 0.06%)  0           0           	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .                 template<typename _U1, typename _U2, typename
      .              .            .                .          .          .                .           .           .           	       enable_if<_PCCP::template
      .              .            .                .          .          .                .           .           .           			   _MoveConstructiblePair<_U1, _U2>()
      .              .            .                .          .          .                .           .           .           			  && !_PCCP::template
      .              .            .                .          .          .                .           .           .           			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
      .              .            .                .          .          .                .           .           .                                    bool>::type=false>
      .              .            .                .          .          .                .           .           .           	explicit constexpr pair(_U1&& __x, _U2&& __y)
-- line 361 ----------------------------------------
-- line 363 ----------------------------------------
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .                 template<typename _U1, typename _U2, typename
      .              .            .                .          .          .                .           .           .           	       enable_if<_PCCFP<_U1, _U2>::template
      .              .            .                .          .          .                .           .           .           			   _MoveConstructiblePair<_U1, _U2>()
      .              .            .                .          .          .                .           .           .           			  && _PCCFP<_U1, _U2>::template
      .              .            .                .          .          .                .           .           .           			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
      .              .            .                .          .          .                .           .           .                                    bool>::type=true>
 15,708 ( 0.00%)     0            0                0          0          0            8,976 ( 0.01%)  0           0           	constexpr pair(pair<_U1, _U2>&& __p)
 15,708 ( 0.00%)   561 ( 0.02%)   9 ( 0.01%)   4,488 ( 0.00%) 0          0            4,488 ( 0.01%)  0           0           	: first(std::forward<_U1>(__p.first)),
 29,172 ( 0.01%)     0            0           11,220 ( 0.01%) 0          0            4,488 ( 0.01%)  0           0           	  second(std::forward<_U2>(__p.second)) { }
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .                 template<typename _U1, typename _U2, typename
      .              .            .                .          .          .                .           .           .           	       enable_if<_PCCFP<_U1, _U2>::template
      .              .            .                .          .          .                .           .           .           			   _MoveConstructiblePair<_U1, _U2>()
      .              .            .                .          .          .                .           .           .           			  && !_PCCFP<_U1, _U2>::template
      .              .            .                .          .          .                .           .           .           			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
      .              .            .                .          .          .                .           .           .                                    bool>::type=false>
      .              .            .                .          .          .                .           .           .           	explicit constexpr pair(pair<_U1, _U2>&& __p)
-- line 381 ----------------------------------------
-- line 382 ----------------------------------------
      .              .            .                .          .          .                .           .           .           	: first(std::forward<_U1>(__p.first)),
      .              .            .                .          .          .                .           .           .           	  second(std::forward<_U2>(__p.second)) { }
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .                 template<typename... _Args1, typename... _Args2>
      .              .            .                .          .          .                .           .           .           	_GLIBCXX20_CONSTEXPR
      .              .            .                .          .          .                .           .           .                   pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .                 _GLIBCXX20_CONSTEXPR pair&
 66,525 ( 0.02%)   561 ( 0.02%)   1 ( 0.00%)       0          0          0           39,915 ( 0.06%) 78 ( 0.03%) 11 ( 0.01%)        operator=(typename conditional<
      .              .            .                .          .          .                .           .           .           		__and_<is_copy_assignable<_T1>,
      .              .            .                .          .          .                .           .           .           		       is_copy_assignable<_T2>>::value,
      .              .            .                .          .          .                .           .           .           		const pair&, const __nonesuch&>::type __p)
      .              .            .                .          .          .                .           .           .                 {
 53,220 ( 0.01%)     0            0           39,915 ( 0.04%) 0          0           13,305 ( 0.02%)  2 ( 0.00%)  0           	first = __p.first;
 53,220 ( 0.01%)     0            0           39,915 ( 0.04%) 0          0           13,305 ( 0.02%)  0           0           	second = __p.second;
 13,305 ( 0.00%)     0            0           13,305 ( 0.01%) 0          0                0           0           0           	return *this;
 26,610 ( 0.01%)     0            0           26,610 ( 0.02%) 0          0                0           0           0                 }
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .                 _GLIBCXX20_CONSTEXPR pair&
      .              .            .                .          .          .                .           .           .                 operator=(typename conditional<
      .              .            .                .          .          .                .           .           .           		__and_<is_move_assignable<_T1>,
      .              .            .                .          .          .                .           .           .           		       is_move_assignable<_T2>>::value,
      .              .            .                .          .          .                .           .           .           		pair&&, __nonesuch&&>::type __p)
      .              .            .                .          .          .                .           .           .                 noexcept(__and_<is_nothrow_move_assignable<_T1>,
      .              .            .                .          .          .                .           .           .           		      is_nothrow_move_assignable<_T2>>::value)
-- line 406 ----------------------------------------
-- line 559 ----------------------------------------
      .              .            .                .          .          .                .           .           .              */
      .              .            .                .          .          .                .           .           .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
      .              .            .                .          .          .                .           .           .             // 181.  make_pair() unintended behavior
      .              .            .                .          .          .                .           .           .           #if __cplusplus >= 201103L
      .              .            .                .          .          .                .           .           .             // NB: DR 706.
      .              .            .                .          .          .                .           .           .             template<typename _T1, typename _T2>
      .              .            .                .          .          .                .           .           .               constexpr pair<typename __decay_and_strip<_T1>::__type,
      .              .            .                .          .          .                .           .           .                              typename __decay_and_strip<_T2>::__type>
 17,952 ( 0.00%)     0            0                0          0          0           11,220 ( 0.02%)  0           0               make_pair(_T1&& __x, _T2&& __y)
      .              .            .                .          .          .                .           .           .               {
      .              .            .                .          .          .                .           .           .                 typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      .              .            .                .          .          .                .           .           .                 typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      .              .            .                .          .          .                .           .           .                 typedef pair<__ds_type1, __ds_type2> 	      __pair_type;
 29,172 ( 0.01%)    34 ( 0.00%)  15 ( 0.01%)   6,732 ( 0.01%) 0          0            6,732 ( 0.01%)  0           0                 return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
  8,976 ( 0.00%)     0            0            8,976 ( 0.01%) 0          0                0           0           0               }
      .              .            .                .          .          .                .           .           .           #else
      .              .            .                .          .          .                .           .           .             template<typename _T1, typename _T2>
      .              .            .                .          .          .                .           .           .               inline pair<_T1, _T2>
      .              .            .                .          .          .                .           .           .               make_pair(_T1 __x, _T2 __y)
      .              .            .                .          .          .                .           .           .               { return pair<_T1, _T2>(__x, __y); }
      .              .            .                .          .          .                .           .           .           #endif
      .              .            .                .          .          .                .           .           .           
      .              .            .                .          .          .                .           .           .             /// @}
-- line 581 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/andrijanabos/Desktop/02-moxit-mock-dixit/backend/src/lib/game/game.cpp
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr           DLmr         Dw               D1mw        DLmw       

      .              .            .                .              .            .                .           .          .           #include "game.hpp"
      .              .            .                .              .            .                .           .          .           
     88 ( 0.00%)     6 ( 0.00%)   3 ( 0.00%)      16 ( 0.00%)     0            0               26 ( 0.00%)  0          0           Game::Game() : m_chat(QJsonArray()){
      4 ( 0.00%)     0            0                2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_currNarratorId = -1;
      4 ( 0.00%)     0            0                2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_maxPlayers = 3;
     10 ( 0.00%)     0            0                2 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_gameID = time(NULL);
      4 ( 0.00%)     2 ( 0.00%)   1 ( 0.00%)       2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_currNarrator = -1;
      4 ( 0.00%)     0            0                2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_narratorCard = -1;
      4 ( 0.00%)     0            0                2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_gamePhase = GamePhase::NARRATOR_CHOICE;
      4 ( 0.00%)     0            0                2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_voteCounter = 0;
      4 ( 0.00%)     0            0                2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_choiceCounter = 0;
      4 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_hostId = 0;
      4 ( 0.00%)     0            0                2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_isOver = false;
      4 ( 0.00%)     0            0                2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_prevNarratorCard = -1;
      4 ( 0.00%)     0            0                2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_isGameStarted = false;
     12 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       2 ( 0.00%)     0            0                2 ( 0.00%)  0          0               m_clue ="";
     14 ( 0.00%)     4 ( 0.00%)   2 ( 0.00%)      10 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           GamePhase Game::gamePhase() const{
      .              .            .                .              .            .                .           .          .               return m_gamePhase;
      .              .            .                .              .            .                .           .          .           }
      .              .            .                .              .            .                .           .          .           
      8 ( 0.00%)     0            0                0              0            0                4 ( 0.00%)  0          0           int Game::gameID() const{
      4 ( 0.00%)     0            0                4 ( 0.00%)     0            0                0           0          0               return m_gameID;
      4 ( 0.00%)     0            0                4 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           int Game::currNarrator() const{
      .              .            .                .              .            .                .           .          .               return m_currNarrator;
      .              .            .                .              .            .                .           .          .           }
      .              .            .                .              .            .                .           .          .           
     15 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0              0            0                6 ( 0.00%)  0          0           int Game::numOfPlayers() const{
     12 ( 0.00%)     0            0                3 ( 0.00%)     0            0                3 ( 0.00%)  0          0               return m_players.size();
      6 ( 0.00%)     0            0                6 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
      8 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       0              0            0                4 ( 0.00%)  0          0           int Game::maxPlayers() const{
      4 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       4 ( 0.00%)     2 ( 0.00%)   0                0           0          0               return m_maxPlayers;
      4 ( 0.00%)     0            0                4 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
     18 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0              0            0                9 ( 0.00%)  0          0           std::vector<Player> Game::players() const{
     18 ( 0.00%)     0            0                6 ( 0.00%)     0            0                3 ( 0.00%)  0          0               return m_players;
      9 ( 0.00%)     0            0                9 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           std::string Game::clue() const{
      .              .            .                .              .            .                .           .          .               return m_clue;
      .              .            .                .              .            .                .           .          .           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           int Game::narratorCard() const{
      .              .            .                .              .            .                .           .          .               return m_narratorCard;
      .              .            .                .              .            .                .           .          .           }
-- line 49 ----------------------------------------
-- line 51 ----------------------------------------
      .              .            .                .              .            .                .           .          .           std::unordered_map<int, int> Game::commonPile() const{
      .              .            .                .              .            .                .           .          .               return m_commonPile;
      .              .            .                .              .            .                .           .          .           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           std::unordered_map<int, int> Game::votes(){
      .              .            .                .              .            .                .           .          .               return m_votes;
      .              .            .                .              .            .                .           .          .           }
      .              .            .                .              .            .                .           .          .           
      6 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0              0            0                3 ( 0.00%)  0          0           void Game::shuffleDeck(){
      5 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)     0            0                2 ( 0.00%)  0          0               int n = m_deck.size();
      4 ( 0.00%)     0            0                0              0            0                2 ( 0.00%)  0          0               srand(time(NULL)); //todo globalni seed
      .              .            .                .              .            .                .           .          .           
    255 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)     168 ( 0.00%)     0            0                1 ( 0.00%)  0          0               for (int i = n - 1; i > 0; i--)
      .              .            .                .              .            .                .           .          .               {
    498 ( 0.00%)     0            0               83 ( 0.00%)     0            0              166 ( 0.00%)  0          0                   int j = rand() % (i + 1);
      .              .            .                .              .            .                .           .          .           
  1,494 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)     332 ( 0.00%)     0            0              249 ( 0.00%)  0          0                   std::swap(m_deck[i], m_deck[j]);
      .              .            .                .              .            .                .           .          .               }
      5 ( 0.00%)     0            0                3 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
     10 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)     0            0                5 ( 0.00%)  0          0           void Game::initializeGame(const QJsonObject& config){
      .              .            .                .              .            .                .           .          .           
     23 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       2 ( 0.00%)     0            0                6 ( 0.00%)  0          0               m_maxPlayers =  config["numOfPlayers"].toInt();
      .              .            .                .              .            .                .           .          .               //todo : dodati tajmere
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               //inicijalizuj id-eve decka
      5 ( 0.00%)     0            0                1 ( 0.00%)     0            0                1 ( 0.00%)  0          0               m_deck.resize(DECKSIZE);
    256 ( 0.00%)     2 ( 0.00%)   1 ( 0.00%)     169 ( 0.00%)     0            0                1 ( 0.00%)  0          0               for(int i = 0; i < DECKSIZE; i++){
    840 ( 0.00%)     0            0              252 ( 0.00%)     0            0              168 ( 0.00%)  0          0                   m_deck[i] = i + 1;
      .              .            .                .              .            .                .           .          .               }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               //dodati host-a:
      5 ( 0.00%)     0            0                2 ( 0.00%)     0            0                1 ( 0.00%)  0          0               addPlayer(config);
      9 ( 0.00%)     2 ( 0.00%)   1 ( 0.00%)       2 ( 0.00%)     0            0                3 ( 0.00%)  0          0               m_hostId = m_players[0].id();
      .              .            .                .              .            .                .           .          .           
      7 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       5 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           void Game::addPlayer(Player& p){
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               m_players.push_back(p);
      .              .            .                .              .            .                .           .          .               m_idToPlayer[p.id()] = m_players.size() - 1;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           }
      .              .            .                .              .            .                .           .          .           
     33 ( 0.00%)     3 ( 0.00%)   3 ( 0.00%)       3 ( 0.00%)     0            0               18 ( 0.00%)  0          0           void Game::addPlayer(const QJsonObject &config){
      .              .            .                .              .            .                .           .          .           
     90 ( 0.00%)     9 ( 0.00%)   9 ( 0.01%)       3 ( 0.00%)     0            0               21 ( 0.00%)  0          0               std::string username = config["userName"].toString().toStdString();
     90 ( 0.00%)     6 ( 0.00%)   6 ( 0.00%)       3 ( 0.00%)     0            0               27 ( 0.00%)  0          0               Player p(username, m_players.size(), 0, {});
     18 ( 0.00%)     0            0                3 ( 0.00%)     0            0                3 ( 0.00%)  0          0               m_players.push_back(p);
     51 ( 0.00%)     6 ( 0.00%)   4 ( 0.00%)       6 ( 0.00%)     0            0               15 ( 0.00%)  0          0               m_idToPlayer[p.id()] = m_players.size() - 1;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           
     42 ( 0.00%)     3 ( 0.00%)   3 ( 0.00%)      18 ( 0.00%)     0            0                6 ( 0.00%)  0          0           }
      .              .            .                .              .            .                .           .          .           void Game::removePlayer(const QJsonObject &config){
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               int id = config["id"].toInt();
      .              .            .                .              .            .                .           .          .               //std::string userName = config["username"].toString().toStdString();
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               for(int i = 0; i < m_players.size(); i++){
      .              .            .                .              .            .                .           .          .                   if(m_players[i].id() == id){
      .              .            .                .              .            .                .           .          .                       m_players.erase(m_players.begin() + i);
      .              .            .                .              .            .                .           .          .                       break;
      .              .            .                .              .            .                .           .          .                   }
      .              .            .                .              .            .                .           .          .               }
      .              .            .                .              .            .                .           .          .           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           
      9 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)     0            0                4 ( 0.00%)  0          0           void Game::startGame(){
      .              .            .                .              .            .                .           .          .           
      2 ( 0.00%)     0            0                1 ( 0.00%)     0            0                1 ( 0.00%)  0          0               m_isGameStarted = true;
      3 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)     0            0                1 ( 0.00%)  0          0               shuffleDeck();
     13 ( 0.00%)     0            0                2 ( 0.00%)     0            0                3 ( 0.00%)  0          0               m_currNarrator = rand() % numOfPlayers();
     19 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       4 ( 0.00%)     0            0                5 ( 0.00%)  0          0               m_currNarratorId = players()[m_currNarrator].id();
      .              .            .                .              .            .                .           .          .           
     22 ( 0.00%)     0            0               13 ( 0.00%)     0            0                1 ( 0.00%)  0          0               for(int i = 0; i < INITIALDEAL; i++)
     18 ( 0.00%)     0            0                6 ( 0.00%)     0            0                6 ( 0.00%)  0          0                   drawCards();
      .              .            .                .              .            .                .           .          .           
     31 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       3 ( 0.00%)     0            0                6 ( 0.00%)  0          0               const std::string msg = "Igra je pocela. Narator je " + m_players[m_currNarrator].username() + ".";
     13 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)     0            0                3 ( 0.00%)  0          0               notify(msg);
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           
      9 ( 0.00%)     2 ( 0.00%)   1 ( 0.00%)       5 ( 0.00%)     0            0                1 ( 0.00%)  0          0           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           //ovo bi moglo da bude private
     60 ( 0.00%)     5 ( 0.00%)   5 ( 0.00%)       0              0            0               30 ( 0.00%)  0          0           void Game::drawCards(){
      .              .            .                .              .            .                .           .          .           
    450 ( 0.00%)     5 ( 0.00%)   5 ( 0.00%)     110 ( 0.00%)     0            0               50 ( 0.00%)  0          0               for(int i = 0; i < m_players.size(); i++){
    480 ( 0.00%)     5 ( 0.00%)   5 ( 0.00%)     120 ( 0.00%)     4 ( 0.00%)   0               90 ( 0.00%)  0          0                   m_players[i].addCard(m_deck.back());
    120 ( 0.00%)     0            0               30 ( 0.00%)     0            0               30 ( 0.00%)  0          0                   m_deck.pop_back();
      .              .            .                .              .            .                .           .          .               }
     50 ( 0.00%)     0            0               30 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
     44 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       4 ( 0.00%)     0            0               24 ( 0.00%)  0          0           void Game::narratorChoice(int cardId, const std::string& clue){
      .              .            .                .              .            .                .           .          .           
     52 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      12 ( 0.00%)     0            0                8 ( 0.00%)  0          0               std::vector<int> hand = m_players[m_currNarrator].cards();
     60 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0              0            0               12 ( 0.00%)  0          0               assert(std::count(hand.begin(), hand.end(), cardId) > 0);
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               //postavi asocijaciju i naratorovu kartu
     24 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       8 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_clue = clue;
     12 ( 0.00%)     0            0                8 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_narratorCard = cardId;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               //dodaj u commonPile
     40 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      16 ( 0.00%)     0            0                8 ( 0.00%)  0          0               m_commonPile[m_narratorCard] = m_currNarratorId;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               //izbaci iz ruke
     52 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      16 ( 0.00%)     0            0                8 ( 0.00%)  0          0               m_players[m_currNarrator].discard(cardId);
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               //promeni gamePhase
      8 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_gamePhase = GamePhase::PLAYERS_CHOOSE;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               //obavesti ostale da biraju kartu iz ruke
     48 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0              0            0               12 ( 0.00%)  0          0               std::string msg = "Odaberite kartu iz ruke.";
     52 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       4 ( 0.00%)     0            0               12 ( 0.00%)  0          0               notify(msg);
     48 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      20 ( 0.00%)     0            0                8 ( 0.00%)  0          0           }
      .              .            .                .              .            .                .           .          .           
     88 ( 0.00%)    16 ( 0.00%)  15 ( 0.01%)       8 ( 0.00%)     0            0               48 ( 0.00%)  0          0           void Game::playerChoice(int playerId, int cardId){
      .              .            .                .              .            .                .           .          .           
    144 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)      24 ( 0.00%)     0            0               24 ( 0.00%)  0          0               std::vector<int> hand = m_players[m_idToPlayer[playerId]].cards();
    120 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0              0            0               24 ( 0.00%)  0          0               assert(std::count(hand.begin(), hand.end(), cardId) > 0);
      .              .            .                .              .            .                .           .          .           
     64 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)      16 ( 0.00%)     0            0               16 ( 0.00%)  0          0               m_commonPile[cardId] = playerId;
      .              .            .                .              .            .                .           .          .           
    144 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)      32 ( 0.00%)     0            0               24 ( 0.00%)  0          0               m_players[m_idToPlayer[playerId]].discard(cardId);
      .              .            .                .              .            .                .           .          .           
    360 ( 0.00%)    27 ( 0.00%)  17 ( 0.01%)      88 ( 0.00%)     0            0               40 ( 0.00%)  0          0               for(int i = 0; i < m_players.size(); i++){
    336 ( 0.00%)     6 ( 0.00%)   0               72 ( 0.00%)     0            0               48 ( 0.00%)  0          0                   if(m_players[i].id() == playerId){
    240 ( 0.00%)    16 ( 0.00%)   9 ( 0.01%)      16 ( 0.00%)     0            0               48 ( 0.00%)  0          0                      std::string msg = "Igrac " + m_players[i].username() + " je izabrao kartu iz ruke.";
    104 ( 0.00%)     3 ( 0.00%)   0                8 ( 0.00%)     0            0               24 ( 0.00%)  0          0                      notify(msg);
     24 ( 0.00%)     0            0                0              0            0                8 ( 0.00%)  0          0                   }
      .              .            .                .              .            .                .           .          .               }
      .              .            .                .              .            .                .           .          .           
     40 ( 0.00%)     8 ( 0.00%)   6 ( 0.00%)      24 ( 0.00%)     0            0                8 ( 0.00%)  0          0               m_choiceCounter++;
      .              .            .                .              .            .                .           .          .           
     96 ( 0.00%)     0            0               24 ( 0.00%)     0            0                8 ( 0.00%)  0          0               if(m_choiceCounter == m_players.size() - 1){
      8 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       4 ( 0.00%)     0            0                4 ( 0.00%)  0          0                   m_gamePhase = GamePhase::PLAYERS_VOTE;
      8 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0                   m_choiceCounter = 0;
     48 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0              0            0               12 ( 0.00%)  0          0                   std::string msg = "Vreme je za glasanje.";
     52 ( 0.00%)     7 ( 0.00%)   0                4 ( 0.00%)     0            0               12 ( 0.00%)  0          0                   notify(msg);
     12 ( 0.00%)     0            0                0              0            0                4 ( 0.00%)  0          0               }
     72 ( 0.00%)    12 ( 0.00%)  12 ( 0.01%)      40 ( 0.00%)     0            0                8 ( 0.00%)  0          0           }
      .              .            .                .              .            .                .           .          .           
     88 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       8 ( 0.00%)     0            0               48 ( 0.00%)  0          0           void Game::playerVote(int playerId, int cardId){
      .              .            .                .              .            .                .           .          .           
    152 ( 0.00%)    16 ( 0.00%)  16 ( 0.01%)      16 ( 0.00%)     0            0               40 ( 0.00%)  0          0               assert(m_commonPile.find(cardId) != m_commonPile.end());
     64 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)      16 ( 0.00%)     0            0               16 ( 0.00%)  0          0               m_votes[playerId] = cardId;
      .              .            .                .              .            .                .           .          .           
    360 ( 0.00%)    16 ( 0.00%)  15 ( 0.01%)      88 ( 0.00%)     0            0               40 ( 0.00%)  0          0               for(int i = 0; i < m_players.size(); i++){
    336 ( 0.00%)    20 ( 0.00%)   8 ( 0.01%)      72 ( 0.00%)     0            0               48 ( 0.00%)  0          0                   if(m_players[i].id() == playerId){
    240 ( 0.00%)    16 ( 0.00%)  14 ( 0.01%)      16 ( 0.00%)     0            0               48 ( 0.00%)  0          0                      std::string msg = "Igrac " + m_players[i].username() + " je glasao.";
    104 ( 0.00%)     0            0                8 ( 0.00%)     0            0               24 ( 0.00%)  0          0                      notify(msg);
     24 ( 0.00%)     0            0                0              0            0                8 ( 0.00%)  0          0                   }
      .              .            .                .              .            .                .           .          .               }
     40 ( 0.00%)     0            0               24 ( 0.00%)     0            0                8 ( 0.00%)  0          0               m_voteCounter++;
     96 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)      24 ( 0.00%)     0            0                8 ( 0.00%)  0          0               if(m_voteCounter == m_players.size() - 1){
      8 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0                   m_voteCounter = 0;
      .              .            .                .              .            .                .           .          .           
     12 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       4 ( 0.00%)     0            0                4 ( 0.00%)  0          0                   endTurn();
      .              .            .                .              .            .                .           .          .               }
     60 ( 0.00%)    14 ( 0.00%)  12 ( 0.01%)      40 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
     36 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       4 ( 0.00%)     0            0               16 ( 0.00%)  0          0           void Game::updatePoints(){
      .              .            .                .              .            .                .           .          .           
      4 ( 0.00%)     0            0                0              0            0                4 ( 0.00%)  0          0               int forNarrator = 0;
      .              .            .                .              .            .                .           .          .           
    180 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)      44 ( 0.00%)     0            0               20 ( 0.00%)  0          0               for(int i = 0; i < m_players.size(); i++){
      .              .            .                .              .            .                .           .          .                   //ne gledamo za koga je narator glasao, iako svakako ne glasa
     48 ( 0.00%)     0            0               36 ( 0.00%)     0            0                0           0          0                   if(i == m_currNarrator)
      4 ( 0.00%)     0            0                0              0            0                0           0          0                       continue;
      .              .            .                .              .            .                .           .          .           
    144 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      32 ( 0.00%)     0            0               40 ( 0.00%)  0          0                   int chosenCard = m_votes[m_players[i].id()];
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .                   //ako je igrac glasao za naratora
     40 ( 0.00%)     0            0               24 ( 0.00%)     0            0                0           0          0                   if(chosenCard == m_narratorCard)
      8 ( 0.00%)     0            0                4 ( 0.00%)     0            0                0           0          0                       forNarrator++;
      .              .            .                .              .            .                .           .          .                   //ako nije glasao za naratora nego za nekog drugog, taj drugi dobija poene
      .              .            .                .              .            .                .           .          .                   else {
     32 ( 0.00%)     3 ( 0.00%)   3 ( 0.00%)       8 ( 0.00%)     0            0                8 ( 0.00%)  0          0                      int pointsFor = m_commonPile[chosenCard];
     68 ( 0.00%)     0            0               12 ( 0.00%)     0            0               12 ( 0.00%)  0          0                      m_players[m_idToPlayer[pointsFor]].addPoints(1);
      .              .            .                .              .            .                .           .          .                   }
      .              .            .                .              .            .                .           .          .               }
      4 ( 0.00%)     0            0                0              0            0                4 ( 0.00%)  0          0               int pointsForPlayer = MAXPOINTS;
      4 ( 0.00%)     0            0                0              0            0                4 ( 0.00%)  0          0               bool givePointsToNarrator = true;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               //da li su svi glasali za naratora?
     56 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      11 ( 0.00%)     0            0                4 ( 0.00%)  0          0               if(forNarrator == m_players.size() - 1 || forNarrator == 0){
      2 ( 0.00%)     0            0                2 ( 0.00%)     0            0                0           0          0                   pointsForPlayer--;
      2 ( 0.00%)     0            0                0              0            0                2 ( 0.00%)  0          0                   givePointsToNarrator = false;
      .              .            .                .              .            .                .           .          .               }
      .              .            .                .              .            .                .           .          .               //dodela svima osim naratoru
    180 ( 0.00%)    12 ( 0.00%)   8 ( 0.01%)      44 ( 0.00%)     0            0               20 ( 0.00%)  0          0               for(int i = 0; i < m_players.size(); i++){
     48 ( 0.00%)     0            0               36 ( 0.00%)     0            0                0           0          0                   if(i == m_currNarrator){
      4 ( 0.00%)     0            0                0              0            0                0           0          0                      continue;
      .              .            .                .              .            .                .           .          .                   }
    184 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      48 ( 0.00%)     0            0               32 ( 0.00%)  0          0                   else if(m_votes[m_players[i].id()] == m_narratorCard){
     48 ( 0.00%)     3 ( 0.00%)   3 ( 0.00%)      12 ( 0.00%)     0            0                8 ( 0.00%)  0          0                       m_players[i].addPoints(pointsForPlayer);
      8 ( 0.00%)     0            0                4 ( 0.00%)     0            0                0           0          0                       if(givePointsToNarrator)
     28 ( 0.00%)     0            0                8 ( 0.00%)     0            0                4 ( 0.00%)  0          0                           m_players[m_currNarrator].addPoints(pointsForPlayer);
      .              .            .                .              .            .                .           .          .                   }
     16 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       4 ( 0.00%)     0            0                0           0          0                   else if(!givePointsToNarrator){
     26 ( 0.00%)     0            0                6 ( 0.00%)     0            0                4 ( 0.00%)  0          0                       m_players[i].addPoints(pointsForPlayer);
      .              .            .                .              .            .                .           .          .                   }
      .              .            .                .              .            .                .           .          .               }
     28 ( 0.00%)     0            0               20 ( 0.00%)     0            0                0           0          0           }
    410 ( 0.00%)    78 ( 0.00%)  42 ( 0.03%)      41 ( 0.00%)     0            0              205 ( 0.00%)  0          0           void Game::notify(std::string message){
      .              .            .                .              .            .                .           .          .           
    123 ( 0.00%)     0            0                0              0            0               41 ( 0.00%)  0          0               QJsonObject messageInfo;
  1,599 ( 0.00%)   108 ( 0.00%)  57 ( 0.04%)       0              0            0              492 ( 0.00%)  1 ( 0.00%) 1 ( 0.00%)      messageInfo["time"] = QTime::currentTime().toString();
  1,476 ( 0.00%)    62 ( 0.00%)  40 ( 0.03%)       0              0            0              410 ( 0.00%)  0          0               messageInfo["userName"] = QString("Server");
  1,476 ( 0.00%)    82 ( 0.00%)  40 ( 0.03%)      41 ( 0.00%)     0            0              410 ( 0.00%)  0          0               messageInfo["content"] = QString::fromStdString(message);
      .              .            .                .              .            .                .           .          .           
    533 ( 0.00%)    41 ( 0.00%)  21 ( 0.02%)      41 ( 0.00%)     0            0              123 ( 0.00%)  0          0               m_chat.addMessage(messageInfo);
      .              .            .                .              .            .                .           .          .           
    369 ( 0.00%)    41 ( 0.00%)  12 ( 0.01%)     205 ( 0.00%)     0            0               41 ( 0.00%)  0          0           }
      .              .            .                .              .            .                .           .          .           
     36 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       4 ( 0.00%)     0            0               16 ( 0.00%)  0          0           void Game::notifyPlayers(){
      .              .            .                .              .            .                .           .          .           
    180 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      44 ( 0.00%)     0            0               20 ( 0.00%)  0          0               for(int i = 0; i < m_players.size(); i++){
    780 ( 0.00%)    52 ( 0.00%)  20 ( 0.02%)      48 ( 0.00%)     0            0              168 ( 0.00%)  0          0                   std::string msg = "Igrac " + m_players[i].username() + " ima " + std::to_string(m_players[i].points()) + " poena.";
    156 ( 0.00%)    12 ( 0.00%)   0               12 ( 0.00%)     0            0               36 ( 0.00%)  0          0                   notify(msg);
     36 ( 0.00%)    12 ( 0.00%)   0                0              0            0               12 ( 0.00%)  0          0               }
      .              .            .                .              .            .                .           .          .           
    124 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)      12 ( 0.00%)     0            0               24 ( 0.00%)  0          0               std::string msg = "Novi narator je " + m_players[m_currNarrator].username() + ".";
     52 ( 0.00%)     8 ( 0.00%)   4 ( 0.00%)       4 ( 0.00%)     0            0               12 ( 0.00%)  0          0               notify(msg);
     36 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      20 ( 0.00%)     0            0                4 ( 0.00%)  0          0           }
      .              .            .                .              .            .                .           .          .           
     24 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0              0            0               12 ( 0.00%)  0          0           void Game::endTurn(){
      .              .            .                .              .            .                .           .          .           
     12 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               updatePoints();
     20 ( 0.00%)     0            0                8 ( 0.00%)     0            0                8 ( 0.00%)  0          0               m_isOver = checkIfOver();
     12 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               drawCards();
      .              .            .                .              .            .                .           .          .           
     68 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      16 ( 0.00%)     0            0                8 ( 0.00%)  0          0               m_currNarrator = (m_currNarrator+1) % m_players.size();
     48 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      16 ( 0.00%)     0            0               12 ( 0.00%)  0          0               m_currNarratorId = m_players[m_currNarrator].id();
      .              .            .                .              .            .                .           .          .           
     16 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_commonPile.clear();
     16 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_votes.clear();
      8 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_gamePhase = GamePhase::NARRATOR_CHOICE;
     24 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_clue = "";
     16 ( 0.00%)     0            0               12 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_prevNarratorCard = m_narratorCard;
      8 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               m_narratorCard = -1;
      .              .            .                .              .            .                .           .          .           
     12 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               notifyPlayers();
     16 ( 0.00%)     0            0               12 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
     36 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       4 ( 0.00%)     0            0               16 ( 0.00%)  0          0           bool Game::checkIfOver(){
      .              .            .                .              .            .                .           .          .           
      4 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0              0            0                4 ( 0.00%)  0          0               bool check = false;
      .              .            .                .              .            .                .           .          .           
     24 ( 0.00%)     0            0                4 ( 0.00%)     0            0                4 ( 0.00%)  0          0               if(m_deck.empty()){
      .              .            .                .              .            .                .           .          .                   std::string msg = "Iskoriscene su sve karte iz deck-a. Igra je zavrsena.";
      .              .            .                .              .            .                .           .          .                   notify(msg);
      .              .            .                .              .            .                .           .          .                   return true;
      .              .            .                .              .            .                .           .          .               }
      .              .            .                .              .            .                .           .          .               else{
    180 ( 0.00%)    12 ( 0.00%)  12 ( 0.01%)      44 ( 0.00%)     0            0               20 ( 0.00%)  0          0                   for(int i = 0; i < m_players.size(); i++){
    156 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)      24 ( 0.00%)     0            0               24 ( 0.00%)  0          0                       if(m_players[i].points() >= 30){
      .              .            .                .              .            .                .           .          .                           std::string msg = "Pobednik je " + m_players[i].username() + ".";
      .              .            .                .              .            .                .           .          .                           notify(msg);
      .              .            .                .              .            .                .           .          .                           check = true;
      .              .            .                .              .            .                .           .          .                       }
      .              .            .                .              .            .                .           .          .                   }
     12 ( 0.00%)     0            0                4 ( 0.00%)     0            0                0           0          0                   return check == true;
      .              .            .                .              .            .                .           .          .               }
     28 ( 0.00%)     4 ( 0.00%)   1 ( 0.00%)      20 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           
  5,610 ( 0.00%)   561 ( 0.02%)  24 ( 0.02%)     561 ( 0.00%)     0            0            2,805 ( 0.00%)  1 ( 0.00%) 1 ( 0.00%)  QJsonObject Game::toJson(){
      .              .            .                .              .            .                .           .          .           
  1,683 ( 0.00%)   561 ( 0.02%)  19 ( 0.01%)     561 ( 0.00%)     0            0              561 ( 0.00%)  0          0               QJsonObject p;
      .              .            .                .              .            .                .           .          .           
 16,269 ( 0.00%)   561 ( 0.02%)  32 ( 0.03%)   1,683 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["voteCounter"] = QJsonValue(m_voteCounter);
 16,269 ( 0.00%) 1,122 ( 0.04%)   4 ( 0.00%)   1,683 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["choiceCounter"] = QJsonValue(m_choiceCounter);
 16,830 ( 0.00%) 1,122 ( 0.04%) 359 ( 0.28%)   1,683 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["isGameStarted"] = QJsonValue(m_isGameStarted);
 16,269 ( 0.00%) 1,122 ( 0.04%)   3 ( 0.00%)   1,683 ( 0.00%)    19 ( 0.00%)   7 ( 0.01%)   4,488 ( 0.01%)  0          0               p["prevCard"] = QJsonValue(m_prevNarratorCard);
 16,830 ( 0.00%) 1,122 ( 0.04%)   3 ( 0.00%)   1,683 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["isOver"] = QJsonValue(m_isOver);
 16,269 ( 0.00%) 1,683 ( 0.06%)   3 ( 0.00%)   1,683 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["id"] = QJsonValue(m_gameID);
 16,269 ( 0.00%) 1,683 ( 0.06%)   3 ( 0.00%)   1,683 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["hostId"] = QJsonValue(m_hostId);
 25,245 ( 0.01%) 1,683 ( 0.06%)  17 ( 0.01%)   1,683 ( 0.00%)     0            0            6,732 ( 0.01%)  0          0               p["gamePhase"] = QString::fromStdString(gamePhaseToStr(m_gamePhase));
      .              .            .                .              .            .                .           .          .           
  1,683 ( 0.00%)     0            0                0              0            0              561 ( 0.00%)  0          0               QJsonObject serializedPlayers;
 19,398 ( 0.00%)   561 ( 0.02%)  13 ( 0.01%)   5,718 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)   2,654 ( 0.00%)  0          0               for(size_t i = 0; i < m_players.size(); i++){
 21,448 ( 0.00%)   561 ( 0.02%) 155 ( 0.12%)   3,064 ( 0.00%)     0            0            4,596 ( 0.01%)  0          0                   auto playerId = QString::number(m_players[i].id());
 52,088 ( 0.01%) 1,122 ( 0.04%)  53 ( 0.04%)   3,064 ( 0.00%)     0            0           13,788 ( 0.02%)  0          0                   serializedPlayers[playerId] = m_players[i].toJson();
  4,596 ( 0.00%)     0            0                0              0            0            1,532 ( 0.00%)  0          0               }
 15,708 ( 0.00%) 1,122 ( 0.04%)   7 ( 0.01%)     561 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["players"] = serializedPlayers;
      .              .            .                .              .            .                .           .          .           
  8,267 ( 0.00%)   561 ( 0.02%)   3 ( 0.00%)   1,683 ( 0.00%)     2 ( 0.00%)   0              561 ( 0.00%)  0          0               if(m_players.size() > 0 && m_isGameStarted == true){
      .              .            .                .              .            .                .           .          .           
 15,694 ( 0.00%) 1,239 ( 0.05%) 280 ( 0.22%)   1,652 ( 0.00%)     0            0            4,130 ( 0.01%)  0          0                   p["narratorId"] = QJsonValue(m_players[m_currNarrator].id());
      .              .            .                .              .            .                .           .          .               }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           
 16,269 ( 0.00%) 1,270 ( 0.05%) 698 ( 0.55%)   1,683 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["currNarrator"] = QJsonValue(m_currNarrator);
 20,757 ( 0.00%) 1,122 ( 0.04%)  68 ( 0.05%)   1,122 ( 0.00%)     0            0            5,610 ( 0.01%)  0          0               p["clue"] = QString::fromStdString(m_clue);
 16,269 ( 0.00%) 1,122 ( 0.04%)   2 ( 0.00%)   1,683 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["narratorCard"] = QJsonValue(m_narratorCard);
      .              .            .                .              .            .                .           .          .           
  1,683 ( 0.00%)     0            0                0              0            0              561 ( 0.00%)  0          0               QJsonObject serializedCommonPile;
 19,871 ( 0.00%) 1,394 ( 0.05%)  11 ( 0.01%)   1,683 ( 0.00%)     0            0            5,998 ( 0.01%)  3 ( 0.00%) 0               for(auto &p : m_commonPile){
  4,606 ( 0.00%)     0            0            1,316 ( 0.00%)   403 ( 0.09%)  95 ( 0.09%)     658 ( 0.00%)  0          0                   auto cardId = QString::number(p.first);
  3,948 ( 0.00%)     0            0            1,316 ( 0.00%)    37 ( 0.01%)   0              658 ( 0.00%)  0          0                   auto playerId = QJsonValue(p.second);
  7,896 ( 0.00%)   272 ( 0.01%)   4 ( 0.00%)       0              0            0            2,632 ( 0.00%)  0          0                   serializedCommonPile[cardId] = playerId;
  3,948 ( 0.00%)     0            0                0              0            0            1,316 ( 0.00%)  0          0               }
 15,708 ( 0.00%) 1,122 ( 0.04%)   4 ( 0.00%)     561 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["commonPile"] = serializedCommonPile;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           
  1,683 ( 0.00%)     0            0                0              0            0              561 ( 0.00%)  0          0               QJsonObject serializedVotes;
 12,311 ( 0.00%) 2,362 ( 0.09%) 234 ( 0.18%)   1,683 ( 0.00%)     0            0            3,838 ( 0.01%) 27 ( 0.01%) 0               for(auto &p : m_votes){
    826 ( 0.00%)     0            0              236 ( 0.00%)    77 ( 0.02%)   3 ( 0.00%)     118 ( 0.00%)  0          0                   auto playerId = QString::number(p.first);
    708 ( 0.00%)   118 ( 0.00%)   6 ( 0.00%)     236 ( 0.00%)     2 ( 0.00%)   0              118 ( 0.00%)  0          0                   auto cardId = QJsonValue(p.second);
  1,416 ( 0.00%)     0            0                0              0            0              472 ( 0.00%)  0          0                   serializedVotes[playerId] = cardId;
    708 ( 0.00%)   118 ( 0.00%)   0                0              0            0              236 ( 0.00%)  0          0               }
 15,708 ( 0.00%)   561 ( 0.02%) 108 ( 0.08%)     561 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["votes"] = serializedVotes;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           
  1,683 ( 0.00%)   561 ( 0.02%)   2 ( 0.00%)       0              0            0              561 ( 0.00%)  0          0               QJsonArray serializedDeck;
343,353 ( 0.08%)   561 ( 0.02%)   1 ( 0.00%) 113,703 ( 0.10%)     0            0           38,649 ( 0.06%)  0          0               for(size_t i = 0; i < m_deck.size(); i++){
300,216 ( 0.07%)     0            0          112,581 ( 0.10%) 2,488 ( 0.53%) 388 ( 0.38%)  75,054 ( 0.11%)  0          0                   auto cardId = m_deck[i];
487,851 ( 0.11%)     0            0           37,527 ( 0.03%)     0            0          112,581 ( 0.16%)  0          0                   serializedDeck.append(cardId);
      .              .            .                .              .            .                .           .          .               }
 15,708 ( 0.00%) 1,122 ( 0.04%)  72 ( 0.06%)     561 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["deck"] = serializedDeck;
      .              .            .                .              .            .                .           .          .           
  2,805 ( 0.00%)     0            0              561 ( 0.00%)     0            0              561 ( 0.00%)  0          0               QJsonArray serializedChat = m_chat.convertToJson();
 15,708 ( 0.00%) 1,122 ( 0.04%)  38 ( 0.03%)     561 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["chat"] = serializedChat;
 16,269 ( 0.00%) 1,122 ( 0.04%) 128 ( 0.10%)   1,683 ( 0.00%)     0            0            4,488 ( 0.01%)  0          0               p["maxPlayers"] = QJsonValue(m_maxPlayers);
      .              .            .                .              .            .                .           .          .           
  1,122 ( 0.00%)     0            0                0              0            0                0           0          0               return p;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           
 12,342 ( 0.00%) 1,683 ( 0.06%)   7 ( 0.01%)   3,366 ( 0.00%)    38 ( 0.01%)  37 ( 0.04%)   2,805 ( 0.00%)  0          0           }
      .              .            .                .              .            .                .           .          .           Game* Game::fromJson(const QJsonObject& o){
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               int prevNarratorCard = o["prevCard"].toInt();
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               int voteCounter = o["voteCounter"].toInt();
      .              .            .                .              .            .                .           .          .               int choiceCounter = o["choiceCounter"].toInt();
      .              .            .                .              .            .                .           .          .               bool isOver = o["isOver"].toBool();
      .              .            .                .              .            .                .           .          .               int id = o["id"].toInt();
-- line 386 ----------------------------------------
-- line 447 ----------------------------------------
      .              .            .                .              .            .                .           .          .               g->m_isGameStarted = isGameStarted;
      .              .            .                .              .            .                .           .          .               g->m_voteCounter = voteCounter;
      .              .            .                .              .            .                .           .          .               g->m_choiceCounter = choiceCounter;
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               return g;
      .              .            .                .              .            .                .           .          .           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           std::string gamePhaseToStr(GamePhase gamePhase)
  5,610 ( 0.00%)   561 ( 0.02%)  28 ( 0.02%)     561 ( 0.00%)     0            0            2,805 ( 0.00%)  0          0           {
  2,914 ( 0.00%)   395 ( 0.01%)  97 ( 0.08%)   1,457 ( 0.00%)     0            0                0           0          0               switch (gamePhase) {
  3,468 ( 0.00%)   289 ( 0.01%)   2 ( 0.00%)     289 ( 0.00%)     0            0              867 ( 0.00%)  0          0                   case GamePhase::NARRATOR_CHOICE :  return "NARRATOR_CHOICE";
  1,992 ( 0.00%)   166 ( 0.01%)   3 ( 0.00%)     166 ( 0.00%)     0            0              498 ( 0.00%)  0          0                   case GamePhase::PLAYERS_VOTE    :  return "PLAYERS_VOTE";
  1,272 ( 0.00%)   106 ( 0.00%)   4 ( 0.00%)     106 ( 0.00%)     0            0              318 ( 0.00%)  0          0                   case GamePhase::PLAYERS_CHOOSE  :  return "PLAYERS_CHOOSE";
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .                   default:
      .              .            .                .              .            .                .           .          .                       break;
      .              .            .                .              .            .                .           .          .               }
      .              .            .                .              .            .                .           .          .               return "";
  4,488 ( 0.00%)   716 ( 0.03%)   4 ( 0.00%)   3,366 ( 0.00%)     0            0                0           0          0           }
      .              .            .                .              .            .                .           .          .           GamePhase strToGamePhase(const std::string strGamePhase){
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .               if(strGamePhase == "NARRATOR_CHOICE")
      .              .            .                .              .            .                .           .          .                   return GamePhase::NARRATOR_CHOICE;
      .              .            .                .              .            .                .           .          .               else if(strGamePhase == "PLAYERS_VOTE")
      .              .            .                .              .            .                .           .          .                   return GamePhase::PLAYERS_VOTE;
      .              .            .                .              .            .                .           .          .               else if(strGamePhase == "PLAYERS_CHOOSE")
      .              .            .                .              .            .                .           .          .                   return GamePhase::PLAYERS_CHOOSE;
      .              .            .                .              .            .                .           .          .               else
      .              .            .                .              .            .                .           .          .                   return GamePhase::NARRATOR_CHOICE; //proveriti sta u ovom slucaju!
      .              .            .                .              .            .                .           .          .           }
      .              .            .                .              .            .                .           .          .           
      .              .            .                .              .            .                .           .          .           
  5,610 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)     561 ( 0.00%)     0            0            2,805 ( 0.00%)  1 ( 0.00%) 1 ( 0.00%)  std::string Game::toJsonString(){
  7,293 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)     561 ( 0.00%)     0            0            1,683 ( 0.00%)  0          0               QJsonDocument doc = QJsonDocument(toJson());
  2,805 ( 0.00%)     0            0                0              0            0              561 ( 0.00%)  0          0               QByteArray data = QByteArray(doc.toJson());
  2,805 ( 0.00%)     0            0              561 ( 0.00%)     0            0              561 ( 0.00%)  0          0               std::string dataString = data.toStdString();
  1,122 ( 0.00%)     0            0                0              0            0                0           0          0               return dataString;
  7,293 ( 0.00%)   563 ( 0.02%)  54 ( 0.04%)   3,366 ( 0.00%)   120 ( 0.03%)  28 ( 0.03%)   1,122 ( 0.00%)  0          0           }
      .              .            .                .              .            .                .           .          .           
      5 ( 0.00%)     1 ( 0.00%)   0                0              0            0                3 ( 0.00%)  0          0           void Game::setGameId(int newId){
      3 ( 0.00%)     0            0                2 ( 0.00%)     0            0                1 ( 0.00%)  0          0               m_gameID = newId;
     24 ( 0.00%)     3 ( 0.00%)   3 ( 0.00%)       8 ( 0.00%)     0            0                5 ( 0.00%)  0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/andrijanabos/Desktop/02-moxit-mock-dixit/backend/src/lib/server/moxit_server.cpp
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr         DLmr         Dw               D1mw         DLmw         

      .              .            .                .            .            .                .            .            .           #include "moxit_server.h"
      .              .            .                .            .            .                .            .            .           
      5 ( 0.00%)     0            0                0            0            0                2 ( 0.00%)   0            0           void log(const std::string &message) {
      9 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       3 ( 0.00%)   0            0                2 ( 0.00%)   0            0               std::cout << message << std::endl;
      3 ( 0.00%)     0            0                2 ( 0.00%)   0            0                0            0            0           }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .           void closeWithError(const std::string &errorMessage) {
      .              .            .                .            .            .                .            .            .               log("Error: " + errorMessage);
      .              .            .                .            .            .                .            .            .               exit(EXIT_FAILURE);
      .              .            .                .            .            .                .            .            .           }
      .              .            .                .            .            .                .            .            .           
      8 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                5 ( 0.00%)   0            0           MoxitServer::MoxitServer(std::string ip_address, int port)
      5 ( 0.00%)     0            0                2 ( 0.00%)   0            0                1 ( 0.00%)   0            0               : m_ip_address(ip_address),
      3 ( 0.00%)     0            0                2 ( 0.00%)   0            0                1 ( 0.00%)   1 ( 0.00%)   1 ( 0.00%)        m_port(port),
      2 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)   0            0                1 ( 0.00%)   0            0                 m_socket(),
      3 ( 0.00%)     0            0                1 ( 0.00%)   0            0                2 ( 0.00%)   1 ( 0.00%)   1 ( 0.00%)        m_socketAddress(),
      2 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)   0            0                1 ( 0.00%)   0            0                 m_socketAddress_length(sizeof(m_socketAddress)),
      2 ( 0.00%)     0            0                1 ( 0.00%)   0            0                1 ( 0.00%)   0            0                 m_running(false),
      2 ( 0.00%)     0            0                1 ( 0.00%)   0            0                1 ( 0.00%)   0            0                 m_epfd(),
  6,150 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)   0            0            2,048 ( 0.00%) 161 ( 0.07%) 152 ( 0.19%)        m_evlist(),
     22 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       6 ( 0.00%)   0            0                6 ( 0.00%)   0            0                 m_numOfClients(0)
      .              .            .                .            .            .                .            .            .           {   
      2 ( 0.00%)     0            0                1 ( 0.00%)   0            0                1 ( 0.00%)   0            0               this->m_socketAddress.sin_family = AF_INET;
      6 ( 0.00%)     0            0                2 ( 0.00%)   0            0                2 ( 0.00%)   0            0               this->m_socketAddress.sin_port = htons(port);
      7 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       2 ( 0.00%)   0            0                3 ( 0.00%)   0            0               this->m_socketAddress.sin_addr.s_addr = inet_addr(ip_address.c_str());
      .              .            .                .            .            .                .            .            .           
      3 ( 0.00%)     0            0                0            0            0                1 ( 0.00%)   0            0               signal(SIGPIPE, SIG_IGN);
      .              .            .                .            .            .                .            .            .           
      3 ( 0.00%)     0            0                1 ( 0.00%)   0            0                1 ( 0.00%)   0            0               this->startServer();
      4 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       3 ( 0.00%)   0            0                0            0            0           }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .           MoxitServer::~MoxitServer() {
      .              .            .                .            .            .                .            .            .               this->closeServer();
      .              .            .                .            .            .                .            .            .           }
      .              .            .                .            .            .                .            .            .           
      9 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       1 ( 0.00%)   0            0                4 ( 0.00%)   0            0           int MoxitServer::startServer() {
      6 ( 0.00%)     0            0                1 ( 0.00%)   0            0                2 ( 0.00%)   0            0               this->m_socket = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
      4 ( 0.00%)     0            0                2 ( 0.00%)   0            0                0            0            0               if(this->m_socket < 0) {
      .              .            .                .            .            .                .            .            .                   closeWithError("Cannot create socket.");
      .              .            .                .            .            .                .            .            .                   return 1;
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
      1 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                1 ( 0.00%)   0            0               const int opt = 1;
     12 ( 0.00%)     0            0                2 ( 0.00%)   0            0                1 ( 0.00%)   0            0               if(setsockopt(m_socket, SOL_SOCKET, SO_REUSEADDR, (const char*) &opt, sizeof(opt)) < 0) {
      .              .            .                .            .            .                .            .            .                   closeWithError("Cannot set reuse address.");
      .              .            .                .            .            .                .            .            .                   return 1;
      .              .            .                .            .            .                .            .            .               }
     12 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       2 ( 0.00%)   0            0                1 ( 0.00%)   0            0               if(setsockopt(m_socket, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt)) < 0) {
      .              .            .                .            .            .                .            .            .                   closeWithError("Cannot set reuse port.");
      .              .            .                .            .            .                .            .            .                   return 1;
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
     12 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       5 ( 0.00%)   0            0                1 ( 0.00%)   0            0               if(bind(m_socket, (sockaddr*) &m_socketAddress, m_socketAddress_length) < 0) {
      .              .            .                .            .            .                .            .            .                   closeWithError("Cannot bind socket.");
      .              .            .                .            .            .                .            .            .                   return 1;
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
      1 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                0            0            0               return 0;
      6 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       5 ( 0.00%)   0            0                0            0            0           }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .           void MoxitServer::closeServer() {
      .              .            .                .            .            .                .            .            .               m_running = false;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               for(int i = 0 ; i < k_threadPoolSize ; i++) {
      .              .            .                .            .            .                .            .            .                   //m_worker_threads[i].join();
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
-- line 67 ----------------------------------------
-- line 73 ----------------------------------------
      .              .            .                .            .            .                .            .            .                   close(m_clientSocketFds[i]);
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               close(this->m_socket);
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               exit(EXIT_SUCCESS);
      .              .            .                .            .            .                .            .            .           }
      .              .            .                .            .            .                .            .            .           
      9 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       1 ( 0.00%)   0            0                4 ( 0.00%)   0            0           void MoxitServer::startListen() {
      3 ( 0.00%)     0            0                1 ( 0.00%)   0            0                1 ( 0.00%)   0            0               addHandlers();
      .              .            .                .            .            .                .            .            .           
      8 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       2 ( 0.00%)   1 ( 0.00%)   0                1 ( 0.00%)   0            0               if(listen(m_socket, k_backlogSize) < 0) {
      .              .            .                .            .            .                .            .            .                   closeWithError("Cannot listen.");
      .              .            .                .            .            .                .            .            .                   exit(EXIT_FAILURE);
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
      3 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                1 ( 0.00%)   0            0               std::ostringstream ss;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               ss << "\n*** Listening on ADDRESS: "
      4 ( 0.00%)     0            0                2 ( 0.00%)   1 ( 0.00%)   0                1 ( 0.00%)   0            0                       << inet_ntoa(m_socketAddress.sin_addr)
     25 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       2 ( 0.00%)   1 ( 0.00%)   0                5 ( 0.00%)   0            0                       << " PORT: " << ntohs(m_socketAddress.sin_port)
      4 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                1 ( 0.00%)   0            0                       << " ***\n\n";
      .              .            .                .            .            .                .            .            .           
     11 ( 0.00%)     0            0                0            0            0                3 ( 0.00%)   0            0               log(ss.str());
      .              .            .                .            .            .                .            .            .           
      3 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)   0            0                1 ( 0.00%)   0            0               setUpEpoll();
      .              .            .                .            .            .                .            .            .           
      2 ( 0.00%)     0            0                1 ( 0.00%)   0            0                1 ( 0.00%)   0            0               m_running = true;
      .              .            .                .            .            .                .            .            .           
     13 ( 0.00%)     0            0                7 ( 0.00%)   0            0                1 ( 0.00%)   0            0               for(int i = 0 ; i < k_threadPoolSize ; i++) {
      .              .            .                .            .            .                .            .            .                   //m_worker_threads.push_back(std::thread(&MoxitServer::startWorkerThread, this));
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
      3 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)   0            0                1 ( 0.00%)   0            0               startWorkerThread();
      .              .            .                .            .            .                .            .            .           }
      .              .            .                .            .            .                .            .            .           
      9 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       1 ( 0.00%)   0            0                4 ( 0.00%)   0            0           void MoxitServer::setUpEpoll() {
      4 ( 0.00%)     0            0                1 ( 0.00%)   0            0                2 ( 0.00%)   1 ( 0.00%)   0               m_epfd = epoll_create(1024);
      4 ( 0.00%)     0            0                2 ( 0.00%)   0            0                0            0            0               if(m_epfd < 0) {
      .              .            .                .            .            .                .            .            .                   closeWithError("Epoll_create error.");
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
      2 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                2 ( 0.00%)   0            0               struct epoll_event event{};
      1 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                1 ( 0.00%)   0            0               event.events = EPOLLIN;
      3 ( 0.00%)     0            0                2 ( 0.00%)   0            0                1 ( 0.00%)   0            0               event.data.fd = m_socket;
      .              .            .                .            .            .                .            .            .           
     11 ( 0.00%)     0            0                4 ( 0.00%)   0            0                1 ( 0.00%)   0            0               if(epoll_ctl(m_epfd, EPOLL_CTL_ADD, m_socket, &event) < 0) {
      .              .            .                .            .            .                .            .            .                   closeWithError("Epoll_ctl error.");
      .              .            .                .            .            .                .            .            .               }
      7 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       5 ( 0.00%)   0            0                0            0            0           }
      .              .            .                .            .            .                .            .            .           
  5,610 ( 0.00%)   456 ( 0.02%)  66 ( 0.05%)     561 ( 0.00%)   0            0            2,805 ( 0.00%)   0            0           int MoxitServer::acceptConnection() {
  1,122 ( 0.00%)   457 ( 0.02%)   1 ( 0.00%)       0            0            0            1,122 ( 0.00%)   0            0               sockaddr_in client = {};
    561 ( 0.00%)     0            0                0            0            0              561 ( 0.00%)   0            0               socklen_t len = sizeof(client);
      .              .            .                .            .            .                .            .            .           
  4,488 ( 0.00%)     0            0            1,122 ( 0.00%)   0            0            1,122 ( 0.00%)   0            0               int new_socket = accept4(m_socket, (sockaddr*) &client, &len, SOCK_NONBLOCK);
      .              .            .                .            .            .                .            .            .           
  1,122 ( 0.00%)   457 ( 0.02%)   3 ( 0.00%)     561 ( 0.00%)   0            0                0            0            0               if(new_socket < 0) {
      .              .            .                .            .            .                .            .            .                   std::ostringstream ss;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   ss << "Server failed to accept incoming connection from ADDRESS: "
      .              .            .                .            .            .                .            .            .                   << inet_ntoa(m_socketAddress.sin_addr) << "; PORT: "
      .              .            .                .            .            .                .            .            .                   << ntohs(m_socketAddress.sin_port);
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   closeWithError(ss.str());
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
  1,683 ( 0.00%)   430 ( 0.02%)   1 ( 0.00%)       0            0            0            1,122 ( 0.00%)   0            0               struct epoll_event *event = new struct epoll_event;
      .              .            .                .            .            .                .            .            .           
  5,049 ( 0.00%)   457 ( 0.02%)  87 ( 0.07%)     561 ( 0.00%)   0            0            1,683 ( 0.00%)   0            0               HttpStatus *httpStatus = new HttpStatus(REQUEST_STATUS::Reading, new_socket);
      .              .            .                .            .            .                .            .            .           
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0              561 ( 0.00%)   0            0               event->events = EPOLLIN;
  1,683 ( 0.00%)     0            0            1,122 ( 0.00%)   0            0              561 ( 0.00%)   0            0               event->data.ptr = static_cast<void*>(httpStatus);
      .              .            .                .            .            .                .            .            .           
  5,610 ( 0.00%)   457 ( 0.02%)   6 ( 0.00%)   2,244 ( 0.00%)   0            0              561 ( 0.00%)   0            0               if(epoll_ctl(m_epfd, EPOLL_CTL_ADD, new_socket, event) < 0) {
      .              .            .                .            .            .                .            .            .                   closeWithError("Epoll_ctl error.");
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
    561 ( 0.00%)   457 ( 0.02%)  27 ( 0.02%)     561 ( 0.00%)   0            0                0            0            0               return new_socket;
  4,488 ( 0.00%)   913 ( 0.03%)  13 ( 0.01%)   3,366 ( 0.00%)   0            0                0            0            0           }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .           
      9 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       1 ( 0.00%)   0            0                4 ( 0.00%)   0            0           void MoxitServer::startWorkerThread() {
  5,825 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)   2,912 ( 0.00%)   2 ( 0.00%)   0                0            0            0               while(m_running) {
 13,103 ( 0.00%)     4 ( 0.00%)   2 ( 0.00%)   4,368 ( 0.00%)   0            0            2,911 ( 0.00%)   0            0                   int numOfFds = epoll_wait(m_epfd, m_evlist, 1024, 2000);
  2,910 ( 0.00%)     0            0            1,455 ( 0.00%)   0            0                0            0            0                   if(numOfFds < 0) {
      .              .            .                .            .            .                .            .            .                       closeWithError("Epoll_wait error.");
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
 14,007 ( 0.00%)     6 ( 0.00%)   5 ( 0.00%)   7,959 ( 0.01%)   0            0            1,455 ( 0.00%)   0            0                   for(int i = 0 ; i < numOfFds ; i++) {
 23,562 ( 0.01%)     2 ( 0.00%)   1 ( 0.00%)   8,415 ( 0.01%) 562 ( 0.12%) 154 ( 0.15%)       0            0            0                       if(m_evlist[i].data.fd == m_socket) {
  2,244 ( 0.00%)     0            0              561 ( 0.00%)   0            0            1,122 ( 0.00%)   0            0                           int new_client = acceptConnection();
  2,805 ( 0.00%)     0            0            1,683 ( 0.00%) 167 ( 0.04%)  95 ( 0.09%)     561 ( 0.00%)   0            0                           m_numOfClients++;
  3,927 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)     561 ( 0.00%)   0            0              561 ( 0.00%)   0            0                           m_clientSocketFds.push_back(new_client);
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .                       else {
 12,342 ( 0.00%)     1 ( 0.00%)   0            3,366 ( 0.00%)   0            0            1,122 ( 0.00%)   0            0                           HttpStatus *httpStatus = reinterpret_cast<HttpStatus*>(m_evlist[i].data.ptr);
      .              .            .                .            .            .                .            .            .           
  3,366 ( 0.00%)   280 ( 0.01%)   6 ( 0.00%)   2,244 ( 0.00%) 125 ( 0.03%)  25 ( 0.02%)   1,122 ( 0.00%)   0            0                           int client = httpStatus->m_client_fd;
      .              .            .                .            .            .                .            .            .           
  4,488 ( 0.00%)     0            0            2,244 ( 0.00%)  50 ( 0.01%)  16 ( 0.02%)       0            0            0                           if(httpStatus->m_req_status == REQUEST_STATUS::Reading) {
  3,927 ( 0.00%)     0            0            1,683 ( 0.00%)   0            0            1,122 ( 0.00%)   0            0                               int readingFinished = readFromClient(client, httpStatus);
      .              .            .                .            .            .                .            .            .           
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0                0            0            0                               if(readingFinished == true) {
  3,927 ( 0.00%)     6 ( 0.00%)   5 ( 0.00%)   1,683 ( 0.00%)   0            0              561 ( 0.00%)   0            0                                   processConnection(client, httpStatus);
      .              .            .                .            .            .                .            .            .                               }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                               else if(readingFinished == false){
      .              .            .                .            .            .                .            .            .                                   m_evlist[i].events = EPOLLIN;
      .              .            .                .            .            .                .            .            .                                   m_evlist[i].data.ptr = static_cast<void*>(httpStatus);
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                                   if(epoll_ctl(m_epfd, EPOLL_CTL_MOD, httpStatus->m_client_fd, &m_evlist[i]) < 0) {
      .              .            .                .            .            .                .            .            .                                       closeWithError("Epoll_ctl_del error.");
-- line 185 ----------------------------------------
-- line 186 ----------------------------------------
      .              .            .                .            .            .                .            .            .                                   }
      .              .            .                .            .            .                .            .            .                               }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                               else if(readingFinished == -1) {
      .              .            .                .            .            .                .            .            .                                   httpStatus->m_req_status = REQUEST_STATUS::Ended;
      .              .            .                .            .            .                .            .            .                               }
      .              .            .                .            .            .                .            .            .                           }
      .              .            .                .            .            .                .            .            .           
  2,244 ( 0.00%)   547 ( 0.02%)   8 ( 0.01%)   1,122 ( 0.00%)   0            0                0            0            0                           else if(httpStatus->m_req_status == REQUEST_STATUS::Writing) {
  3,366 ( 0.00%)     0            0            1,122 ( 0.00%)   0            0            1,122 ( 0.00%)   0            0                               bool writingFinished = writeToClient(httpStatus);
      .              .            .                .            .            .                .            .            .           
  1,122 ( 0.00%)   547 ( 0.02%)   4 ( 0.00%)     561 ( 0.00%)   0            0                0            0            0                               if(writingFinished) {
      .              .            .                .            .            .                .            .            .           
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0              561 ( 0.00%)   0            0                                   httpStatus->m_req_status = REQUEST_STATUS::Ended;
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0              561 ( 0.00%)   0            0                                   httpStatus->m_sent_bytes = 0;
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0              561 ( 0.00%)   0            0                                   httpStatus->m_read_body_bytes = 0;
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0              561 ( 0.00%)   0            0                                   httpStatus->m_read_header_bytes = 0;
  3,366 ( 0.00%)   547 ( 0.02%)   1 ( 0.00%)     561 ( 0.00%)   0            0            1,122 ( 0.00%)  22 ( 0.01%)   0                                   httpStatus->m_buffer[0] = '\0';
      .              .            .                .            .            .                .            .            .           
 11,220 ( 0.00%)   547 ( 0.02%)   8 ( 0.01%)   3,366 ( 0.00%)   0            0              561 ( 0.00%)   0            0                                   if(epoll_ctl(m_epfd, EPOLL_CTL_DEL, httpStatus->m_client_fd, &m_evlist[i]) < 0) {
      .              .            .                .            .            .                .            .            .                                       closeWithError("Epoll_ctl error.");
      .              .            .                .            .            .                .            .            .                                   }
      .              .            .                .            .            .                .            .            .           
  3,927 ( 0.00%)   547 ( 0.02%)  36 ( 0.03%)   1,122 ( 0.00%)   0            0              561 ( 0.00%)   0            0                                   if(close(httpStatus->m_client_fd) < 0) {
      .              .            .                .            .            .                .            .            .                                       closeWithError("Epoll fd close error");
      .              .            .                .            .            .                .            .            .                                   }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                               }
      .              .            .                .            .            .                .            .            .                               else {
      .              .            .                .            .            .                .            .            .                                   m_evlist[i].events = EPOLLOUT;
      .              .            .                .            .            .                .            .            .                                   //m_evlist[i].data.ptr = static_cast<void*>(httpStatus);
      .              .            .                .            .            .                .            .            .           
-- line 217 ----------------------------------------
-- line 221 ----------------------------------------
      .              .            .                .            .            .                .            .            .                               }
      .              .            .                .            .            .                .            .            .                           }
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           }
      .              .            .                .            .            .                .            .            .           
  6,171 ( 0.00%)    17 ( 0.00%)   1 ( 0.00%)     561 ( 0.00%)   0            0            3,366 ( 0.00%)   0            0           int MoxitServer::readFromClient(int client, HttpStatus *httpStatus) {
  1,683 ( 0.00%)   561 ( 0.02%)   2 ( 0.00%)       0            0            0              561 ( 0.00%)   0            0               std::string bufferStr;
  4,488 ( 0.00%)     0            0            1,683 ( 0.00%)   0            0              561 ( 0.00%)   0            0               bufferStr.append(httpStatus->m_buffer, httpStatus->m_read_body_bytes);
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               while(true) {
451,535 ( 0.10%)   561 ( 0.02%)   3 ( 0.00%)       0            0            0          434,560 ( 0.63%)  55 ( 0.02%)   1 ( 0.00%)          char buffer[1024] = {};
 23,765 ( 0.01%)   561 ( 0.02%)  17 ( 0.01%)   3,395 ( 0.00%)   0            0            6,790 ( 0.01%)   0            0                   ssize_t readBytes = recv(client, buffer, 50, 0);
      .              .            .                .            .            .                .            .            .           
  6,790 ( 0.00%)     0            0            3,395 ( 0.00%)   0            0                0            0            0                   if(readBytes > 0) {
 17,004 ( 0.00%)     0            0            2,834 ( 0.00%)   0            0            2,834 ( 0.00%)   0            0                       bufferStr.append(buffer, readBytes);
 19,838 ( 0.00%)   561 ( 0.02%)   6 ( 0.00%)  11,336 ( 0.01%)  15 ( 0.00%)   0            2,834 ( 0.00%)   0            0                       httpStatus->m_read_body_bytes += readBytes;
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0                0            0            0                   else if(readBytes == 0) { //Client closed connection
      .              .            .                .            .            .                .            .            .                       return -1;
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   else { //readBytes < 0
  2,244 ( 0.00%)     0            0              561 ( 0.00%)   0            0              561 ( 0.00%)   0            0                       if(errno == EAGAIN || errno == EWOULDBLOCK) { //Source temporary unavailable
  3,927 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)       0            0            0            1,122 ( 0.00%)   0            0                           auto emptyLinePos = bufferStr.find("\r\n\r\n");
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0                0            0            0                           if(emptyLinePos != std::string::npos) {
  1,683 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)   1,122 ( 0.00%)   0            0              561 ( 0.00%)   0            0                               httpStatus->m_read_header_bytes = emptyLinePos;
  5,049 ( 0.00%)     0            0            2,805 ( 0.00%)   0            0              561 ( 0.00%)   0            0                               httpStatus->m_read_body_bytes -= (httpStatus->m_read_header_bytes + 4);
      .              .            .                .            .            .                .            .            .           
  3,366 ( 0.00%)   561 ( 0.02%)   2 ( 0.00%)     561 ( 0.00%)   0            0              561 ( 0.00%)   0            0                               httpStatus->m_buffer = bufferStr;
      .              .            .                .            .            .                .            .            .           
  1,122 ( 0.00%)     0            0                0            0            0                0            0            0                               return true;
      .              .            .                .            .            .                .            .            .                           }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                           break;
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                       else {
      .              .            .                .            .            .                .            .            .                           closeWithError("recv error");
      .              .            .                .            .            .                .            .            .                           break;
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               httpStatus->m_buffer = bufferStr;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               return true;
  5,610 ( 0.00%)   576 ( 0.02%)   3 ( 0.00%)   2,805 ( 0.00%)   1 ( 0.00%)   0              561 ( 0.00%)   0            0           }
      .              .            .                .            .            .                .            .            .           
  3,366 ( 0.00%)   547 ( 0.02%)   4 ( 0.00%)       0            0            0            1,683 ( 0.00%)   0            0           bool MoxitServer::writeToClient(HttpStatus *httpStatus) {
    561 ( 0.00%)     0            0                0            0            0              561 ( 0.00%)   0            0               size_t MAX_BYTES_TO_SEND = 50;
    561 ( 0.00%)     0            0                0            0            0              561 ( 0.00%)   0            0               bool ind = false;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               while(true) {
108,528 ( 0.03%)     0            0           54,264 ( 0.05%)   0            0                0            0            0                   if(ind) {
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0              561 ( 0.00%)   0            0                       httpStatus->m_req_status = REQUEST_STATUS::Ended;
  1,122 ( 0.00%)     0            0                0            0            0                0            0            0                       return true;
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
214,812 ( 0.05%)   547 ( 0.02%)   6 ( 0.00%) 161,109 ( 0.15%)   0            0                0            0            0                   if(httpStatus->m_left_to_send < MAX_BYTES_TO_SEND) {
  1,683 ( 0.00%)     0            0            1,122 ( 0.00%)   0            0              561 ( 0.00%)   0            0                       MAX_BYTES_TO_SEND = httpStatus->m_left_to_send;
    561 ( 0.00%)     0            0                0            0            0              561 ( 0.00%)   0            0                       ind = true;
      .              .            .                .            .            .                .            .            .                   }
375,921 ( 0.09%)     0            0          161,109 ( 0.15%)   0            0          107,406 ( 0.16%)   0            0                   ssize_t sendBytes = send(httpStatus->m_client_fd,
429,624 ( 0.10%)   547 ( 0.02%)   1 ( 0.00%) 161,109 ( 0.15%)   0            0           53,703 ( 0.08%)   0            0                                            &httpStatus->m_buffer.c_str()[httpStatus->m_sent_bytes],
      .              .            .                .            .            .                .            .            .                                            MAX_BYTES_TO_SEND, 0);
      .              .            .                .            .            .                .            .            .           
107,406 ( 0.02%)     0            0           53,703 ( 0.05%)   0            0                0            0            0                   if(sendBytes > 0) {
322,218 ( 0.07%)   547 ( 0.02%)   8 ( 0.01%) 214,812 ( 0.19%)   0            0           53,703 ( 0.08%)   0            0                       httpStatus->m_sent_bytes += sendBytes;
429,624 ( 0.10%)     0            0          214,812 ( 0.19%)   0            0           53,703 ( 0.08%)   0            0                       httpStatus->m_left_to_send -= sendBytes;
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   else if(sendBytes == 0) { //Client closed connection
      .              .            .                .            .            .                .            .            .                       break;
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   else { //sendBytes < 0
      .              .            .                .            .            .                .            .            .                       if(errno == EAGAIN || errno == EWOULDBLOCK) { //Source temporary unavailable
-- line 301 ----------------------------------------
-- line 306 ----------------------------------------
      .              .            .                .            .            .                .            .            .                           //closeWithError("send error");
      .              .            .                .            .            .                .            .            .                           return true;
      .              .            .                .            .            .                .            .            .                           break;
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               return false;
  1,122 ( 0.00%)   547 ( 0.02%) 137 ( 0.11%)   1,122 ( 0.00%)   0            0                0            0            0           }
      .              .            .                .            .            .                .            .            .           
  6,732 ( 0.00%)   576 ( 0.02%)  18 ( 0.01%)     561 ( 0.00%)   0            0            3,927 ( 0.01%)   0            0           void MoxitServer::processConnection(int socket, HttpStatus *httpStatus) const {
  1,683 ( 0.00%)     0            0                0            0            0              561 ( 0.00%)   0            0               std::string headerStr;
  1,683 ( 0.00%)     0            0                0            0            0              561 ( 0.00%)   0            0               std::string bodyStr;
      .              .            .                .            .            .                .            .            .           
  5,049 ( 0.00%)   561 ( 0.02%)   4 ( 0.00%)   1,683 ( 0.00%)   1 ( 0.00%)   0              561 ( 0.00%)   0            0               headerStr.append(httpStatus->m_buffer, 0, httpStatus->m_read_header_bytes);
  6,732 ( 0.00%)   561 ( 0.02%)   3 ( 0.00%)   2,805 ( 0.00%)   3 ( 0.00%)   0              561 ( 0.00%)   0            0               bodyStr.append(httpStatus->m_buffer, httpStatus->m_read_header_bytes + 4,
      .              .            .                .            .            .                .            .            .                              httpStatus->m_read_body_bytes);
      .              .            .                .            .            .                .            .            .           
  2,805 ( 0.00%)     0            0                0            0            0              561 ( 0.00%)   0            0               auto reqHeader = RequestHeader::parse(headerStr);
      .              .            .                .            .            .                .            .            .           
  2,805 ( 0.00%)   561 ( 0.02%)   0              561 ( 0.00%)   0            0              561 ( 0.00%)   0            0               Response res = Response(socket);
      .              .            .                .            .            .                .            .            .           
    561 ( 0.00%)   561 ( 0.02%)   2 ( 0.00%)       0            0            0              561 ( 0.00%)   0            0               bool ind = false;
 59,285 ( 0.01%) 1,152 ( 0.04%)  16 ( 0.01%)   1,683 ( 0.00%)   0            0           17,740 ( 0.03%) 102 ( 0.04%)   0               for(const auto &handler: m_handlers) {
 58,110 ( 0.01%)   561 ( 0.02%)   2 ( 0.00%)   3,874 ( 0.00%)   0            0           11,622 ( 0.02%)   0            0                   if(handler.is(reqHeader.getMethod(), reqHeader.getPath())) {
 12,903 ( 0.00%) 2,244 ( 0.08%) 123 ( 0.10%)   1,122 ( 0.00%)  74 ( 0.02%)   0            2,805 ( 0.00%)   0            0                       handler.call(Request(reqHeader, bodyStr, socket), res);
    561 ( 0.00%)     0            0                0            0            0              561 ( 0.00%)   0            0                       ind = true;
    561 ( 0.00%)     0            0                0            0            0                0            0            0                       break;
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .               }
      .              .            .                .            .            .                .            .            .           
  2,244 ( 0.00%)   561 ( 0.02%)  91 ( 0.07%)     561 ( 0.00%)   0            0                0            0            0               if(!ind) {
      .              .            .                .            .            .                .            .            .                   std::string response = res.sendStatus(404);
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   struct epoll_event event;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   HttpStatus *httpStatus = new HttpStatus(REQUEST_STATUS::Writing, socket);
      .              .            .                .            .            .                .            .            .                   event.events = EPOLLOUT;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   httpStatus->m_left_to_send = response.size();
-- line 345 ----------------------------------------
-- line 346 ----------------------------------------
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   httpStatus->m_buffer = response;
      .              .            .                .            .            .                .            .            .                   event.data.ptr = static_cast<void*>(httpStatus);
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   if(epoll_ctl(m_epfd, EPOLL_CTL_MOD, socket, &event) < 0) {
      .              .            .                .            .            .                .            .            .                           closeWithError("Epoll_ctl error.");
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .               }
 11,220 ( 0.00%) 1,683 ( 0.06%)  45 ( 0.04%)   3,366 ( 0.00%) 559 ( 0.12%) 354 ( 0.35%)   2,244 ( 0.00%)   0            0           }
      .              .            .                .            .            .                .            .            .           
     77 ( 0.00%)    12 ( 0.00%)   2 ( 0.00%)       0            0            0               44 ( 0.00%)   0            0           MoxitServer& MoxitServer::post(const std::string &path, const HandlerType &handler) {
     66 ( 0.00%)     0            0               33 ( 0.00%)   0            0               11 ( 0.00%)   0            0               return this->use(Method::POST, path, handler);
     22 ( 0.00%)    11 ( 0.00%)   0               22 ( 0.00%)   0            0                0            0            0           }
      .              .            .                .            .            .                .            .            .           
    132 ( 0.00%)    11 ( 0.00%)   1 ( 0.00%)      11 ( 0.00%)   0            0               77 ( 0.00%)   0            0           MoxitServer& MoxitServer::use(Method method, const std::string &path, const HandlerType &handler) {
    154 ( 0.00%)    12 ( 0.00%)   1 ( 0.00%)      33 ( 0.00%)   0            0               33 ( 0.00%)   0            0               Handler h = Handler(method, path, handler);
     66 ( 0.00%)     0            0               11 ( 0.00%)   0            0               11 ( 0.00%)   0            0               m_handlers.emplace_back(h);
     22 ( 0.00%)    11 ( 0.00%)   1 ( 0.00%)      11 ( 0.00%)   0            0                0            0            0               return *this;
     99 ( 0.00%)    11 ( 0.00%)   1 ( 0.00%)      55 ( 0.00%)   0            0               11 ( 0.00%)   0            0           }
      .              .            .                .            .            .                .            .            .           
  6,732 ( 0.00%) 1,122 ( 0.04%)   6 ( 0.00%)     561 ( 0.00%)   0            0            3,927 ( 0.01%)   0            0           void MoxitServer::addEpollWriteEvent(const Request& request ,const std::string& response) {
  1,683 ( 0.00%)     0            0                0            0            0            1,122 ( 0.00%)   0            0               struct epoll_event *event = new struct epoll_event;
  2,244 ( 0.00%)     0            0              561 ( 0.00%)   0            0            1,122 ( 0.00%)   0            0               int socket_fd = request.getSocketFd();
      .              .            .                .            .            .                .            .            .           
  5,049 ( 0.00%)   561 ( 0.02%)   3 ( 0.00%)     561 ( 0.00%)   0            0            1,683 ( 0.00%)   0            0               HttpStatus *httpStatus = new HttpStatus(REQUEST_STATUS::Writing, socket_fd);
  1,122 ( 0.00%)     0            0              561 ( 0.00%)   0            0              561 ( 0.00%)   1 ( 0.00%)   0               event->events = EPOLLOUT;
      .              .            .                .            .            .                .            .            .           
  2,805 ( 0.00%)     0            0            1,122 ( 0.00%)   0            0            1,122 ( 0.00%)   0            0               httpStatus->m_left_to_send = response.size();
  3,366 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)   1,122 ( 0.00%)   0            0              561 ( 0.00%)   0            0               httpStatus->m_buffer = response;
      .              .            .                .            .            .                .            .            .           
  1,683 ( 0.00%)     0            0            1,122 ( 0.00%)  15 ( 0.00%)   4 ( 0.00%)     561 ( 0.00%)  21 ( 0.01%)   0               event->data.ptr = static_cast<void*>(httpStatus);
      .              .            .                .            .            .                .            .            .           
  5,610 ( 0.00%)     0            0            2,244 ( 0.00%) 523 ( 0.11%)  20 ( 0.02%)     561 ( 0.00%)   0            0               if(epoll_ctl(m_epfd, EPOLL_CTL_MOD, socket_fd, event) < 0) {
      .              .            .                .            .            .                .            .            .                   closeWithError("Epoll_ctl error.");
      .              .            .                .            .            .                .            .            .               }
  5,049 ( 0.00%)   561 ( 0.02%)  50 ( 0.04%)   3,366 ( 0.00%)  23 ( 0.00%)   6 ( 0.01%)       0            0            0           }
      .              .            .                .            .            .                .            .            .           
      9 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       1 ( 0.00%)   0            0                4 ( 0.00%)   0            0           void MoxitServer::addHandlers() {
     31 ( 0.00%)     3 ( 0.00%)   2 ( 0.00%)       2 ( 0.00%)   0            0                8 ( 0.00%)   0            0               this->post("/", [this] (const Request &req, Response res) {
      .              .            .                .            .            .                .            .            .                   std::cout << "Welcome." << std::endl;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   std::string response = res.send(req.getBody());
      .              .            .                .            .            .                .            .            .                   this->addEpollWriteEvent(req, response);
      .              .            .                .            .            .                .            .            .               });
      .              .            .                .            .            .                .            .            .           
    111 ( 0.00%)    10 ( 0.00%)  10 ( 0.01%)      38 ( 0.00%)   0            0               40 ( 0.00%)   0            0               this->post("/narratorChoice", [this](const Request &req, Response res) {
     12 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0            0            0                4 ( 0.00%)   0            0                   std::string response;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   try {
     28 ( 0.00%)     0            0                0            0            0                8 ( 0.00%)   0            0                       QJsonDocument reqDoc = QJsonDocument::fromJson(QString(
     12 ( 0.00%)     0            0                4 ( 0.00%)   0            0                4 ( 0.00%)   0            0                           req.getBody().c_str()
     68 ( 0.00%)    12 ( 0.00%)   8 ( 0.01%)       0            0            0               16 ( 0.00%)   0            0                       ).toUtf8());
      .              .            .                .            .            .                .            .            .           
    104 ( 0.00%)    12 ( 0.00%)   8 ( 0.01%)       0            0            0               24 ( 0.00%)   0            0                       std::string gameId = std::to_string(reqDoc["gameId"].toInt());
      .              .            .                .            .            .                .            .            .           
     68 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0            0            0               20 ( 0.00%)   0            0                       if(this->m_games.find(gameId) == this->m_games.end()) {
      .              .            .                .            .            .                .            .            .                           throw std::runtime_error("gameId not found");
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .                       
     24 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0            0            0                8 ( 0.00%)   0            0                       Game &game = this->m_games[gameId];
      .              .            .                .            .            .                .            .            .           
     88 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0            0            0               24 ( 0.00%)   0            0                       int cardId = reqDoc["cardId"].toInt();
    120 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0            0            0               28 ( 0.00%)   0            0                       std::string clue = reqDoc["clue"].toString().toStdString();
      .              .            .                .            .            .                .            .            .           
     24 ( 0.00%)     0            0                8 ( 0.00%)   0            0                4 ( 0.00%)   0            0                       game.narratorChoice(cardId, clue);
      .              .            .                .            .            .                .            .            .           
     88 ( 0.00%)    16 ( 0.00%)   8 ( 0.01%)       8 ( 0.00%)   0            0               20 ( 0.00%)   0            0                       response = res.send(game.toJsonString());
     36 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0            0            0               12 ( 0.00%)   0            0                   }
      .              .            .                .            .            .                .            .            .                   catch(std::exception &e) {
      .              .            .                .            .            .                .            .            .                       response = res.sendStatus(500, e.what());
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .                   
     20 ( 0.00%)     0            0                4 ( 0.00%)   0            0                4 ( 0.00%)   0            0                   this->addEpollWriteEvent(req, response);
     52 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)      28 ( 0.00%)   2 ( 0.00%)   0                4 ( 0.00%)   0            0               });
      .              .            .                .            .            .                .            .            .           
    191 ( 0.00%)    18 ( 0.00%)  10 ( 0.01%)      74 ( 0.00%)   8 ( 0.00%)   0               72 ( 0.00%)   0            0               this->post("/playerChoice", [this](const Request &req, Response res) {
     24 ( 0.00%)     8 ( 0.00%)   5 ( 0.00%)       0            0            0                8 ( 0.00%)   0            0                   std::string response;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   try {
     56 ( 0.00%)     0            0                0            0            0               16 ( 0.00%)   0            0                       QJsonDocument reqDoc = QJsonDocument::fromJson(QString(
     24 ( 0.00%)     0            0                8 ( 0.00%)   0            0                8 ( 0.00%)   0            0                           req.getBody().c_str()
    136 ( 0.00%)    16 ( 0.00%)  16 ( 0.01%)       0            0            0               32 ( 0.00%)   0            0                       ).toUtf8());
      .              .            .                .            .            .                .            .            .           
    208 ( 0.00%)    16 ( 0.00%)  12 ( 0.01%)       0            0            0               48 ( 0.00%)   0            0                       std::string gameId = std::to_string(reqDoc["gameId"].toInt());
      .              .            .                .            .            .                .            .            .           
    136 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0            0            0               40 ( 0.00%)   0            0                       if(this->m_games.find(gameId) == this->m_games.end()) {
      .              .            .                .            .            .                .            .            .                           throw std::runtime_error("gameId not found");
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .                       
     48 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0            0            0               16 ( 0.00%)   0            0                       Game &game = this->m_games[gameId];
      .              .            .                .            .            .                .            .            .           
    176 ( 0.00%)     8 ( 0.00%)   7 ( 0.01%)       0            0            0               48 ( 0.00%)   0            0                       int cardId = reqDoc["cardId"].toInt();
    176 ( 0.00%)    16 ( 0.00%)  16 ( 0.01%)       0            0            0               48 ( 0.00%)   0            0                       int playerId = reqDoc["playerId"].toInt();
      .              .            .                .            .            .                .            .            .           
     48 ( 0.00%)     8 ( 0.00%)   7 ( 0.01%)      24 ( 0.00%)   0            0                8 ( 0.00%)   0            0                       game.playerChoice(playerId, cardId);
      .              .            .                .            .            .                .            .            .           
    176 ( 0.00%)    16 ( 0.00%)   7 ( 0.01%)      16 ( 0.00%)   0            0               40 ( 0.00%)   0            0                       response = res.send(game.toJsonString());
     48 ( 0.00%)     8 ( 0.00%)   7 ( 0.01%)       0            0            0               16 ( 0.00%)   0            0                   }
      .              .            .                .            .            .                .            .            .                   catch(std::exception &e) {
      .              .            .                .            .            .                .            .            .                       response = res.sendStatus(500, e.what());
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .                   
     40 ( 0.00%)     0            0                8 ( 0.00%)   0            0                8 ( 0.00%)   0            0                   this->addEpollWriteEvent(req, response);
    104 ( 0.00%)    12 ( 0.00%)  10 ( 0.01%)      56 ( 0.00%)   5 ( 0.00%)   2 ( 0.00%)       8 ( 0.00%)   0            0               });
      .              .            .                .            .            .                .            .            .           
    191 ( 0.00%)    14 ( 0.00%)  13 ( 0.01%)      74 ( 0.00%)   8 ( 0.00%)   0               72 ( 0.00%)   0            0               this->post("/playerVote", [this](const Request &req, Response res) {
     24 ( 0.00%)     0            0                0            0            0                8 ( 0.00%)   0            0                   std::string response;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   try {
     56 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0            0            0               16 ( 0.00%)   0            0                       QJsonDocument reqDoc = QJsonDocument::fromJson(QString(
     24 ( 0.00%)     0            0                8 ( 0.00%)   0            0                8 ( 0.00%)   0            0                           req.getBody().c_str()
    136 ( 0.00%)     8 ( 0.00%)   7 ( 0.01%)       0            0            0               32 ( 0.00%)   0            0                       ).toUtf8());
      .              .            .                .            .            .                .            .            .           
    208 ( 0.00%)    11 ( 0.00%)  11 ( 0.01%)       0            0            0               48 ( 0.00%)   0            0                       std::string gameId = std::to_string(reqDoc["gameId"].toInt());
      .              .            .                .            .            .                .            .            .           
    136 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0            0            0               40 ( 0.00%)   0            0                       if(this->m_games.find(gameId) == this->m_games.end()) {
      .              .            .                .            .            .                .            .            .                           throw std::runtime_error("gameId not found");
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .                       
     48 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0            0            0               16 ( 0.00%)   0            0                       Game &game = this->m_games[gameId];
      .              .            .                .            .            .                .            .            .           
    176 ( 0.00%)    16 ( 0.00%)   8 ( 0.01%)       0            0            0               48 ( 0.00%)   0            0                       int cardId = reqDoc["cardId"].toInt();
    176 ( 0.00%)    16 ( 0.00%)  16 ( 0.01%)       0            0            0               48 ( 0.00%)   0            0                       int playerId = reqDoc["playerId"].toInt();
      .              .            .                .            .            .                .            .            .           
     48 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)      24 ( 0.00%)   0            0                8 ( 0.00%)   0            0                       game.playerVote(playerId, cardId);
      .              .            .                .            .            .                .            .            .           
    176 ( 0.00%)    20 ( 0.00%)   8 ( 0.01%)      16 ( 0.00%)   1 ( 0.00%)   1 ( 0.00%)      40 ( 0.00%)   0            0                       response = res.send(game.toJsonString());
     48 ( 0.00%)     8 ( 0.00%)   8 ( 0.01%)       0            0            0               16 ( 0.00%)   0            0                   }
      .              .            .                .            .            .                .            .            .                   catch(std::exception &e) {
      .              .            .                .            .            .                .            .            .                       response = res.sendStatus(500, e.what());
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .                   
     40 ( 0.00%)     0            0                8 ( 0.00%)   0            0                8 ( 0.00%)   0            0                   this->addEpollWriteEvent(req, response);
    104 ( 0.00%)    16 ( 0.00%)  16 ( 0.01%)      56 ( 0.00%)   7 ( 0.00%)   1 ( 0.00%)       8 ( 0.00%)   0            0               });
      .              .            .                .            .            .                .            .            .           
     71 ( 0.00%)    11 ( 0.00%)  10 ( 0.01%)      20 ( 0.00%)   0            0               24 ( 0.00%)   0            0               this->post("/joinGame", [this] (const Request &req, Response res) {
      6 ( 0.00%)     0            0                0            0            0                2 ( 0.00%)   0            0                   std::string response;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   try {
     14 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       0            0            0                4 ( 0.00%)   0            0                       QJsonDocument reqDoc = QJsonDocument::fromJson(QString(
      6 ( 0.00%)     0            0                2 ( 0.00%)   0            0                2 ( 0.00%)   0            0                           req.getBody().c_str()
     34 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       0            0            0                8 ( 0.00%)   0            0                       ).toUtf8());
      .              .            .                .            .            .                .            .            .           
     52 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)       0            0            0               12 ( 0.00%)   0            0                       std::string gameId = std::to_string(reqDoc["gameId"].toInt());
      .              .            .                .            .            .                .            .            .           
     34 ( 0.00%)     0            0                0            0            0               10 ( 0.00%)   0            0                       if(this->m_games.find(gameId) == this->m_games.end()) {
      .              .            .                .            .            .                .            .            .                           throw std::runtime_error("gameId not found");
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .           
     12 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       0            0            0                4 ( 0.00%)   0            0                       Game &game = this->m_games[gameId];
      .              .            .                .            .            .                .            .            .           
     22 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       4 ( 0.00%)   0            0                4 ( 0.00%)   0            0                       if(game.maxPlayers() == game.numOfPlayers()) {
      .              .            .                .            .            .                .            .            .                           throw std::runtime_error("Game is full!");
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .           
      2 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       0            0            0                2 ( 0.00%)   0            0                       bool foundPlayer = false;
     88 ( 0.00%)    12 ( 0.00%)   6 ( 0.00%)       6 ( 0.00%)   0            0               26 ( 0.00%)   0            0                       for(auto &player : game.players()) {
    147 ( 0.00%)    10 ( 0.00%)   8 ( 0.01%)       3 ( 0.00%)   0            0               33 ( 0.00%)   0            0                           if(player.username() == reqDoc["userName"].toString().toStdString()) {
      .              .            .                .            .            .                .            .            .                               throw std::runtime_error("Player already in game.");
      .              .            .                .            .            .                .            .            .                           }
      6 ( 0.00%)     0            0                0            0            0                2 ( 0.00%)   0            0                       }
      .              .            .                .            .            .                .            .            .           
     26 ( 0.00%)     4 ( 0.00%)   2 ( 0.00%)       2 ( 0.00%)   0            0                6 ( 0.00%)   0            0                       game.addPlayer(reqDoc.object());
      .              .            .                .            .            .                .            .            .           
     44 ( 0.00%)     4 ( 0.00%)   2 ( 0.00%)       4 ( 0.00%)   0            0               10 ( 0.00%)   0            0                       response = res.send(game.toJsonString());
     12 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       0            0            0                4 ( 0.00%)   0            0                   }
      .              .            .                .            .            .                .            .            .                   catch(std::exception &e) {
      .              .            .                .            .            .                .            .            .                       response = res.sendStatus(500, e.what());
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .                   
     10 ( 0.00%)     0            0                2 ( 0.00%)   0            0                2 ( 0.00%)   0            0                   this->addEpollWriteEvent(req, response);
     26 ( 0.00%)     6 ( 0.00%)   6 ( 0.00%)      14 ( 0.00%)   0            0                2 ( 0.00%)   0            0               });
      .              .            .                .            .            .                .            .            .           
     31 ( 0.00%)     3 ( 0.00%)   2 ( 0.00%)       2 ( 0.00%)   0            0                8 ( 0.00%)   0            0               this->post("/activeGames", [this] (const Request &req, Response res) {
      .              .            .                .            .            .                .            .            .                   std::string resp;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   try {
      .              .            .                .            .            .                .            .            .                       QJsonArray games;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                       for(auto &pair : this->m_games) {
      .              .            .                .            .            .                .            .            .                           QJsonObject game;
      .              .            .                .            .            .                .            .            .                           game["gameId"] = QString(pair.first.c_str());
-- line 527 ----------------------------------------
-- line 537 ----------------------------------------
      .              .            .                .            .            .                .            .            .                   catch (std::exception &e) {
      .              .            .                .            .            .                .            .            .                       resp = res.sendStatus(500, e.what());
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   this->addEpollWriteEvent(req, resp);
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .               });
      .              .            .                .            .            .                .            .            .           
 10,651 ( 0.00%)   603 ( 0.02%)  66 ( 0.05%)   4,781 ( 0.00%)  48 ( 0.01%)  16 ( 0.02%)   4,256 ( 0.01%)   0            0               this->post("/gameState", [this] (const Request &req, Response res)
      .              .            .                .            .            .                .            .            .               {
  1,593 ( 0.00%)     0            0                0            0            0              531 ( 0.00%)   0            0                   std::string resp;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   try {
 14,337 ( 0.00%)   581 ( 0.02%)  30 ( 0.02%)     531 ( 0.00%)   0            0            3,717 ( 0.01%)   0            0                       QJsonDocument reqDoc = QJsonDocument::fromJson(QString(req.getBody().c_str()).toUtf8());
 13,806 ( 0.00%) 1,062 ( 0.04%)  35 ( 0.03%)       0            0            0            3,186 ( 0.00%)   0            0                       std::string gameId = std::to_string(reqDoc["gameId"].toInt());
      .              .            .                .            .            .                .            .            .                       
  9,027 ( 0.00%)   531 ( 0.02%)  80 ( 0.06%)       0            0            0            2,655 ( 0.00%)   0            0                       if(this->m_games.find(gameId) == this->m_games.end()) {
      .              .            .                .            .            .                .            .            .                           throw std::runtime_error("gameId not found");
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .           
  3,186 ( 0.00%)    33 ( 0.00%)  11 ( 0.01%)       0            0            0            1,062 ( 0.00%)   0            0                       Game& game = this->m_games[gameId];
 11,682 ( 0.00%)   531 ( 0.02%)   8 ( 0.01%)   1,062 ( 0.00%)   0            0            2,655 ( 0.00%)   0            0                       resp = res.send(game.toJsonString());
  3,186 ( 0.00%)   531 ( 0.02%)   1 ( 0.00%)       0            0            0            1,062 ( 0.00%)   0            0                   }
      .              .            .                .            .            .                .            .            .                   catch (std::exception &e) {
      .              .            .                .            .            .                .            .            .                       resp = res.sendStatus(500, e.what());
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
  2,655 ( 0.00%)     0            0              531 ( 0.00%)   0            0              531 ( 0.00%)   0            0                   this->addEpollWriteEvent(req, resp);
  6,903 ( 0.00%) 1,062 ( 0.04%)  25 ( 0.02%)   3,717 ( 0.00%) 120 ( 0.03%)   4 ( 0.00%)     531 ( 0.00%)   0            0               });
      .              .            .                .            .            .                .            .            .           
     51 ( 0.00%)     7 ( 0.00%)   5 ( 0.00%)      11 ( 0.00%)   0            0               16 ( 0.00%)   0            0               this->post("/startGame", [this] (const Request &req, Response res) {
      3 ( 0.00%)     0            0                0            0            0                1 ( 0.00%)   0            0                   std::string resp;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   try {
     27 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       1 ( 0.00%)   0            0                7 ( 0.00%)   0            0                       QJsonDocument reqDoc = QJsonDocument::fromJson(QString(req.getBody().c_str()).toUtf8());
     26 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       0            0            0                6 ( 0.00%)   0            0                       std::string gameId = std::to_string(reqDoc["gameId"].toInt());
      .              .            .                .            .            .                .            .            .                       
     17 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       0            0            0                5 ( 0.00%)   0            0                       if(this->m_games.find(gameId) == this->m_games.end()) {
      .              .            .                .            .            .                .            .            .                           throw std::runtime_error("gameId not found");
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .           
      6 ( 0.00%)     0            0                0            0            0                2 ( 0.00%)   0            0                       Game& game = this->m_games[gameId];
      3 ( 0.00%)     0            0                1 ( 0.00%)   0            0                1 ( 0.00%)   0            0                       game.startGame();
     22 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       2 ( 0.00%)   0            0                5 ( 0.00%)   0            0                       resp = res.send(game.toJsonString());
      6 ( 0.00%)     0            0                0            0            0                2 ( 0.00%)   0            0                   }
      .              .            .                .            .            .                .            .            .                   catch (std::exception &e) {
      .              .            .                .            .            .                .            .            .                       resp = res.sendStatus(500, e.what());
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
      5 ( 0.00%)     0            0                1 ( 0.00%)   0            0                1 ( 0.00%)   0            0                   this->addEpollWriteEvent(req, resp);
      .              .            .                .            .            .                .            .            .           
     13 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       7 ( 0.00%)   1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%)   0            0               });
      .              .            .                .            .            .                .            .            .           
     50 ( 0.00%)     5 ( 0.00%)   5 ( 0.00%)      11 ( 0.00%)   1 ( 0.00%)   1 ( 0.00%)      15 ( 0.00%)   0            0               this->post("/createGame", [this] (const Request &req, Response res) {
      .              .            .                .            .            .                .            .            .           
      3 ( 0.00%)     0            0                0            0            0                1 ( 0.00%)   0            0                   std::string resp;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   try{
      3 ( 0.00%)     0            0                0            0            0                1 ( 0.00%)   0            0                       Game newGame = Game();
     14 ( 0.00%)     0            0                2 ( 0.00%)   1 ( 0.00%)   0                3 ( 0.00%)   0            0                       newGame.setGameId(newGame.gameID() + ++this->createdGameCounter);
      8 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                2 ( 0.00%)   0            0                       std::string gameId = std::to_string(newGame.gameID());
      .              .            .                .            .            .                .            .            .           
     27 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       1 ( 0.00%)   0            0                7 ( 0.00%)   0            0                       QJsonDocument reqDoc = QJsonDocument::fromJson(QString(req.getBody().c_str()).toUtf8());
      .              .            .                .            .            .                .            .            .           
     13 ( 0.00%)     2 ( 0.00%)   1 ( 0.00%)       0            0            0                3 ( 0.00%)   0            0                       newGame.initializeGame(reqDoc.object());
     10 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                2 ( 0.00%)   0            0                       this->m_games[gameId] = newGame;
      .              .            .                .            .            .                .            .            .           
     27 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       1 ( 0.00%)   0            0                6 ( 0.00%)   0            0                       resp = res.send(this->m_games[gameId].toJsonString());
      9 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0            0            0                3 ( 0.00%)   0            0                   }
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   catch(std::exception &e) {
      .              .            .                .            .            .                .            .            .                       resp = res.sendStatus(500, e.what());
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .                   
      5 ( 0.00%)     0            0                1 ( 0.00%)   0            0                1 ( 0.00%)   0            0                   this->addEpollWriteEvent(req, resp);
      .              .            .                .            .            .                .            .            .                   
     12 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       6 ( 0.00%)   0            0                1 ( 0.00%)   0            0               });
      .              .            .                .            .            .                .            .            .           
     31 ( 0.00%)     2 ( 0.00%)   2 ( 0.00%)       2 ( 0.00%)   0            0                8 ( 0.00%)   0            0               this->post("/settings", [this] (const Request &req, Response res) {
      .              .            .                .            .            .                .            .            .                   std::string response = res.send(req.getBody());
      .              .            .                .            .            .                .            .            .                   this->addEpollWriteEvent(req, response);
      .              .            .                .            .            .                .            .            .               });
      .              .            .                .            .            .                .            .            .           
    151 ( 0.00%)    32 ( 0.00%)  32 ( 0.03%)      56 ( 0.00%)   3 ( 0.00%)   0               56 ( 0.00%)   0            0               this->post("/chat", [this] (const Request &req, Response res) {
     18 ( 0.00%)     0            0                0            0            0                6 ( 0.00%)   0            0                   std::string resp;
      .              .            .                .            .            .                .            .            .           
      .              .            .                .            .            .                .            .            .                   try {
     42 ( 0.00%)     0            0                0            0            0               12 ( 0.00%)   0            0                       QJsonDocument reqDoc = QJsonDocument::fromJson(QString(
     18 ( 0.00%)     6 ( 0.00%)   6 ( 0.00%)       6 ( 0.00%)   0            0                6 ( 0.00%)   0            0                           req.getBody().c_str()
    102 ( 0.00%)     6 ( 0.00%)   6 ( 0.00%)       0            0            0               24 ( 0.00%)   0            0                       ).toUtf8());
      .              .            .                .            .            .                .            .            .           
    156 ( 0.00%)    12 ( 0.00%)  12 ( 0.01%)       0            0            0               36 ( 0.00%)   0            0                       std::string gameId = std::to_string(reqDoc["gameId"].toInt());
      .              .            .                .            .            .                .            .            .           
    102 ( 0.00%)     6 ( 0.00%)   6 ( 0.00%)       0            0            0               30 ( 0.00%)   0            0                       if(this->m_games.find(gameId) == this->m_games.end()) {
      .              .            .                .            .            .                .            .            .                           throw std::runtime_error("gameId not found");
      .              .            .                .            .            .                .            .            .                       }
      .              .            .                .            .            .                .            .            .           
     36 ( 0.00%)     0            0                0            0            0               12 ( 0.00%)   0            0                       Game &game = this->m_games[gameId];
     78 ( 0.00%)     6 ( 0.00%)   6 ( 0.00%)       6 ( 0.00%)   0            0               18 ( 0.00%)   0            0                       game.m_chat.addMessage(reqDoc.object());
      .              .            .                .            .            .                .            .            .           
    132 ( 0.00%)    18 ( 0.00%)  12 ( 0.01%)      12 ( 0.00%)   0            0               30 ( 0.00%)   0            0                       resp = res.send(game.toJsonString());
     36 ( 0.00%)     0            0                0            0            0               12 ( 0.00%)   0            0                   }
      .              .            .                .            .            .                .            .            .                   catch(std::exception &e) {
      .              .            .                .            .            .                .            .            .                       resp = res.sendStatus(500, e.what());
      .              .            .                .            .            .                .            .            .                   }
      .              .            .                .            .            .                .            .            .           
     30 ( 0.00%)     0            0                6 ( 0.00%)   0            0                6 ( 0.00%)   0            0                   this->addEpollWriteEvent(req, resp);
     78 ( 0.00%)    12 ( 0.00%)  11 ( 0.01%)      42 ( 0.00%)   1 ( 0.00%)   0                6 ( 0.00%)   0            0               });
     28 ( 0.00%)     3 ( 0.00%)   3 ( 0.00%)      11 ( 0.00%)   1 ( 0.00%)   0                5 ( 0.00%)   0            0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_uninitialized.h
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr               D1mr       DLmr       Dw               D1mw       DLmw       

-- line 77 ----------------------------------------
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             /// @cond undocumented
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<bool _TrivialValueTypes>
      .              .            .                .          .          .                .          .          .               struct __uninitialized_copy
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 template<typename _InputIterator, typename _ForwardIterator>
      .              .            .                .          .          .                .          .          .                   static _ForwardIterator
 31,024 ( 0.01%)     4 ( 0.00%)   2 ( 0.00%)       0          0          0           19,390 ( 0.03%) 0          0                   __uninit_copy(_InputIterator __first, _InputIterator __last,
      .              .            .                .          .          .                .          .          .           		      _ForwardIterator __result)
      .              .            .                .          .          .                .          .          .                   {
  7,756 ( 0.00%)   561 ( 0.02%) 114 ( 0.09%)   3,878 ( 0.00%) 0          0            3,878 ( 0.01%) 0          0           	  _ForwardIterator __cur = __result;
      .              .            .                .          .          .                .          .          .           	  __try
      .              .            .                .          .          .                .          .          .           	    {
201,557 ( 0.05%)   565 ( 0.02%) 565 ( 0.44%)  15,503 ( 0.01%) 0          0           34,884 ( 0.05%) 0          0           	      for (; __first != __last; ++__first, (void)++__cur)
155,030 ( 0.04%)     0            0           15,503 ( 0.01%) 0          0           46,509 ( 0.07%) 0          0           		std::_Construct(std::__addressof(*__cur), *__first);
  3,882 ( 0.00%)     0            0            3,878 ( 0.00%) 0          0                0          0          0           	      return __cur;
      .              .            .                .          .          .                .          .          .           	    }
      .              .            .                .          .          .                .          .          .           	  __catch(...)
      .              .            .                .          .          .                .          .          .           	    {
      .              .            .                .          .          .                .          .          .           	      std::_Destroy(__result, __cur);
      .              .            .                .          .          .                .          .          .           	      __throw_exception_again;
      .              .            .                .          .          .                .          .          .           	    }
 11,634 ( 0.00%)     0            0           11,634 ( 0.01%) 0          0                0          0          0           	}
      .              .            .                .          .          .                .          .          .               };
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<>
      .              .            .                .          .          .                .          .          .               struct __uninitialized_copy<true>
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 template<typename _InputIterator, typename _ForwardIterator>
      .              .            .                .          .          .                .          .          .                   static _ForwardIterator
    161 ( 0.00%)     7 ( 0.00%)   7 ( 0.01%)       0          0          0               92 ( 0.00%) 0          0                   __uninit_copy(_InputIterator __first, _InputIterator __last,
      .              .            .                .          .          .                .          .          .           		      _ForwardIterator __result)
    184 ( 0.00%)     0            0              115 ( 0.00%) 0          0               23 ( 0.00%) 0          0                   { return std::copy(__first, __last, __result); }
      .              .            .                .          .          .                .          .          .               };
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             /// @endcond
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             /**
      .              .            .                .          .          .                .          .          .              *  @brief Copies the range [first,last) into result.
      .              .            .                .          .          .                .          .          .              *  @param  __first  An input iterator.
      .              .            .                .          .          .                .          .          .              *  @param  __last   An input iterator.
      .              .            .                .          .          .                .          .          .              *  @param  __result An output iterator.
      .              .            .                .          .          .                .          .          .              *  @return   __result + (__first - __last)
      .              .            .                .          .          .                .          .          .              *
      .              .            .                .          .          .                .          .          .              *  Like copy(), but does not require an initialized output range.
      .              .            .                .          .          .                .          .          .             */
      .              .            .                .          .          .                .          .          .             template<typename _InputIterator, typename _ForwardIterator>
      .              .            .                .          .          .                .          .          .               inline _ForwardIterator
 27,307 ( 0.01%)    16 ( 0.00%)  13 ( 0.01%)       0          0          0           15,604 ( 0.02%) 0          0               uninitialized_copy(_InputIterator __first, _InputIterator __last,
      .              .            .                .          .          .                .          .          .           		       _ForwardIterator __result)
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 typedef typename iterator_traits<_InputIterator>::value_type
      .              .            .                .          .          .                .          .          .           	_ValueType1;
      .              .            .                .          .          .                .          .          .                 typedef typename iterator_traits<_ForwardIterator>::value_type
      .              .            .                .          .          .                .          .          .           	_ValueType2;
      .              .            .                .          .          .                .          .          .           #if __cplusplus < 201103L
      .              .            .                .          .          .                .          .          .                 const bool __assignable = true;
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
      .              .            .                .          .          .                .          .          .                 // optimization that uses memmove would happily "copy" them anyway.
      .              .            .                .          .          .                .          .          .                 static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
      .              .            .                .          .          .                .          .          .           	  "result type must be constructible from value type of input range");
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .                 typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      .              .            .                .          .          .                .          .          .                 typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      .              .            .                .          .          .                .          .          .                 // Trivial types can have deleted assignment, so using std::copy
      .              .            .                .          .          .                .          .          .                 // would be ill-formed. Require assignability before using std::copy:
  3,901 ( 0.00%)     0            0                0          0          0            3,901 ( 0.01%) 0          0                 const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
      .              .            .                .          .          .                .          .          .           #endif
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .                 return std::__uninitialized_copy<__is_trivial(_ValueType1)
      .              .            .                .          .          .                .          .          .           				       && __is_trivial(_ValueType2)
      .              .            .                .          .          .                .          .          .           				       && __assignable>::
 23,406 ( 0.01%)     3 ( 0.00%)   2 ( 0.00%)  11,703 ( 0.01%) 0          0            3,901 ( 0.01%) 0          0           	__uninit_copy(__first, __last, __result);
  7,802 ( 0.00%)     4 ( 0.00%)   4 ( 0.00%)   7,802 ( 0.01%) 0          0                0          0          0               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             /// @cond undocumented
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<bool _TrivialValueType>
      .              .            .                .          .          .                .          .          .               struct __uninitialized_fill
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 template<typename _ForwardIterator, typename _Tp>
      .              .            .                .          .          .                .          .          .                   static void
-- line 160 ----------------------------------------
-- line 222 ----------------------------------------
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             /// @cond undocumented
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<bool _TrivialValueType>
      .              .            .                .          .          .                .          .          .               struct __uninitialized_fill_n
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 template<typename _ForwardIterator, typename _Size, typename _Tp>
      .              .            .                .          .          .                .          .          .                   static _ForwardIterator
 27,118 ( 0.01%)    31 ( 0.00%)  25 ( 0.02%)       0          0          0           15,496 ( 0.02%) 0          0                   __uninit_fill_n(_ForwardIterator __first, _Size __n,
      .              .            .                .          .          .                .          .          .           			const _Tp& __x)
      .              .            .                .          .          .                .          .          .                   {
  7,748 ( 0.00%)     0            0            3,874 ( 0.00%) 0          0            3,874 ( 0.01%) 0          0           	  _ForwardIterator __cur = __first;
      .              .            .                .          .          .                .          .          .           	  __try
      .              .            .                .          .          .                .          .          .           	    {
 73,606 ( 0.02%)   561 ( 0.02%)   5 ( 0.00%)  50,362 ( 0.05%) 0          0                0          0          0           	      for (; __n > 0; --__n, (void) ++__cur)
123,968 ( 0.03%)     0            0           30,992 ( 0.03%) 0          0           30,992 ( 0.05%) 0          0           		std::_Construct(std::__addressof(*__cur), __x);
  3,874 ( 0.00%)     0            0            3,874 ( 0.00%) 0          0                0          0          0           	      return __cur;
      .              .            .                .          .          .                .          .          .           	    }
      .              .            .                .          .          .                .          .          .           	  __catch(...)
      .              .            .                .          .          .                .          .          .           	    {
      .              .            .                .          .          .                .          .          .           	      std::_Destroy(__first, __cur);
      .              .            .                .          .          .                .          .          .           	      __throw_exception_again;
      .              .            .                .          .          .                .          .          .           	    }
  7,748 ( 0.00%)     0            0            7,748 ( 0.01%) 0          0                0          0          0           	}
      .              .            .                .          .          .                .          .          .               };
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<>
      .              .            .                .          .          .                .          .          .               struct __uninitialized_fill_n<true>
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 template<typename _ForwardIterator, typename _Size, typename _Tp>
      .              .            .                .          .          .                .          .          .                   static _ForwardIterator
      .              .            .                .          .          .                .          .          .                   __uninit_fill_n(_ForwardIterator __first, _Size __n,
-- line 253 ----------------------------------------
-- line 265 ----------------------------------------
      .              .            .                .          .          .                .          .          .              *  @param  __n      The number of copies to make.
      .              .            .                .          .          .                .          .          .              *  @param  __x      The source value.
      .              .            .                .          .          .                .          .          .              *  @return   Nothing.
      .              .            .                .          .          .                .          .          .              *
      .              .            .                .          .          .                .          .          .              *  Like fill_n(), but does not require an initialized output range.
      .              .            .                .          .          .                .          .          .             */
      .              .            .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Size, typename _Tp>
      .              .            .                .          .          .                .          .          .               inline _ForwardIterator
 27,118 ( 0.01%) 1,122 ( 0.04%)  14 ( 0.01%)       0          0          0           15,496 ( 0.02%) 0          0               uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 typedef typename iterator_traits<_ForwardIterator>::value_type
      .              .            .                .          .          .                .          .          .           	_ValueType;
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .                 // Trivial types do not need a constructor to begin their lifetime,
      .              .            .                .          .          .                .          .          .                 // so try to use std::fill_n to benefit from its memmove optimization.
      .              .            .                .          .          .                .          .          .                 // For arbitrary class types and floating point types we can't assume
      .              .            .                .          .          .                .          .          .                 // that __n > 0 and std::__size_to_integer(__n) > 0 are equivalent,
-- line 281 ----------------------------------------
-- line 285 ----------------------------------------
      .              .            .                .          .          .                .          .          .           #else
      .              .            .                .          .          .                .          .          .                 // Trivial types can have deleted copy constructor, but the std::fill_n
      .              .            .                .          .          .                .          .          .                 // optimization that uses memmove would happily "copy" them anyway.
      .              .            .                .          .          .                .          .          .                 static_assert(is_constructible<_ValueType, const _Tp&>::value,
      .              .            .                .          .          .                .          .          .           	  "result type must be constructible from input type");
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .                 // Trivial types can have deleted assignment, so using std::fill_n
      .              .            .                .          .          .                .          .          .                 // would be ill-formed. Require assignability before using std::fill_n:
  3,874 ( 0.00%)     0            0                0          0          0            3,874 ( 0.01%) 0          0                 constexpr bool __can_fill
      .              .            .                .          .          .                .          .          .           	= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;
      .              .            .                .          .          .                .          .          .           #endif
      .              .            .                .          .          .                .          .          .                 return __uninitialized_fill_n<__is_trivial(_ValueType) && __can_fill>::
 23,244 ( 0.01%)     0            0           11,622 ( 0.01%) 0          0            3,874 ( 0.01%) 0          0           	__uninit_fill_n(__first, __n, __x);
  7,748 ( 0.00%)     0            0            7,748 ( 0.01%) 0          0                0          0          0               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             /// @cond undocumented
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             // Extensions: versions of uninitialized_copy, uninitialized_fill,
      .              .            .                .          .          .                .          .          .             //  and uninitialized_fill_n that take an allocator parameter.
      .              .            .                .          .          .                .          .          .             //  We dispatch back to the standard versions when we're given the
      .              .            .                .          .          .                .          .          .             //  default allocator.  For nondefault allocators we do not use 
      .              .            .                .          .          .                .          .          .             //  any of the POD optimizations.
-- line 306 ----------------------------------------
-- line 323 ----------------------------------------
      .              .            .                .          .          .                .          .          .           	{
      .              .            .                .          .          .                .          .          .           	  std::_Destroy(__result, __cur, __alloc);
      .              .            .                .          .          .                .          .          .           	  __throw_exception_again;
      .              .            .                .          .          .                .          .          .           	}
      .              .            .                .          .          .                .          .          .               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
      .              .            .                .          .          .                .          .          .               inline _ForwardIterator
 31,208 ( 0.01%)     9 ( 0.00%)   9 ( 0.01%)       0          0          0           19,505 ( 0.03%) 0          0               __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      .              .            .                .          .          .                .          .          .           			   _ForwardIterator __result, allocator<_Tp>&)
 31,208 ( 0.01%)    15 ( 0.00%)  15 ( 0.01%)  19,505 ( 0.02%) 0          0            3,901 ( 0.01%) 0          0               { return std::uninitialized_copy(__first, __last, __result); }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<typename _InputIterator, typename _ForwardIterator,
      .              .            .                .          .          .                .          .          .           	   typename _Allocator>
      .              .            .                .          .          .                .          .          .               inline _ForwardIterator
      .              .            .                .          .          .                .          .          .               __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      .              .            .                .          .          .                .          .          .           			   _ForwardIterator __result, _Allocator& __alloc)
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
-- line 341 ----------------------------------------
-- line 400 ----------------------------------------
      .              .            .                .          .          .                .          .          .           	  std::_Destroy(__first, __cur, __alloc);
      .              .            .                .          .          .                .          .          .           	  __throw_exception_again;
      .              .            .                .          .          .                .          .          .           	}
      .              .            .                .          .          .                .          .          .               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Size, typename _Tp,
      .              .            .                .          .          .                .          .          .           	   typename _Tp2>
      .              .            .                .          .          .                .          .          .               inline _ForwardIterator
 30,992 ( 0.01%)    32 ( 0.00%)  20 ( 0.02%)       0          0          0           19,370 ( 0.03%) 0          0               __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
      .              .            .                .          .          .                .          .          .           			     const _Tp& __x, allocator<_Tp2>&)
 30,992 ( 0.01%)    34 ( 0.00%)  15 ( 0.01%)  19,370 ( 0.02%) 0          0            3,874 ( 0.01%) 0          0               { return std::uninitialized_fill_n(__first, __n, __x); }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
      .              .            .                .          .          .                .          .          .             // __uninitialized_fill_move, __uninitialized_move_fill.
      .              .            .                .          .          .                .          .          .             // All of these algorithms take a user-supplied allocator, which is used
      .              .            .                .          .          .                .          .          .             // for construction and destruction.
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             // __uninitialized_copy_move
-- line 418 ----------------------------------------
-- line 565 ----------------------------------------
      .              .            .                .          .          .                .          .          .           	}
      .              .            .                .          .          .                .          .          .               };
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<bool _TrivialValueType>
      .              .            .                .          .          .                .          .          .               struct __uninitialized_default_n_1
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 template<typename _ForwardIterator, typename _Size>
      .              .            .                .          .          .                .          .          .                   static _ForwardIterator
 27,118 ( 0.01%)   561 ( 0.02%)   1 ( 0.00%)       0          0          0           15,496 ( 0.02%) 0          0                   __uninit_default_n(_ForwardIterator __first, _Size __n)
      .              .            .                .          .          .                .          .          .                   {
  7,748 ( 0.00%)     0            0            3,874 ( 0.00%) 0          0            3,874 ( 0.01%) 0          0           	  _ForwardIterator __cur = __first;
      .              .            .                .          .          .                .          .          .           	  __try
      .              .            .                .          .          .                .          .          .           	    {
230,502 ( 0.05%)     0            0          168,034 ( 0.15%) 0          0                0          0          0           	      for (; __n > 0; --__n, (void) ++__cur)
273,600 ( 0.06%)     0            0           54,720 ( 0.05%) 0          0          109,440 ( 0.16%) 0          0           		std::_Construct(std::__addressof(*__cur));
  7,748 ( 0.00%)     0            0            3,874 ( 0.00%) 0          0                0          0          0           	      return __cur;
      .              .            .                .          .          .                .          .          .           	    }
      .              .            .                .          .          .                .          .          .           	  __catch(...)
      .              .            .                .          .          .                .          .          .           	    {
      .              .            .                .          .          .                .          .          .           	      std::_Destroy(__first, __cur);
      .              .            .                .          .          .                .          .          .           	      __throw_exception_again;
      .              .            .                .          .          .                .          .          .           	    }
 11,622 ( 0.00%)   561 ( 0.02%)  13 ( 0.01%)  11,622 ( 0.01%) 0          0                0          0          0           	}
      .              .            .                .          .          .                .          .          .               };
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<>
      .              .            .                .          .          .                .          .          .               struct __uninitialized_default_n_1<true>
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 template<typename _ForwardIterator, typename _Size>
      .              .            .                .          .          .                .          .          .                   static _ForwardIterator
      6 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       0          0          0                3 ( 0.00%) 0          0                   __uninit_default_n(_ForwardIterator __first, _Size __n)
      .              .            .                .          .          .                .          .          .                   {
      2 ( 0.00%)     0            0                1 ( 0.00%) 0          0                0          0          0           	  if (__n > 0)
      .              .            .                .          .          .                .          .          .           	    {
      .              .            .                .          .          .                .          .          .           	      typename iterator_traits<_ForwardIterator>::value_type* __val
      4 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%) 0          0                2 ( 0.00%) 0          0           		= std::__addressof(*__first);
      3 ( 0.00%)     0            0                1 ( 0.00%) 0          0                1 ( 0.00%) 0          0           	      std::_Construct(__val);
      1 ( 0.00%)     0            0                1 ( 0.00%) 0          0                0          0          0           	      ++__first;
      8 ( 0.00%)     0            0                3 ( 0.00%) 0          0                2 ( 0.00%) 0          0           	      __first = std::fill_n(__first, __n - 1, *__val);
      .              .            .                .          .          .                .          .          .           	    }
      1 ( 0.00%)     1 ( 0.00%)   1 ( 0.00%)       1 ( 0.00%) 0          0                0          0          0           	  return __first;
      2 ( 0.00%)     0            0                2 ( 0.00%) 0          0                0          0          0           	}
      .              .            .                .          .          .                .          .          .               };
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             // __uninitialized_default
      .              .            .                .          .          .                .          .          .             // Fills [first, last) with value-initialized value_types.
      .              .            .                .          .          .                .          .          .             template<typename _ForwardIterator>
      .              .            .                .          .          .                .          .          .               inline void
      .              .            .                .          .          .                .          .          .               __uninitialized_default(_ForwardIterator __first,
      .              .            .                .          .          .                .          .          .           			    _ForwardIterator __last)
-- line 614 ----------------------------------------
-- line 622 ----------------------------------------
      .              .            .                .          .          .                .          .          .           				     && __assignable>::
      .              .            .                .          .          .                .          .          .           	__uninit_default(__first, __last);
      .              .            .                .          .          .                .          .          .               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             // __uninitialized_default_n
      .              .            .                .          .          .                .          .          .             // Fills [first, first + n) with value-initialized value_types.
      .              .            .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Size>
      .              .            .                .          .          .                .          .          .               inline _ForwardIterator
 23,250 ( 0.01%)     2 ( 0.00%)   2 ( 0.00%)       0          0          0           11,625 ( 0.02%) 0          0               __uninitialized_default_n(_ForwardIterator __first, _Size __n)
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 typedef typename iterator_traits<_ForwardIterator>::value_type
      .              .            .                .          .          .                .          .          .           	_ValueType;
      .              .            .                .          .          .                .          .          .                 // See uninitialized_fill_n for the conditions for using std::fill_n.
  3,875 ( 0.00%)     0            0                0          0          0            3,875 ( 0.01%) 0          0                 constexpr bool __can_fill
      .              .            .                .          .          .                .          .          .           	= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .                 return __uninitialized_default_n_1<__is_trivial(_ValueType)
      .              .            .                .          .          .                .          .          .           					 && __can_fill>::
 19,375 ( 0.00%)     0            0            7,750 ( 0.01%) 0          0            3,875 ( 0.01%) 0          0           	__uninit_default_n(__first, __n);
  7,750 ( 0.00%)     0            0            7,750 ( 0.01%) 0          0                0          0          0               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             // __uninitialized_default_a
      .              .            .                .          .          .                .          .          .             // Fills [first, last) with value_types constructed by the allocator
      .              .            .                .          .          .                .          .          .             // alloc, with no arguments passed to the construct call.
      .              .            .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Allocator>
      .              .            .                .          .          .                .          .          .               void
      .              .            .                .          .          .                .          .          .               __uninitialized_default_a(_ForwardIterator __first,
-- line 649 ----------------------------------------
-- line 694 ----------------------------------------
      .              .            .                .          .          .                .          .          .           	  __throw_exception_again;
      .              .            .                .          .          .                .          .          .           	}
      .              .            .                .          .          .                .          .          .               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             // __uninitialized_default_n_a specialization for std::allocator,
      .              .            .                .          .          .                .          .          .             // which ignores the allocator and value-initializes the elements.
      .              .            .                .          .          .                .          .          .             template<typename _ForwardIterator, typename _Size, typename _Tp>
      .              .            .                .          .          .                .          .          .               inline _ForwardIterator
 27,125 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)       0          0          0           15,500 ( 0.02%) 0          0               __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
      .              .            .                .          .          .                .          .          .           				allocator<_Tp>&)
 27,125 ( 0.01%)   561 ( 0.02%)   2 ( 0.00%)  15,500 ( 0.01%) 0          0            3,875 ( 0.01%) 0          0               { return std::__uninitialized_default_n(__first, __n); }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<bool _TrivialValueType>
      .              .            .                .          .          .                .          .          .               struct __uninitialized_default_novalue_1
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 template<typename _ForwardIterator>
      .              .            .                .          .          .                .          .          .           	static void
      .              .            .                .          .          .                .          .          .           	__uninit_default_novalue(_ForwardIterator __first,
      .              .            .                .          .          .                .          .          .           				 _ForwardIterator __last)
-- line 712 ----------------------------------------
-- line 978 ----------------------------------------
      .              .            .                .          .          .                .          .          .               }
      .              .            .                .          .          .                .          .          .           #endif // C++17
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .           #if __cplusplus >= 201103L
      .              .            .                .          .          .                .          .          .             /// @cond undocumented
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template<typename _Tp, typename _Up, typename _Allocator>
      .              .            .                .          .          .                .          .          .               inline void
 56,427 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)       0          0          0           32,244 ( 0.05%) 0          0               __relocate_object_a(_Tp* __restrict __dest, _Up* __restrict __orig,
      .              .            .                .          .          .                .          .          .           			_Allocator& __alloc)
      .              .            .                .          .          .                .          .          .               noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
      .              .            .                .          .          .                .          .          .           			 __dest, std::move(*__orig)))
      .              .            .                .          .          .                .          .          .           	     && noexcept(std::allocator_traits<_Allocator>::destroy(
      .              .            .                .          .          .                .          .          .           			    __alloc, std::__addressof(*__orig))))
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 typedef std::allocator_traits<_Allocator> __traits;
 72,549 ( 0.02%)   563 ( 0.02%)  19 ( 0.01%)  24,183 ( 0.02%) 0          0           16,122 ( 0.02%) 0          0                 __traits::construct(__alloc, __dest, std::move(*__orig));
 64,488 ( 0.01%)     1 ( 0.00%)   1 ( 0.00%)  16,122 ( 0.01%) 0          0           16,122 ( 0.02%) 0          0                 __traits::destroy(__alloc, std::__addressof(*__orig));
 24,183 ( 0.01%)     0            0           16,122 ( 0.01%) 0          0                0          0          0               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             // This class may be specialized for specific types.
      .              .            .                .          .          .                .          .          .             // Also known as is_trivially_relocatable.
      .              .            .                .          .          .                .          .          .             template<typename _Tp, typename = void>
      .              .            .                .          .          .                .          .          .               struct __is_bitwise_relocatable
      .              .            .                .          .          .                .          .          .               : is_trivial<_Tp> { };
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template <typename _Tp, typename _Up>
      .              .            .                .          .          .                .          .          .               inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
    552 ( 0.00%)    14 ( 0.00%)   5 ( 0.00%)       0          0          0              345 ( 0.00%) 0          0               __relocate_a_1(_Tp* __first, _Tp* __last,
      .              .            .                .          .          .                .          .          .           		   _Tp* __result, allocator<_Up>&) noexcept
      .              .            .                .          .          .                .          .          .               {
    276 ( 0.00%)     0            0              138 ( 0.00%) 0          0               69 ( 0.00%) 0          0                 ptrdiff_t __count = __last - __first;
    138 ( 0.00%)     0            0               69 ( 0.00%) 0          0                0          0          0                 if (__count > 0)
    133 ( 0.00%)     0            0               57 ( 0.00%) 0          0               19 ( 0.00%) 0          0           	__builtin_memmove(__result, __first, __count * sizeof(_Tp));
    276 ( 0.00%)     3 ( 0.00%)   2 ( 0.00%)     138 ( 0.00%) 0          0                0          0          0                 return __result + __count;
    138 ( 0.00%)     0            0              138 ( 0.00%) 0          0                0          0          0               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template <typename _InputIterator, typename _ForwardIterator,
      .              .            .                .          .          .                .          .          .           	    typename _Allocator>
      .              .            .                .          .          .                .          .          .               inline _ForwardIterator
152,622 ( 0.04%)    11 ( 0.00%)   5 ( 0.00%)       0          0          0          101,748 ( 0.15%) 0          0               __relocate_a_1(_InputIterator __first, _InputIterator __last,
      .              .            .                .          .          .                .          .          .           		   _ForwardIterator __result, _Allocator& __alloc)
      .              .            .                .          .          .                .          .          .               noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
      .              .            .                .          .          .                .          .          .           					       std::addressof(*__first),
      .              .            .                .          .          .                .          .          .           					       __alloc)))
      .              .            .                .          .          .                .          .          .               {
      .              .            .                .          .          .                .          .          .                 typedef typename iterator_traits<_InputIterator>::value_type
      .              .            .                .          .          .                .          .          .           	_ValueType;
      .              .            .                .          .          .                .          .          .                 typedef typename iterator_traits<_ForwardIterator>::value_type
      .              .            .                .          .          .                .          .          .           	_ValueType2;
      .              .            .                .          .          .                .          .          .                 static_assert(std::is_same<_ValueType, _ValueType2>::value,
      .              .            .                .          .          .                .          .          .           	  "relocation is only possible for values of the same type");
 33,916 ( 0.01%)   561 ( 0.02%)   2 ( 0.00%)  16,958 ( 0.02%) 0          0           16,958 ( 0.02%) 0          0                 _ForwardIterator __cur = __result;
108,137 ( 0.03%)   568 ( 0.02%)  22 ( 0.02%)  66,160 ( 0.06%) 0          0                0          0          0                 for (; __first != __last; ++__first, (void)++__cur)
104,793 ( 0.02%)     0            0           24,183 ( 0.02%) 0          0           24,183 ( 0.04%) 0          0           	std::__relocate_object_a(std::__addressof(*__cur),
      .              .            .                .          .          .                .          .          .           				 std::__addressof(*__first), __alloc);
 16,958 ( 0.00%)     0            0           16,958 ( 0.02%) 0          0                0          0          0                 return __cur;
 50,874 ( 0.01%)     0            0           50,874 ( 0.05%) 0          0                0          0          0               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             template <typename _InputIterator, typename _ForwardIterator,
      .              .            .                .          .          .                .          .          .           	    typename _Allocator>
      .              .            .                .          .          .                .          .          .               inline _ForwardIterator
170,270 ( 0.04%)     8 ( 0.00%)   5 ( 0.00%)       0          0          0          119,189 ( 0.17%) 0          0               __relocate_a(_InputIterator __first, _InputIterator __last,
      .              .            .                .          .          .                .          .          .           		 _ForwardIterator __result, _Allocator& __alloc)
      .              .            .                .          .          .                .          .          .               noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
      .              .            .                .          .          .                .          .          .           				     std::__niter_base(__last),
      .              .            .                .          .          .                .          .          .           				     std::__niter_base(__result), __alloc)))
      .              .            .                .          .          .                .          .          .               {
289,459 ( 0.07%)   619 ( 0.02%)   8 ( 0.01%)  68,108 ( 0.06%) 0          0           68,108 ( 0.10%) 0          0                 return __relocate_a_1(std::__niter_base(__first),
      .              .            .                .          .          .                .          .          .           			    std::__niter_base(__last),
      .              .            .                .          .          .                .          .          .           			    std::__niter_base(__result), __alloc);
 85,135 ( 0.02%)     0            0           68,108 ( 0.06%) 0          0                0          0          0               }
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             /// @endcond
      .              .            .                .          .          .                .          .          .           #endif
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .             /// @} group memory
      .              .            .                .          .          .                .          .          .           
      .              .            .                .          .          .                .          .          .           _GLIBCXX_END_NAMESPACE_VERSION
      .              .            .                .          .          .                .          .          .           } // namespace
-- line 1057 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/regex_executor.tcc
--------------------------------------------------------------------------------
Ir               I1mr           ILmr         Dr              D1mr         DLmr         Dw              D1mw       DLmw       

-- line 73 ----------------------------------------
      .              .            .               .            .            .               .          .          .             // TODO: This approach is exponentially slow for certain input.
      .              .            .               .            .            .               .          .          .             //       Try to compile the NFA to a DFA.
      .              .            .               .            .            .               .          .          .             //
      .              .            .               .            .            .               .          .          .             // Time complexity: \Omega(match_length), O(2^(_M_nfa.size()))
      .              .            .               .            .            .               .          .          .             // Space complexity: \theta(match_results.size() + match_length)
      .              .            .               .            .            .               .          .          .             //
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _Alloc, typename _TraitsT,
      .              .            .               .            .            .               .          .          .           	   bool __dfs_mode>
 38,740 ( 0.01%) 1,122 ( 0.04%) 155 ( 0.12%)  3,874 ( 0.00%)   0            0          15,496 ( 0.02%) 0          0               bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
      .              .            .               .            .            .               .          .          .               _M_main_dispatch(_Match_mode __match_mode, __dfs)
      .              .            .               .            .            .               .          .          .               {
  7,748 ( 0.00%)     0            0           3,874 ( 0.00%)   0            0           3,874 ( 0.01%) 0          0                 _M_has_sol = false;
 34,866 ( 0.01%)   561 ( 0.02%)   4 ( 0.00%)  7,748 ( 0.01%)   0            0          11,622 ( 0.02%) 0          0                 *_M_states._M_get_sol_pos() = _BiIter();
 23,244 ( 0.01%)     0            0          11,622 ( 0.01%)   0            0           3,874 ( 0.01%) 0          0                 _M_cur_results = _M_results;
 27,118 ( 0.01%)     0            0          15,496 ( 0.01%)   0            0           3,874 ( 0.01%) 0          0                 _M_dfs(__match_mode, _M_states._M_start);
  7,748 ( 0.00%)     0            0           7,748 ( 0.01%)   0            0               0          0          0                 return _M_has_sol;
 19,370 ( 0.00%)   561 ( 0.02%)   2 ( 0.00%) 15,496 ( 0.01%)   0            0               0          0          0               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             // ------------------------------------------------------------
      .              .            .               .            .            .               .          .          .             //
      .              .            .               .            .            .               .          .          .             // BFS mode:
      .              .            .               .            .            .               .          .          .             //
      .              .            .               .            .            .               .          .          .             // Russ Cox's article (http://swtch.com/~rsc/regexp/regexp1.html)
      .              .            .               .            .            .               .          .          .             // explained this algorithm clearly.
      .              .            .               .            .            .               .          .          .             //
-- line 97 ----------------------------------------
-- line 238 ----------------------------------------
      .              .            .               .            .            .               .          .          .           		    _M_rep_once_more(__match_mode, __i);
      .              .            .               .            .            .               .          .          .           		}
      .              .            .               .            .            .               .          .          .           	    }
      .              .            .               .            .            .               .          .          .           	}
      .              .            .               .            .            .               .          .          .               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _Alloc, typename _TraitsT,
      .              .            .               .            .            .               .          .          .           	   bool __dfs_mode>
 42,614 ( 0.01%) 1,122 ( 0.04%)  11 ( 0.01%)  3,874 ( 0.00%)   0            0          19,370 ( 0.03%) 0          0               void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
      .              .            .               .            .            .               .          .          .               _M_handle_subexpr_begin(_Match_mode __match_mode, _StateIdT __i)
      .              .            .               .            .            .               .          .          .               {
 30,992 ( 0.01%)     0            0          11,622 ( 0.01%)   0            0           7,748 ( 0.01%) 0          0                 const auto& __state = _M_nfa[__i];
      .              .            .               .            .            .               .          .          .           
 27,118 ( 0.01%)   561 ( 0.02%)   4 ( 0.00%) 11,622 ( 0.01%) 766 ( 0.16%) 253 ( 0.25%)  7,748 ( 0.01%) 0          0                 auto& __res = _M_cur_results[__state._M_subexpr];
 11,622 ( 0.00%)     0            0           7,748 ( 0.01%)   0            0           3,874 ( 0.01%) 0          0                 auto __back = __res.first;
 15,496 ( 0.00%)     0            0          11,622 ( 0.01%)   0            0           3,874 ( 0.01%) 0          0                 __res.first = _M_current;
 27,118 ( 0.01%)     0            0          15,496 ( 0.01%)   0            0           3,874 ( 0.01%) 0          0                 _M_dfs(__match_mode, __state._M_next);
 11,622 ( 0.00%)     0            0           7,748 ( 0.01%)   0            0           3,874 ( 0.01%) 2 ( 0.00%) 0                 __res.first = __back;
 23,244 ( 0.01%)     0            0          15,496 ( 0.01%)   0            0               0          0          0               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _Alloc, typename _TraitsT,
      .              .            .               .            .            .               .          .          .           	   bool __dfs_mode>
 12,342 ( 0.00%) 1,122 ( 0.04%) 263 ( 0.21%)  1,122 ( 0.00%)   0            0           5,610 ( 0.01%) 0          0               void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
      .              .            .               .            .            .               .          .          .               _M_handle_subexpr_end(_Match_mode __match_mode, _StateIdT __i)
      .              .            .               .            .            .               .          .          .               {
  8,976 ( 0.00%)     0            0           3,366 ( 0.00%)   0            0           2,244 ( 0.00%) 0          0                 const auto& __state = _M_nfa[__i];
      .              .            .               .            .            .               .          .          .           
  7,854 ( 0.00%)     0            0           3,366 ( 0.00%) 149 ( 0.03%)  16 ( 0.02%)  2,244 ( 0.00%) 0          0                 auto& __res = _M_cur_results[__state._M_subexpr];
  7,854 ( 0.00%)   561 ( 0.02%) 217 ( 0.17%)  4,488 ( 0.00%)   0            0           3,366 ( 0.00%) 0          0                 auto __back = __res;
  4,488 ( 0.00%)     0            0           3,366 ( 0.00%)   0            0           1,122 ( 0.00%) 0          0                 __res.second = _M_current;
  2,244 ( 0.00%)     0            0           1,122 ( 0.00%)   0            0           1,122 ( 0.00%) 0          0                 __res.matched = true;
  7,854 ( 0.00%)   561 ( 0.02%) 395 ( 0.31%)  4,488 ( 0.00%)   0            0           1,122 ( 0.00%) 0          0                 _M_dfs(__match_mode, __state._M_next);
  5,610 ( 0.00%)     0            0           1,122 ( 0.00%)   0            0           1,122 ( 0.00%) 0          0                 __res = __back;
  6,732 ( 0.00%)     0            0           4,488 ( 0.00%)   0            0               0          0          0               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _Alloc, typename _TraitsT,
      .              .            .               .            .            .               .          .          .           	   bool __dfs_mode>
      .              .            .               .            .            .               .          .          .               inline void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
      .              .            .               .            .            .               .          .          .               _M_handle_line_begin_assertion(_Match_mode __match_mode, _StateIdT __i)
      .              .            .               .            .            .               .          .          .               {
      .              .            .               .            .            .               .          .          .                 const auto& __state = _M_nfa[__i];
      .              .            .               .            .            .               .          .          .                 if (_M_at_begin())
-- line 279 ----------------------------------------
-- line 309 ----------------------------------------
      .              .            .               .            .            .               .          .          .               {
      .              .            .               .            .            .               .          .          .                 const auto& __state = _M_nfa[__i];
      .              .            .               .            .            .               .          .          .                 if (_M_lookahead(__state._M_alt) == !__state._M_neg)
      .              .            .               .            .            .               .          .          .           	_M_dfs(__match_mode, __state._M_next);
      .              .            .               .            .            .               .          .          .               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _Alloc, typename _TraitsT,
      .              .            .               .            .            .               .          .          .           	   bool __dfs_mode>
 94,000 ( 0.02%)    48 ( 0.00%)  19 ( 0.01%)      0            0            0          47,000 ( 0.07%) 2 ( 0.00%) 0               void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
      .              .            .               .            .            .               .          .          .               _M_handle_match(_Match_mode __match_mode, _StateIdT __i)
      .              .            .               .            .            .               .          .          .               {
 94,000 ( 0.02%)     0            0          35,250 ( 0.03%)   0            0          23,500 ( 0.03%) 0          0                 const auto& __state = _M_nfa[__i];
      .              .            .               .            .            .               .          .          .           
105,750 ( 0.02%)   561 ( 0.02%)   2 ( 0.00%) 23,500 ( 0.02%)   0            0          11,750 ( 0.02%) 0          0                 if (_M_current == _M_end)
      .              .            .               .            .            .               .          .          .           	return;
      .              .            .               .            .            .               .          .          .                 if (__dfs_mode)
      .              .            .               .            .            .               .          .          .           	{
141,000 ( 0.03%)     0            0          35,250 ( 0.03%)   1 ( 0.00%)   0          23,500 ( 0.03%) 0          0           	  if (__state._M_matches(*_M_current))
      .              .            .               .            .            .               .          .          .           	    {
 35,992 ( 0.01%)   561 ( 0.02%)   2 ( 0.00%)  8,998 ( 0.01%)   0            0           8,998 ( 0.01%) 0          0           	      ++_M_current;
 62,986 ( 0.01%)     0            0          35,992 ( 0.03%)   0            0           8,998 ( 0.01%) 0          0           	      _M_dfs(__match_mode, __state._M_next);
 44,990 ( 0.01%)     0            0           8,998 ( 0.01%)   0            0           8,998 ( 0.01%) 0          0           	      --_M_current;
      .              .            .               .            .            .               .          .          .           	    }
      .              .            .               .            .            .               .          .          .           	}
      .              .            .               .            .            .               .          .          .                 else
      .              .            .               .            .            .               .          .          .           	if (__state._M_matches(*_M_current))
      .              .            .               .            .            .               .          .          .           	  _M_states._M_queue(__state._M_next, _M_cur_results);
 23,500 ( 0.01%)     0            0          23,500 ( 0.02%)   0            0               0          0          0               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _TraitsT>
      .              .            .               .            .            .               .          .          .               struct _Backref_matcher
      .              .            .               .            .            .               .          .          .               {
      .              .            .               .            .            .               .          .          .                 _Backref_matcher(bool __icase, const _TraitsT& __traits)
      .              .            .               .            .            .               .          .          .                 : _M_traits(__traits) { }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .                 bool
-- line 344 ----------------------------------------
-- line 417 ----------------------------------------
      .              .            .               .            .            .               .          .          .           	    }
      .              .            .               .            .            .               .          .          .           	  else
      .              .            .               .            .            .               .          .          .           	    _M_dfs(__match_mode, __state._M_next);
      .              .            .               .            .            .               .          .          .           	}
      .              .            .               .            .            .               .          .          .               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _Alloc, typename _TraitsT,
      .              .            .               .            .            .               .          .          .           	   bool __dfs_mode>
 13,464 ( 0.00%) 1,122 ( 0.04%) 212 ( 0.17%)  1,122 ( 0.00%)   0            0           6,732 ( 0.01%) 0          0               void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
      .              .            .               .            .            .               .          .          .               _M_handle_accept(_Match_mode __match_mode, _StateIdT)
      .              .            .               .            .            .               .          .          .               {
      .              .            .               .            .            .               .          .          .                 if (__dfs_mode)
      .              .            .               .            .            .               .          .          .           	{
      .              .            .               .            .            .               .          .          .           	  __glibcxx_assert(!_M_has_sol);
  2,244 ( 0.00%)     0            0           1,122 ( 0.00%)   0            0               0          0          0           	  if (__match_mode == _Match_mode::_Exact)
 11,220 ( 0.00%)   561 ( 0.02%) 233 ( 0.18%)  3,366 ( 0.00%)   0            0           2,244 ( 0.00%) 0          0           	    _M_has_sol = _M_current == _M_end;
      .              .            .               .            .            .               .          .          .           	  else
      .              .            .               .            .            .               .          .          .           	    _M_has_sol = true;
 10,098 ( 0.00%)     0            0           2,244 ( 0.00%)   0            0           1,122 ( 0.00%) 0          0           	  if (_M_current == _M_begin
  3,366 ( 0.00%)   561 ( 0.02%)   4 ( 0.00%)      0            0            0               0          0          0           	      && (_M_flags & regex_constants::match_not_null))
      .              .            .               .            .            .               .          .          .           	    _M_has_sol = false;
  4,488 ( 0.00%)     0            0           2,244 ( 0.00%)   0            0               0          0          0           	  if (_M_has_sol)
      .              .            .               .            .            .               .          .          .           	    {
  5,610 ( 0.00%)   561 ( 0.02%)   1 ( 0.00%)  1,683 ( 0.00%) 465 ( 0.10%) 260 ( 0.26%)    561 ( 0.00%) 0          0           	      if (_M_nfa._M_flags & regex_constants::ECMAScript)
  3,927 ( 0.00%)     0            0           1,683 ( 0.00%)   0            0             561 ( 0.00%) 0          0           		_M_results = _M_cur_results;
      .              .            .               .            .            .               .          .          .           	      else // POSIX
      .              .            .               .            .            .               .          .          .           		{
      .              .            .               .            .            .               .          .          .           		  __glibcxx_assert(_M_states._M_get_sol_pos());
      .              .            .               .            .            .               .          .          .           		  // Here's POSIX's logic: match the longest one. However
      .              .            .               .            .            .               .          .          .           		  // we never know which one (lhs or rhs of "|") is longer
      .              .            .               .            .            .               .          .          .           		  // unless we try both of them and compare the results.
      .              .            .               .            .            .               .          .          .           		  // The member variable _M_sol_pos records the end
      .              .            .               .            .            .               .          .          .           		  // position of the last successful match. It's better
-- line 449 ----------------------------------------
-- line 467 ----------------------------------------
      .              .            .               .            .            .               .          .          .           	    return;
      .              .            .               .            .            .               .          .          .           	  if (__match_mode == _Match_mode::_Prefix || _M_current == _M_end)
      .              .            .               .            .            .               .          .          .           	    if (!_M_has_sol)
      .              .            .               .            .            .               .          .          .           	      {
      .              .            .               .            .            .               .          .          .           		_M_has_sol = true;
      .              .            .               .            .            .               .          .          .           		_M_results = _M_cur_results;
      .              .            .               .            .            .               .          .          .           	      }
      .              .            .               .            .            .               .          .          .           	}
  6,732 ( 0.00%) 1,122 ( 0.04%) 112 ( 0.09%)  5,610 ( 0.01%)   0            0               0          0          0               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _Alloc, typename _TraitsT,
      .              .            .               .            .            .               .          .          .           	   bool __dfs_mode>
      .              .            .               .            .            .               .          .          .               void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
      .              .            .               .            .            .               .          .          .               _M_handle_alternative(_Match_mode __match_mode, _StateIdT __i)
      .              .            .               .            .            .               .          .          .               {
      .              .            .               .            .            .               .          .          .                 const auto& __state = _M_nfa[__i];
      .              .            .               .            .            .               .          .          .           
-- line 483 ----------------------------------------
-- line 498 ----------------------------------------
      .              .            .               .            .            .               .          .          .           	  _M_has_sol = false;
      .              .            .               .            .            .               .          .          .           	  _M_dfs(__match_mode, __state._M_next);
      .              .            .               .            .            .               .          .          .           	  _M_has_sol |= __has_sol;
      .              .            .               .            .            .               .          .          .           	}
      .              .            .               .            .            .               .          .          .               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _Alloc, typename _TraitsT,
      .              .            .               .            .            .               .          .          .           	   bool __dfs_mode>
142,944 ( 0.03%)     0            0               0            0            0          71,472 ( 0.10%) 0          0               void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
      .              .            .               .            .            .               .          .          .               _M_dfs(_Match_mode __match_mode, _StateIdT __i)
      .              .            .               .            .            .               .          .          .               {
142,944 ( 0.03%)     0            0          35,736 ( 0.03%)   0            0          17,868 ( 0.03%) 0          0                 if (_M_states._M_visited(__i))
      .              .            .               .            .            .               .          .          .           	return;
      .              .            .               .            .            .               .          .          .           
339,492 ( 0.08%) 1,122 ( 0.04%)  67 ( 0.05%) 71,472 ( 0.06%) 136 ( 0.03%)   4 ( 0.00%) 35,736 ( 0.05%) 0          0                 switch (_M_nfa[__i]._M_opcode())
      .              .            .               .            .            .               .          .          .           	{
      .              .            .               .            .            .               .          .          .           	case _S_opcode_repeat:
      .              .            .               .            .            .               .          .          .           	  _M_handle_repeat(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_subexpr_begin:
 27,118 ( 0.01%)     0            0          11,622 ( 0.01%)   0            0           3,874 ( 0.01%) 0          0           	  _M_handle_subexpr_begin(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_subexpr_end:
  7,854 ( 0.00%)   561 ( 0.02%)  11 ( 0.01%)  3,366 ( 0.00%)   0            0           1,122 ( 0.00%) 0          0           	  _M_handle_subexpr_end(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_line_begin_assertion:
      .              .            .               .            .            .               .          .          .           	  _M_handle_line_begin_assertion(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_line_end_assertion:
      .              .            .               .            .            .               .          .          .           	  _M_handle_line_end_assertion(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_word_boundary:
      .              .            .               .            .            .               .          .          .           	  _M_handle_word_boundary(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_subexpr_lookahead:
      .              .            .               .            .            .               .          .          .           	  _M_handle_subexpr_lookahead(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_match:
 82,250 ( 0.02%) 1,109 ( 0.04%)  48 ( 0.04%) 35,250 ( 0.03%)   0            0          11,750 ( 0.02%) 0          0           	  _M_handle_match(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_backref:
      .              .            .               .            .            .               .          .          .           	  _M_handle_backref(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_accept:
  7,854 ( 0.00%)   562 ( 0.02%)  59 ( 0.05%)  3,366 ( 0.00%)   0            0           1,122 ( 0.00%) 0          0           	  _M_handle_accept(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	case _S_opcode_alternative:
      .              .            .               .            .            .               .          .          .           	  _M_handle_alternative(__match_mode, __i); break;
      .              .            .               .            .            .               .          .          .           	default:
      .              .            .               .            .            .               .          .          .           	  __glibcxx_assert(false);
      .              .            .               .            .            .               .          .          .           	}
 35,736 ( 0.01%)    16 ( 0.00%)   0          35,736 ( 0.03%)   0            0               0          0          0               }
      .              .            .               .            .            .               .          .          .           
      .              .            .               .            .            .               .          .          .             // Return whether now is at some word boundary.
      .              .            .               .            .            .               .          .          .             template<typename _BiIter, typename _Alloc, typename _TraitsT,
      .              .            .               .            .            .               .          .          .           	   bool __dfs_mode>
      .              .            .               .            .            .               .          .          .               bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
      .              .            .               .            .            .               .          .          .               _M_word_boundary() const
      .              .            .               .            .            .               .          .          .               {
      .              .            .               .            .            .               .          .          .                 if (_M_current == _M_begin && (_M_flags & regex_constants::match_not_bow))
-- line 547 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/new
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr               D1mr       DLmr       Dw               D1mw       DLmw       

-- line 167 ----------------------------------------
        .          .          .                .          .          .                .          .          .             _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
        .          .          .                .          .          .                .          .          .           void operator delete[](void*, std::size_t, std::align_val_t)
        .          .          .                .          .          .                .          .          .             _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
        .          .          .                .          .          .                .          .          .           #endif // __cpp_sized_deallocation
        .          .          .                .          .          .                .          .          .           #endif // __cpp_aligned_new
        .          .          .                .          .          .                .          .          .           
        .          .          .                .          .          .                .          .          .           // Default placement versions of operator new.
        .          .          .                .          .          .                .          .          .           _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
1,077,744 ( 0.25%) 9 ( 0.00%) 1 ( 0.00%) 404,154 ( 0.37%) 0          0          404,154 ( 0.59%) 0          0           { return __p; }
        .          .          .                .          .          .                .          .          .           _GLIBCXX_NODISCARD inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
        .          .          .                .          .          .                .          .          .           { return __p; }
        .          .          .                .          .          .                .          .          .           
        .          .          .                .          .          .                .          .          .           // Default placement versions of operator delete.
        .          .          .                .          .          .                .          .          .           inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
        .          .          .                .          .          .                .          .          .           inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
        .          .          .                .          .          .                .          .          .           //@}
        .          .          .                .          .          .                .          .          .           } // extern "C++"
-- line 183 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../sysdeps/x86_64/dl-machine.h
  ./elf/./elf/dl-lookup.c
  ./malloc/./malloc/arena.c
  ./malloc/./malloc/malloc.c
  ./socket/../sysdeps/unix/sysv/linux/send.c
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S

--------------------------------------------------------------------------------
Ir                  I1mr             ILmr            Dr                  D1mr            DLmr           Dw                  D1mw           DLmw           
--------------------------------------------------------------------------------
49,137,137 (11.39%) 294,733 (10.91%) 33,889 (26.55%) 16,356,847 (14.81%) 21,555 ( 4.59%) 5,809 ( 5.72%) 13,413,575 (19.58%) 6,694 ( 2.72%) 1,660 ( 2.02%)  events annotated

